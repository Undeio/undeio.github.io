<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="Oe5X3we6LueobdVkYt_0OWN2MKIdhLA1ABWWwBtCInI"><meta name="baidu-site-verification" content="code-cAwJVzSa3d"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"undeio.me",root:"/",images:"/images",scheme:"Gemini",version:"8.2.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,width:300},copycode:!0,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"},path:"/search.xml",localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!0}}</script><meta name="description" content="记录逆向工程核心原理一书中对PE 文件格式的描述，辅助阅读加密解密第 11 章节，补充、印证，加强学习，同时作为备忘，初始对很多内容理解不够深刻且容易忘记，日后需多加练习；  使用工具 OllyDbg 1.1 原版，简称OD； OD 汉化和插件均来自互联网； WinHEX来自互联网； 文中所有数字均是HEX，为了书写方便采用DEC；"><meta property="og:type" content="article"><meta property="og:title" content="PE 文件格式"><meta property="og:url" content="https://undeio.me/post/1876828466/"><meta property="og:site_name" content="池塘·半亩"><meta property="og:description" content="记录逆向工程核心原理一书中对PE 文件格式的描述，辅助阅读加密解密第 11 章节，补充、印证，加强学习，同时作为备忘，初始对很多内容理解不够深刻且容易忘记，日后需多加练习；  使用工具 OllyDbg 1.1 原版，简称OD； OD 汉化和插件均来自互联网； WinHEX来自互联网； 文中所有数字均是HEX，为了书写方便采用DEC；"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnqc1thiodj316q0u0q5s.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnqcbjzm65j31360ai74r.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnqcqnwemej316p0u0go5.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnqokc8tzsj31640dgq4k.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnrfb7n93aj316u0u00vu.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnrfz6q5lqj316w0u0mzs.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnsqzcsjsnj316r0u041k.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnsrf4o9j1j316q0u0dih.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnsypkauskj316x0u0wgw.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnsz701irwj316u0u0tbj.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnszcrj5gij316x0u00vr.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnsznj6kkfj316m0u041z.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnt02pzailj316s0u0n09.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnt0aevkwrj316s0u0dim.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntuzfk614j316s0u0q5d.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntv12k5gvj316i0u0773.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntv5oue9xj316t0u0diu.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntvbhgjx1j316q0u0n00.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntvei6fjpj316q0u0acp.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntvlbcvxfj31b40u0tbx.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntvp6hfftj316j0u00vk.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntvr1cbzqj316s0u041i.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntvuyl8g5j316x0u0acs.jpg"><meta property="article:published_time" content="2020-07-05T07:16:34.000Z"><meta property="article:modified_time" content="2020-07-05T07:16:34.000Z"><meta property="article:author" content="Undeio"><meta property="article:tag" content="PE"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnqc1thiodj316q0u0q5s.jpg"><link rel="canonical" href="https://undeio.me/post/1876828466/"><script data-pjax class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>PE 文件格式 | 池塘·半亩</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?1dca64bee6b4ddd8e5704b56999cb693";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">池塘·半亩</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">业精于勤，荒于嬉。行成于思，毁于随。</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="nav-number">1.</span> <span class="nav-text">使用工具</span></a></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#PE-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">PE 文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PE-%E6%96%87%E4%BB%B6%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">PE 文件种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VA-amp-RVA"><span class="nav-number">3.</span> <span class="nav-text">VA &amp; RVA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PE-%E5%A4%B4"><span class="nav-number"></span> <span class="nav-text">PE 头</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DOS-%E5%A4%B4"><span class="nav-number">1.</span> <span class="nav-text">DOS 头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOS-%E5%AD%98%E6%A0%B9"><span class="nav-number">2.</span> <span class="nav-text">DOS 存根</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NT-%E5%A4%B4%EF%BC%88PE-Header%EF%BC%8CPE-%E5%A4%B4%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">NT 头（PE Header，PE 头）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NT-%E5%A4%B4%EF%BC%9A%E6%96%87%E4%BB%B6%E5%A4%B4-IMAGE-FILE-HEADER"><span class="nav-number">4.</span> <span class="nav-text">NT 头：文件头 IMAGE_FILE_HEADER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NT-%E5%A4%B4%EF%BC%9A%E5%8F%AF%E9%80%89%E5%A4%B4-IMAGE-OPTIONAL-HEADER"><span class="nav-number">5.</span> <span class="nav-text">NT 头：可选头 IMAGE_OPTIONAL_HEADER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E5%8C%BA%E5%A4%B4-IMAGE-SECTION-HEADER-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="nav-number">6.</span> <span class="nav-text">节区头 IMAGE_SECTION_HEADER 结构体数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RVA-to-RAW"><span class="nav-number"></span> <span class="nav-text">RVA to RAW</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IAT%EF%BC%88Import-Address-Table%EF%BC%8C%E5%AF%BC%E5%85%A5%E5%9C%B0%E5%9D%80%E8%A1%A8%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">IAT（Import Address Table，导入地址表）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DLL%EF%BC%88Dynamic-Link-Library%EF%BC%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">DLL（Dynamic Link Library，动态链接库）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">输入函数的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IMAGE-IMPORT-DESCRIPTOR"><span class="nav-number">3.</span> <span class="nav-text">IMAGE_IMPORT_DESCRIPTOR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5-NOTEPAD-EXE-%E4%B8%BA%E4%BE%8B%EF%BC%8C%E6%A2%B3%E7%90%86%E6%80%9D%E8%B7%AF%EF%BC%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0"><span class="nav-number">4.</span> <span class="nav-text">以 NOTEPAD.EXE 为例，梳理思路，强化学习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EAT%EF%BC%88Export-Address-Table%EF%BC%8C%E5%AF%BC%E5%87%BA%E5%9C%B0%E5%9D%80%E8%A1%A8%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">EAT（Export Address Table，导出地址表）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IMAGE-EXPORT-DESCRIPTOR"><span class="nav-number">1.</span> <span class="nav-text">IMAGE_EXPORT_DESCRIPTOR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5-KERNEL32-DLL-%E4%B8%BA%E4%BE%8B%EF%BC%8C%E6%A2%B3%E7%90%86%E6%80%9D%E8%B7%AF%EF%BC%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0"><span class="nav-number">2.</span> <span class="nav-text">以 KERNEL32.DLL 为例，梳理思路，强化学习</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Undeio" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Undeio</p><div class="site-description" itemprop="description">也许似乎大概是，然而未必不见得。</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">28</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/Undeio" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Undeio" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="mailto:sean_link@live.com" title="E-Mail → mailto:sean_link@live.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js server="tencent" type="playlist" id="714421782" order="random" list-max-height="146px"></meting-js></div></div><div class="back-to-top animated" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class="sidebar-dimmer"></div></header><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://undeio.me/post/1876828466/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Undeio"><meta itemprop="description" content="也许似乎大概是，然而未必不见得。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="池塘·半亩"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">PE 文件格式</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-07-05 15:16:34" itemprop="dateCreated datePublished" datetime="2020-07-05T15:16:34+08:00">2020-07-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">逆向工程</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>记录<a target="_blank" rel="noopener external nofollow noreferrer" href="https://reversecore.com/">逆向工程核心原理</a>一书中对<code>PE 文件格式</code>的描述，辅助阅读<a target="_blank" rel="noopener external nofollow noreferrer" href="https://bbs.pediy.com/forum-99.htm">加密解密</a>第 11 章节，补充、印证，加强学习，同时作为备忘，初始对很多内容理解不够深刻且容易忘记，日后需多加练习；</p></blockquote><h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul><li>OllyDbg 1.1 原版，简称<code>OD</code>；</li><li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li><li><code>WinHEX</code>来自互联网；</li><li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li></ul><a id="more"></a><h3 id="PE-文件格式"><a href="#PE-文件格式" class="headerlink" title="PE 文件格式"></a>PE 文件格式</h3><p>PE 文件是 Windows 操作系统下的可执行文件格式；</p><p>是微软在 UNIX 平台的 COFF（Common Object File Format，通用对象文件格式）基础上制作而成的；</p><p>在 Win16 平台上，可执行文件格式是 NE；</p><p>在 Win32 平台上，可执行文件格式是 PE（Portable Executable File Format，可移植的执行体）；</p><p>PE 文件是指 32 位的可执行文件，也称为 PE32；</p><p>64 位的可执行文件称为 PE+ 或 PE32+，是 PE 文件的一种扩展形式，而不是 PE64；</p><blockquote><p>Tips：⚠️ 为当前参数列表需重点关注</p></blockquote><h4 id="PE-文件种类"><a href="#PE-文件种类" class="headerlink" title="PE 文件种类"></a>PE 文件种类</h4><table><thead><tr><th align="center">种类</th><th align="center">主扩展名</th></tr></thead><tbody><tr><td align="center">可执行系列</td><td align="center">EXE、SCR</td></tr><tr><td align="center">库系列</td><td align="center">DLL、OCX、CPL、DRV</td></tr><tr><td align="center">驱动程序系列</td><td align="center">SYS、VXD</td></tr><tr><td align="center">对象文件系列</td><td align="center">OBJ</td></tr></tbody></table><p>除 OBJ 文件之外的所有文件都是可执行的；</p><p>EXE 文件和 DLL 文件的区别完全是语义上的，它们使用完全相同的 PE 格式，唯一的区别就是用一个字段标识出这个文件是 EXE 还是 DLL；</p><p>DLL、SYS 文件等虽然不能直接在 Shell 中运行，但可以使用其它方法执行；</p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>PE 文件使用的是一个平面地址空间，所有代码和数据都合并在一起，组成一个很大的结构；</p><p>文件的内容被分割为不同的区块（Section，又称区段、节等）；</p><p>区块中包含代码或数据，各个区块按页边界对齐；</p><p>区块没有大小限制，是一个连续结构；</p><p>每区个块都有它自己在内存中的一套属性，如：是否包含代码、是否只读或可读/写等；</p><p>Windows 加载器（又称 PE 装载器）遍历 PE 文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移地址映射到较高的内存地址中；</p><p>磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的，但数据之间的相对位置可能会改变，某项的偏移地址可能区别于原始的偏移地址；</p><p>当 PE 文件通过 Windows 加载器载入内存后，内存中的版本称为模块（Module）；</p><p>映射文件的起始地址称为模块句柄（hModule），可以通过模块句柄访问内存中的其它数据结构，这个初始内存地址也称为基地址（ImageBase）；</p><p>基地址的值是由 PE 文件本身设定的，按照默认设置，用 Visual C++ 建立的 EXE 文件的基地址是 00400000，DLL 文件的基地址是 10000000；</p><p>从 DOS 头到节区头是 PE 头部分，称为 PE 头，下面的节区合称 PE 体；</p><p>文件中使用偏移（offset），内存中使用 VA（Virtual Address，虚拟地址）来表示位置；</p><p>文件加载到内存时，节区的大小、位置等会发生变化；</p><p>文件的内容一般可以分为代码（.text）、数据（.data）、资源（.src）节，分别保存；</p><p>根据所用的不同开发工具与编译选项，节区的名称、大小、个数、存储的内容等都是不同的，它们按照不同的用途，分类保存到不同的节中；</p><p>各节区头定义了各节区在文件或内存中的大小、位置、属性等；</p><p>PE 头与各节区的尾部存在一个区域，称为 NULL 填充，也就是 PE 头与各节区以 NULL 分割；</p><p>计算机中，为了提高处理文件、内存、网络包的效率，使用“最小基本单位”这一概念，PE 文件也类似；</p><p>文件 / 内存中各节区的起始位置应该在各文件 / 内存的最小单位的倍数位置上，空白区域将用 NULL 填充；</p><h4 id="VA-amp-RVA"><a href="#VA-amp-RVA" class="headerlink" title="VA &amp; RVA"></a>VA &amp; RVA</h4><p>在 Windows 系统中，PE 文件将被系统加载器映射到内存中；</p><p>每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址（Virtual Address，VA）；</p><p>VA（Virtual Address，虚拟地址） 指的是进程虚拟内存的绝对地址；</p><p>RVA（Relative Virtual Address，相对虚拟地址）指的是从基准位置（ImageBase）开始的相对地址；</p><p>VA 与 RVA 之间的关系：虚拟地址（VA） = 相对虚拟地址（RVA） + 基地址（ImageBase）；</p><p>PE 头内部信息大多以 RVA 形式存在；</p><p>原因在于，PE 文件（主要是 DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其它 PE 文件（DLL）；</p><p>此时，必须通过重定位将其加载到其它空白的位置，若 PE 头信息使用的是 VA，则无法正常访问；</p><p>因此使用 RVA 来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题；</p><p>这么看和栈帧类似啊，基于 EBP 而不是 ESP，原因就是 ESP 在程序运行中不断变化；</p><p>32 位 Windows 系统中，各进程分配有 4GB 的虚拟内存，因此进程中 VA 值的范围是 00000000 ～ FFFFFFFF；</p><h3 id="PE-头"><a href="#PE-头" class="headerlink" title="PE 头"></a>PE 头</h3><p>PE 头由许多结构体组成；</p><h4 id="DOS-头"><a href="#DOS-头" class="headerlink" title="DOS 头"></a>DOS 头</h4><p>每个 PE 文件都是以一个 DOS 程序开始的，有了它，一旦程序在 DOS 下执行，DOS 就能识别出这是一个有效的执行体，然后运行紧随 MZ Header 的 DOS stub（DOS 块）；</p><p>DOS stub（DOS 存根） 实际上是一个有效的 EXE，在不支持 PE 文件格式的操作系统中，它将简单的显示一个错误提示；</p><p>通常把 DOS MZ 头与 DOS stub 合并称为 DOS 头；</p><p>微软创建 PE 文件格式时，广泛使用的是 DOS 文件，考虑到 PE 文件对 DOS 文件的兼容性，在 PE 头的最前面添加了一个 IMAGE_DOS_HEADER 结构体，用来扩展已有的 DOS EXE 头；</p><p>IMAGE_DOS_HEADER 结构体的大小为 64 字节，在该结构体中必须知道 2 个重要的成员：</p><ul><li>e_magic：DOS 签名（Signature，4D5A，对应的 ASCII 值是“MZ”），也称为 DOS MZ 头；</li><li>e_lfanew：指示 NT 头的偏移（根据不同文件拥有可变值），是真正的 PE 文件头的相对偏移（RVA）位置，占用 4 个字节，位于从文件开始偏移 3C 字节处；</li></ul><p>所有 PE 文件在开始部分（e_magic）都有 DOS 签名（5A4D，“MZ”）；</p><p>一个名叫 Mark Zbikowski 的开发人员在微软设计了 DOS 可执行文件，MZ 取自其名字的首字母；</p><p>e_lfanew 值指向 NT 头所在位置（NT 头的名称为 IMAGE_NT_HEADERS）;</p><p>NOTEPAD.EXE 的 IMAGE_DOS_HEADER 结构体：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqc1thiodj316q0u0q5s.jpg" alt="IMAGE_DOS_HEADER"></p><p>文件开始的 2 个字节为 5A4D，e_lfanew 值为 000000E0（Intel x86 CPU，小端序标识法）；</p><h4 id="DOS-存根"><a href="#DOS-存根" class="headerlink" title="DOS 存根"></a>DOS 存根</h4><p>DOS 存根（stub）位于 DOS 头下方，是可选项，且大小不固定；</p><p>DOS 存根由代码与数据混合而成；</p><p>NOTEPAD.EXE 的 DOS 存根：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqcbjzm65j31360ai74r.jpg" alt="NOTEPAD.EXE 的 DOS 存根"></p><h4 id="NT-头（PE-Header，PE-头）"><a href="#NT-头（PE-Header，PE-头）" class="headerlink" title="NT 头（PE Header，PE 头）"></a>NT 头（PE Header，PE 头）</h4><p>NT 头的名称为 IMAGE_NT_HEADERS；</p><p>IMAGE_NT_HEADERS 结构体由 3 个成员组成，第一个成员为签名（Signature）结构体，其值为 50450000（“PE”00），另外两个成员分别为文件头（File Header）与可选头（Optional Header）结构体；</p><p>IMAGE_NT_HEADERS 结构体：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqcqnwemej316p0u0go5.jpg" alt="IMAGE_NT_HEADERS 结构体"></p><p>IMAGE_NT_HEADERS 结构体的大小为 F8，相当大；</p><h4 id="NT-头：文件头-IMAGE-FILE-HEADER"><a href="#NT-头：文件头-IMAGE-FILE-HEADER" class="headerlink" title="NT 头：文件头 IMAGE_FILE_HEADER"></a>NT 头：文件头 IMAGE_FILE_HEADER</h4><p>文件头是表现文件大致属性的 IMAGE_FILE_HEADER 结构体；</p><p>IMAGE_FILE_HEADER 结构体的成员：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqokc8tzsj31640dgq4k.jpg" alt="IMAGE_FILE_HEADER 结构体的成员"></p><p>以下成员的前 4 个非常重要，若设置不正确，将导致文件无法正常运行：（偏移量基于 PE 文件头 （IMAGE_NT_HEADERS））</p><table><thead><tr><th align="center">偏移量</th><th align="center">字段</th><th align="center">Size</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">Machine</td><td align="center">WORD</td><td align="center">运行平台</td></tr><tr><td align="center">6</td><td align="center">NumberOfSections</td><td align="center">WORD</td><td align="center">文件的区块数</td></tr><tr><td align="center">14</td><td align="center">SizeOfOptionalHeader</td><td align="center">WORD</td><td align="center">IMAGE_OPTIONAL_HEADER 结构体的大小</td></tr><tr><td align="center">16</td><td align="center">Characteristics</td><td align="center">WORD</td><td align="center">文件属性</td></tr><tr><td align="center">8</td><td align="center">TimeDateStamp</td><td align="center">DWORD</td><td align="center">文件创建时间</td></tr><tr><td align="center">C</td><td align="center">PointerToSymbolTable</td><td align="center">DWORD</td><td align="center">指向符号表</td></tr><tr><td align="center">10</td><td align="center">NumberOfSymbols</td><td align="center">DWORD</td><td align="center">符号表中符号的数量</td></tr></tbody></table><ol><li><p>Machine：每个 CPU 都拥有唯一的 Machine 码，兼容 32 位 Intel x86 芯片的 Machine 码为 14C，具体定义位于 winnt.h；</p><p>几种典型的机器类型标志：</p><table><thead><tr><th align="center">机器</th><th align="center">标志</th></tr></thead><tbody><tr><td align="center">Intel i386</td><td align="center">14C</td></tr><tr><td align="center">MIPS R3000</td><td align="center">162</td></tr><tr><td align="center">MIPS R4000</td><td align="center">166</td></tr><tr><td align="center">Alpha AXP</td><td align="center">184</td></tr><tr><td align="center">Power PC</td><td align="center">1F0</td></tr></tbody></table></li><li><p>NumberOfSections：用来指出文件中存在的节区（Section）数量，该值一定要大于 0，且当定义的节区数量与实际数量不同时，将发生运行错误；</p></li><li><p>SizeOfOptionalHeader：IMAGE_NT_HEADERS 结构体的最后一个成员为 IMAGE_OPTIONAL_HEADER 结构体，SizeOfOptionalHeader 成员用来指出 IMAGE_OPTIONAL_HEADER 结构体的长度，表示数据的大小；</p><p>Windows 的 PE 装载器需要查看 IMAGE_FILE_HEADER 的 SizeOfOptionalHeader 值，从而识别出 IMAGE_OPTIONAL_HEADER 结构体的大小；</p><p>PE32+ 格式的文件中使用的是 IMAGE_OPTIONAL_HEADER64 结构体，而不是 IMAGE_OPTIONAL_HEADER32 结构体；</p><p>IMAGE_OPTIONAL_HEADER64 与 IMAGE_OPTIONAL_HEADER32 两个结构体的尺寸不同，所以需要在 SizeOfOptionalHeader 成员中明确指出结构体的大小；</p><p>IMAGE_OPTIONAL_HEADER 的大小依赖于当前 PE 文件是 32 位还是 64 位；</p><p>对于 32 位 PE 文件，这个域通常是 00E0；<br>对于 64 位 PE 文件，这个域通常是 00F0；</p></li><li><p>Characteristics：用于标识文件的属性，文件是否为可运行的形态、是否为 DLL 文件等信息，具体定义位于 winnt.h；</p><p>属性位字段的含义：</p><table><thead><tr><th align="center">特征值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0001</td><td align="center">文件中不存在重定位信息</td></tr><tr><td align="center">0002</td><td align="center">文件可执行，如果为 0，一般是链接时出问题了 ⚠️</td></tr><tr><td align="center">0004</td><td align="center">行号信息被移除</td></tr><tr><td align="center">0008</td><td align="center">符号信息被移除</td></tr><tr><td align="center">0020</td><td align="center">应用程序可以处理超过 2GB 的地址</td></tr><tr><td align="center">0080</td><td align="center">处理机的低位字节是相反的</td></tr><tr><td align="center">0100</td><td align="center">目标平台为 32 位机器</td></tr><tr><td align="center">0200</td><td align="center">.DBG 文件的调试信息被移除</td></tr><tr><td align="center">0400</td><td align="center">如果映像文件位于可移动介质中，则先复制到交换文件中再运行</td></tr><tr><td align="center">0800</td><td align="center">如果映像文件位于网络中，则复制到交换文件后才运行</td></tr><tr><td align="center">1000</td><td align="center">系统文件</td></tr><tr><td align="center">2000</td><td align="center">文件是 DLL ⚠️</td></tr><tr><td align="center">4000</td><td align="center">文件只能运行在单处理器上</td></tr><tr><td align="center">8000</td><td align="center">处理机的高位字节是相反的</td></tr></tbody></table></li><li><p>TimeDateStamp：用来记录编译器创建此文件的时间；</p></li><li><p>PointerToSymbolTable：COFF 符号表的文件偏移位置，若没有符号表存在，将此值设置为 0；</p></li><li><p>NumberOfSymbols：如果有符号表，它表示其中的符号数目；</p></li></ol><h4 id="NT-头：可选头-IMAGE-OPTIONAL-HEADER"><a href="#NT-头：可选头-IMAGE-OPTIONAL-HEADER" class="headerlink" title="NT 头：可选头 IMAGE_OPTIONAL_HEADER"></a>NT 头：可选头 IMAGE_OPTIONAL_HEADER</h4><p>IMAGE_OPTIONAL_HEADER32 是 PE 头结构体中最大的；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrfb7n93aj316u0u00vu.jpg" alt="IMAGE_OPTIONAL_HEADER32"></p><p>首先在 DOS 头中找到 PE 头（NT 头）的偏移量，然后黄色表示的是签名（IMAGE_NT_SIGNATURE）结构体，红色表示 IMAGE_FILE_HEADER 结构体，黑色和蓝色表示 IMAGE_OPTIONAL_HEADER32 结构体，其中，黑色为 IMAGE_OPTIONAL_HEADER32 结构体中需要重点关注的部分（DataDirectory 成员未标注）；</p><p>在 IMAGE_OPTIONAL_HEADER32 结构体中需要关注下列成员，这些成员是文件运行必需的，设置错误将导致文件无法正常运行：（偏移量基于 PE 文件头 （IMAGE_NT_HEADERS））</p><table><thead><tr><th align="center">偏移量</th><th align="center">字段</th><th align="center">Size</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">18</td><td align="center">Magic</td><td align="center">WORD</td><td align="center">标志字</td></tr><tr><td align="center">28</td><td align="center">AddressOfEntryPoint</td><td align="center">DWORD</td><td align="center">程序执行入口 RVA</td></tr><tr><td align="center">34</td><td align="center">ImageBase</td><td align="center">DWORD</td><td align="center">程序默认载入基地址</td></tr><tr><td align="center">38</td><td align="center">SetionAlignment</td><td align="center">DWORD</td><td align="center">内存中区块的对齐值</td></tr><tr><td align="center">3C</td><td align="center">FileAlignment</td><td align="center">DWORD</td><td align="center">文件中区块的对齐值</td></tr><tr><td align="center">50</td><td align="center">SizeOfImage</td><td align="center">DWORD</td><td align="center">映像载入内存后的总尺寸</td></tr><tr><td align="center">54</td><td align="center">SizeOfHeaders</td><td align="center">DWORD</td><td align="center">整个 PE 头的大小</td></tr><tr><td align="center">5C</td><td align="center">Subsystem</td><td align="center">WORD</td><td align="center">文件子系统</td></tr><tr><td align="center">74</td><td align="center">NumberOfRvaAndSizes</td><td align="center">DWORD</td><td align="center">数据目录表的项数</td></tr><tr><td align="center">78</td><td align="center">DataDirectory</td><td align="center"></td><td align="center">数据目录表</td></tr></tbody></table><ol><li><p>Magic：为 IMAGE_OPTIONAL_HEADER32 结构体时，Magic 码为 10B；为 IMAGE_OPTIONAL_HEADER64 结构体时，Magic 码为 20B，文件为 ROM 映像时，Magic 码为 107；</p></li><li><p>AddressOfEntryPoint：持有 EP 的 RVA 值，该值指出程序最先执行的代码的起始地址，非常重要；</p></li><li><p>ImageBase：进程的虚拟内存范围是 00000000 ～ FFFFFFFF（32 位系统），PE 文件被加载到如此大的内存中时，ImageBase 指出文件的优先装载地址，而 ImageBase 就是文件在内存中的首选载入地址，如果 PE 文件是在这个地址载入的，那么加载器将跳过应用基址重定位的步骤；</p><ul><li>EXE、DLL 文件被装载到用户内存的 00000000 ～ 7FFFFFFF 中；</li><li>SYS 文件被装载到内核内存的 80000000 ～ FFFFFFFF 中；</li><li>一般而言，使用开发工具创建的 EXE 文件，其默认 ImageBase 值为 00400000，DLL 文件的 ImageBase 值为 10000000；（可以指定为其它值）</li><li>执行 PE 文件时，PE 装载器先创建进程，再将文件载入内存，然后把 EIP 寄存器的值设置为 <code>ImageBase + AddressOfEntryPoint</code>；</li></ul></li><li><p>SetionAlignment / FileAlignment</p><p>PE 体，也就是 PE 的 Body 部分划分为若干个节区，这些节区存储着不同类别的数据；</p><p>SetionAlignment 指定了节区在内存中的最小单位，每个节区被载入的地址必定是此字段指定数值的整数倍；默认的对齐尺寸是目标 CPU 的页尺寸；</p><p>FileAlignment 指定了节区在磁盘文件中的最小单位，组成块的原始数据必须保证从本字段的倍数地址开始；</p><p>一个文件中，FileAlignment 与 SetionAlignment 的值可能相同，也可能不相同；</p><p>磁盘文件或内存的节区大小必定为 FileAlignment 或 SetionAlignment 值的整数倍；</p></li><li><p>SizeOfImage：加载 PE 文件到内存时，SizeOfImage 指定了 PE Image 在虚拟内存中所占空间的大小；</p><p>映像载入内存后的总尺寸，是指载入文件从 ImageBase 到最后一个块的大小，最后一个块根据其大小向上取整；</p><p>一般而言，文件的大小与加载到内存中的大小是不同的（节区头中定义了各节装载的位置与占有内存的大小）；</p></li><li><p>SizeOfHeaders：用来指出整个 PE 头的大小，该值必需是 FileAlignment 的整数倍；</p><p>MS-DOS 头部、PE 文件头、区块表的总尺寸，域值四舍五入至文件对齐值的倍数；</p><p>第一节区所在位置与 SizeOfHeaders 距文件开始偏移的量相同；</p></li><li><p>Subsystem：用来区分系统驱动文件（*.sys）与普通的可执行文件（*.exe，*.dll）；</p><p>一个标明可执行文件所期望的子系统（用户界面类型）的枚举值，这个值只对 EXE 重要；</p><p>成员值如下：</p><table><thead><tr><th align="center">值</th><th align="center">含义</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center"></td><td align="center">未知</td></tr><tr><td align="center">1</td><td align="center">Driver 文件</td><td align="center">不需要子系统，系统驱动（如：ntfs.sys）</td></tr><tr><td align="center">2</td><td align="center">GUI 文件</td><td align="center">图形接口子系统，窗口应用程序（如：notepad.exe）</td></tr><tr><td align="center">3</td><td align="center">GUI 文件</td><td align="center">字符子系统，控制台应用程序（如：cmd.exe）</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">OS/2 字符子系统</td></tr><tr><td align="center">7</td><td align="center"></td><td align="center">POSIX 字符子系统</td></tr><tr><td align="center">8</td><td align="center"></td><td align="center">保留</td></tr><tr><td align="center">9</td><td align="center"></td><td align="center">Windows CE 图形界面</td></tr></tbody></table></li><li><p>NumberOfRvaAndSizes：用来指定 DataDirectory 数组的个数；</p><p>数据目录表（DataDirectory）的项数，这个字段的值从 Windows NT 发布以来一直是 16；</p><p>PE 装载器通过查看 NumberOfRvaAndSizes 的值来识别数组大小；</p></li><li><p>DataDirectory：是由 IMAGE_DATA_DIRECTORY 结构体组成的数组，数组的每项都有被定义的值，指向输出表、输入表、资源块等数据；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrfz6q5lqj316w0u0mzs.jpg" alt="DataDirectory"></p><p>数据目录表的每个成员占 8 个字节，分别指向相关的结构体，前 4 个字节表示地址，后 4 个字节表示大小，最后一个成员必须为 0；</p><table><thead><tr><th align="center">序号</th><th align="left">成员</th><th align="left">结构</th><th align="center">偏移量（PE / PE32+）</th></tr></thead><tbody><tr><td align="center">0</td><td align="left">Export Table ⚠️</td><td align="left">IMAGE_DIRECTORY_ENTRY_EXPORT</td><td align="center">78 / 88</td></tr><tr><td align="center">1</td><td align="left">Import Table ⚠️</td><td align="left">IMAGE_DIRECTORY_ENTRY_IMPORT</td><td align="center">80 / 90</td></tr><tr><td align="center">2</td><td align="left">Resources Table ⚠️</td><td align="left">IMAGE_DIRECTORY_ENTRY_RESOURCE</td><td align="center">88 / 98</td></tr><tr><td align="center">3</td><td align="left">Exception Table</td><td align="left">IMAGE_DIRECTORY_ENTRY_EXCEPTION</td><td align="center">90 / A0</td></tr><tr><td align="center">4</td><td align="left">Security Table</td><td align="left">IMAGE_DIRECTORY_ENTRY_SECURITY</td><td align="center">98 / A8</td></tr><tr><td align="center">5</td><td align="left">Base relocation Table</td><td align="left">IMAGE_DIRECTORY_ENTRY_BASERELOC</td><td align="center">A0 / B0</td></tr><tr><td align="center">6</td><td align="left">Debug</td><td align="left">IMAGE_DIRECTORY_ENTRY_DEBUG</td><td align="center">A8 / B8</td></tr><tr><td align="center">7</td><td align="left">Copyright</td><td align="left">IMAGE_DIRECTORY_ENTRY_COPYRIGHT</td><td align="center">B0 / C0</td></tr><tr><td align="center">8</td><td align="left">Global Ptr</td><td align="left">IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td><td align="center">B8 / C8</td></tr><tr><td align="center">9</td><td align="left">Thread local storage (TLS) ⚠️</td><td align="left">IMAGE_DIRECTORY_ENTRY_TLS</td><td align="center">C0 / D0</td></tr><tr><td align="center">10</td><td align="left">Load configuration</td><td align="left">IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td><td align="center">C8 / D8</td></tr><tr><td align="center">11</td><td align="left">Bound Import</td><td align="left">IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td><td align="center">D0 / E0</td></tr><tr><td align="center">12</td><td align="left">Import Address Table (IAT) ⚠️</td><td align="left">IMAGE_DIRECTORY_ENTRY_IAT</td><td align="center">D8 / E8</td></tr><tr><td align="center">13</td><td align="left">Delay Import</td><td align="left">IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td><td align="center">E0 / F0</td></tr><tr><td align="center">14</td><td align="left">COM descriptor</td><td align="left">IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td><td align="center">E8 / F8</td></tr><tr><td align="center">15</td><td align="left">保留，必须为 0</td><td align="left"></td><td align="center">F0 / 100</td></tr></tbody></table><p>PE 文件在定位输出表、输入表和资源表等重要数据时，就是从 IMAGE_DATA_DIRECTORY 结构体开始的；</p></li></ol><h4 id="节区头-IMAGE-SECTION-HEADER-结构体数组"><a href="#节区头-IMAGE-SECTION-HEADER-结构体数组" class="headerlink" title="节区头 IMAGE_SECTION_HEADER 结构体数组"></a>节区头 IMAGE_SECTION_HEADER 结构体数组</h4><p>PE 文件中的 code（代码）、data（数据）、resource（资源）等按照属性分类存储在不同节区；</p><p>节区头中定义了各节区属性；</p><p>节区属性中有文件 / 内存的起始位置、大小、访问权限等；</p><p>不同内存属性的访问权限：</p><table><thead><tr><th align="center">类别</th><th align="center">访问权限</th></tr></thead><tbody><tr><td align="center">code</td><td align="center">执行，读取权限</td></tr><tr><td align="center">data</td><td align="center">非执行，读写权限</td></tr><tr><td align="center">resource</td><td align="center">非执行，读取权限</td></tr></tbody></table><p>节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组，每个结构体对应一个节区，每个结构体包含它所关联区块的信息，如位置、长度、属性等，该数组的数目由 IMAGE_NT_HEADERS.IMAGE_FILE_HEADER.NumberOfSections 指出；</p><p>IMAGE_SECTION_HEADER 结构体中的重要成员：</p><table><thead><tr><th align="center">项目</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">VirtualSize</td><td align="center">内存中节区所占大小</td></tr><tr><td align="center">VirtualAddress</td><td align="center">内存中节区起始位置（RVA）</td></tr><tr><td align="center">SizeOfRawData</td><td align="center">磁盘文件中节区所占大小</td></tr><tr><td align="center">PointerToRawData</td><td align="center">磁盘文件中节区起始位置</td></tr><tr><td align="center">Characteristics</td><td align="center">节区属性（bit OR）</td></tr></tbody></table><ol><li><p>VirtualSize：指出实际被使用的区块的大小，是在进行对齐处理前区块的实际大小；</p></li><li><p>VirtualAddress：该块装载到内存中的 RVA，这个地址是按照内存页对齐的，它的数值总是 SectionAlignment 的整数倍；</p></li><li><p>SizeOfRawData：该块在磁盘中所占的空间，在可执行文件中，该字段包含经 FileAlignment 调整的块的大小；</p></li><li><p>PointerToRawData：该块在磁盘文件中的偏移，程序经编译或汇编后生成原始数据，这个字段用于给出原始数据在文件中的偏移；</p><p>如果程序装载自 PE 或 COFF 文件（而不是由操作系统载入的），这一字段将比 VirtualAddress 还重要，在这种情况下，必须完全使用线性映像的方法载入文件，所以需要在该偏移处找到块的数据，而不是 VirtualAddress 字段中的 RVA 地址；</p></li><li><p>Characteristics：块属性，该字段是一组指出块属性的标志，多个标志值求或即为 Characteristics 的值；</p><p>Characteristics 的值由下列值组合而成：</p><table><thead><tr><th align="center">定义</th><th align="center">值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">IMAGE_SCN_CNT_CODE</td><td align="center">00000020</td><td align="center">包含代码，常与 10000000 一起设置</td></tr><tr><td align="center">IMAGE_SCN_CNT_INITIALIZED_DATA</td><td align="center">00000040</td><td align="center">该块包含已初始化的数据</td></tr><tr><td align="center">IMAGE_SCN_CNT_UNINITIALIZED_DATA</td><td align="center">00000080</td><td align="center">该块包含未初始化的数据</td></tr><tr><td align="center">IMAGE_SCN_MEM_DISCARDABLE</td><td align="center">02000000</td><td align="center">该块可被丢弃，因为它一旦被载入，进程就不再需要它了<br>常见的可丢弃块是 .reloc（重定位块）</td></tr><tr><td align="center">IMAGE_SCN_MEM_SHARED</td><td align="center">10000000</td><td align="center">该块为共享块</td></tr><tr><td align="center">IMAGE_SCN_MEM_EXECUTE</td><td align="center">20000000</td><td align="center">该块可执行，通常当 00000020 标志被设置时，该标志也被设置</td></tr><tr><td align="center">IMAGE_SCN_MEM_READ</td><td align="center">40000000</td><td align="center">该块可读，可执行文件中的块总是设置该标志</td></tr><tr><td align="center">IMAGE_SCN_MEM_WRITE</td><td align="center">80000000</td><td align="center">该块可写，如果 PE 文件中没有设置该标志，装载程序就会将内存映像页标记为可读或可执行</td></tr></tbody></table></li></ol><p>VirtualAddress 与 PointerToRawData 不带有任何值，分别由定义在 IMAGE_OPTIONAL_HEADER32 中的 SectionAlignment 与 FileAlignment 确定；</p><p>VirtualSize 与 SizeOfRawData 一般具有不同的大小，即磁盘文件中节区的大小与加载到内存中的节区的大小是不同的；</p><p>如果 VirtualSize 的值大于 SizeOfRawData 的值，那么 SizeOfRawData 表示来自可执行文件初始化数据的大小，与 VirtualSize 相差的字节用 0 填充；</p><p>最后，PE 规范未明确规定节区的 Name，所以可以向其中放入任何值，甚至可以填充 NULL 值，因此，节区的 Name 字段仅供参考，不能保证其百分百的用作某种信息（节区的名称）；</p><h3 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h3><p>PE 文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的映射，这种映射一般称为 RVA to RAW；</p><p>方法如下：</p><ol><li><p>查找 RVA 所在节区；</p></li><li><p>使用简单的公式计算文件偏移（RAW）</p></li></ol><p>根据 IMAGE_SECTION_HEADER 结构体，换算公式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAW - PointerToRawData = RVA - VirtualAddress</span><br><span class="line">                   RAW = RVA - VirtualAddress + PointerToRawData</span><br></pre></td></tr></table></figure><h3 id="IAT（Import-Address-Table，导入地址表）"><a href="#IAT（Import-Address-Table，导入地址表）" class="headerlink" title="IAT（Import Address Table，导入地址表）"></a>IAT（Import Address Table，导入地址表）</h3><p>在 PE 文件内有一组数据结构，它们分别对应于被输入的 DLL，每一个这样的结构体都给出了被输入的 DLL 的名称并指向一组函数指针，这组函数指针称为输入地址表（IAT）；</p><p>每一个被引入的 API 在 IAT 里都有保留的位置，在那里它将被 Windows 加载器写入输入函数的地址，也就是调用位置；</p><p>一旦模块被载入，IAT 中将包含所要输入函数的地址；</p><p>把所有输入函数放在 IAT 中，这样，无论代码中多用一个输入函数多少次，都会通过 IAT 中的同一个函数指针来完成；</p><h4 id="DLL（Dynamic-Link-Library，动态链接库）"><a href="#DLL（Dynamic-Link-Library，动态链接库）" class="headerlink" title="DLL（Dynamic Link Library，动态链接库）"></a>DLL（Dynamic Link Library，动态链接库）</h4><p>16 位的 DOS 时代不存在 DLL 这一概念，只有“库”一说，比如在 C 语言中使用 printf() 函数时，编译器会从 C 语言库中读取相应函数的二进制代码，然后插入应用程序的源代码中，也就是说，可执行文件中包含着 printf() 函数的二进制代码；</p><p>Windows OS 支持多任务，如果同时运行多个程序，而每个程序包含相同的库，将造成严重的内存浪费和磁盘浪费，因此，Windows 引入了 DLL 这一概念，描述如下：</p><ol><li>不要把库包含到程序中，单独组成 DLL 文件，需要时调用即可；</li><li>内存映射技术使加载后的 DLL 代码、资源在多个进程中实现共享；</li><li>更新库时，只要替换相关的 DLL 文件即可，简单易行；</li></ol><p>加载 DLL 的方式有两种：</p><ol><li>“显式链接”（Explicit Linking），程序使用 DLL 时加载，使用完毕后释放内存，必须确定目标 DLL 已经被加载，然后才寻找 API 的地址，这几乎总是通过调用 LoadLibrary 和 GetProcAddress 完成的；</li><li>“隐式链接”（Implicit Linking），程序开始时即同时加载 DLL，程序终止时再释放占用的内存，Windows 加载器保证 PE 文件所需的任何附加的 DLL 都被载入，调用 LoadLibrary 和 GetProcAddress 的过程由 Windows 加载器完成；</li></ol><p>IAT 提供的机制与隐式链接有关；</p><p>大多程序在调用 API 时，都并非直接调用，而是通过获取指定地址处的值来实现调用，为什么不直接调用呢？</p><p>这是由于，程序的制作者编译程序时，无法确定程序的运行环境（XP、Vista、7、10）、语言（ENG、CHS、JPN、KOR）、服务包（Service Pack），不同环境中，使用的 DLL 版本各不相同，指定的 API 的实际位置也会不同；</p><p>为了确保能在所有环境中都能正常调用 API，编译器准备并记录要保存 API 的实际地址，执行文件时，PE 装载器会将 API 的地址写入到这个实际地址；</p><p>编译器不使用直接指令调用 API 的另一个原因在于 DLL 重定向。</p><p>DLL 文件的 ImageBase 值一般为 10000000，比如程序使用了 a.dll 和 b.dll，PE 装载器先将 a.dll 装载到内存的 10000000 处，然后尝试将 b.dll 也装载到该处，但由于该地址已经装载了 a.dll，所以，PE 装载器会查找其它空白的内存空间，然后将 b.dll 装载进去，这就是 DLL 重定向，这就使得无法对实际地址进行硬编码；</p><p>还有一个原因在于：PE 头中表示地址时使用 RVA，而不是 VA；</p><p>实际操作中，无法保证 DLL 一定会被加载到 PE 头指定的 ImageBase 处，但是 EXE 文件（生成进程的主体）却能准确的加载到自身的 ImageBase 中，这是因为它拥有自己的虚拟空间；</p><h4 id="输入函数的调用"><a href="#输入函数的调用" class="headerlink" title="输入函数的调用"></a>输入函数的调用</h4><p>输入函数就是被程序调用但其执行代码不在程序中的函数，这些函数的代码位于相关的 DLL 中，在调用程序中只保留相关的函数信息，如函数名、DLL 文件名等；</p><p>对磁盘上的 PE 文件来说，它无法得知这些输入函数在内存中的地址；</p><p>只有当 PE 文件载入内存后，Windows 加载器才会将相关 DLL 载入，并将调用输入函数的指令和函数实际所处的地址联系起来；</p><p>当应用程序调用一个 DLL 的代码和数据时，它正在被隐式链接到 DLL，这个过程完全由 Windows 加载器完成；</p><h4 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR"></a>IMAGE_IMPORT_DESCRIPTOR</h4><p>IMAGE_IMPORT_DESCRIPTOR 结构体中记录着 PE 文件要倒入哪些库文件；</p><p>可执行文件使用来自其它 DLL 的代码或数据的动作称为输入（import）；</p><p>当 PE 文件被载入时，Windows 加载器的工作之一就是定位所有被输入的函数和数据，并让正在载入的文件可以使用这些地址，这个过程是通过 PE 文件的输入表（Import Table，简称“IT”，也称导入表）完成的；</p><p>输入表中保存的是函数名和其驻留的 DLL 名等动态链接库所需的信息；</p><p>在 PE 文件头的可选映像头中，数据目录表的第 2 个成员指向输入表，即 IMAGE_NT_HEADERS.IMAGE_OPTIONAL_HEADER.DataDirectory[1]，也就是 IMAGE_DIRECTORY_ENTRY_IMPORT；</p><p>输入表（数组）以 IMAGE_IMPORT_DESCRIPTOR（IID） 结构体开始，每个被 PE 文件隐式链接的 DLL 都有一个 IID，这个数组中，没有字段指出该结构体数组的项数，但它的最后一个单元是 NULL，由此可以计算出该数组的项数；</p><p>执行一个普通程序时，往往需要导入多个库，导入多少个库就存在多少个 IMAGE_IMPORT_DESCRIPTOR 结构体，这些结构体形成了数组，且结构体数组最后以 NULL 结构体结尾；</p><p>IMAGE_IMPORT_DESCRIPTOR 结构体的成员：</p><table><thead><tr><th align="center">项目</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">OriginalFirstThunk（Characteristics）⚠️</td><td align="center">INT 的地址（RVA）</td></tr><tr><td align="center">TimeDateStamp</td><td align="center">一个 32 位的时间标志，可忽略</td></tr><tr><td align="center">ForwarderChain</td><td align="center">第 1 个被转向的 API 的索引，一般为 0</td></tr><tr><td align="center">Name ⚠️</td><td align="center">库名称字符串的地址（RVA）</td></tr><tr><td align="center">FirstThunk ⚠️</td><td align="center">IAT 的地址（RVA）</td></tr></tbody></table><blockquote><p>INT：输入名称表（Import Name Table）；</p><p>IAT：输入地址表（Import Address Table）；</p></blockquote><ol><li>OriginalFirstThunk（INT）：包含指向输入名称表（INT）的 RVA；<br>INT 是一个包含导入函数信息（Ordinal，Name）的结构体指针数组，只有获得了这些信息，才能在加载到进程内存的库中准确求得相应函数的起始地址；<br>INT 是一个 IMAGE_THUNK_DATA 结构的数组，数组中的每个 IMAGE_THUNK_DATA 结构都指向 IMAGE_IMPORT_BY_NAME 结构，数组尾部以 NULL 结束，即数组以一个内容为 0 的 IMAGE_THUNK_DATA 结构体结束；</li><li>TimeDateStamp：一个 32 位的时间标志，可忽略；</li><li>ForwarderChain：这是第 1 个被转向的 API 的索引，一般为 0，在程序中引用一个 DLL 中的 API，而这个 API 又在引用其它 DLL 的 API 时使用；</li><li>Name：DLL 名字的指针，是一个以 “00” 结尾的 ASCII 字符的 RVA 地址，该字符包含输入 DLL 的名称；<br>Name 是一个字符串指针，它指向导入函数所属的库文件的名称；</li><li>FirstThunk（IAT）：包含指向输入地址表（IAT）的 RVA；</li></ol><p>OriginalFirstThunk 与 FirstThunk 相似，它们分别指向两个本质上相同的数组 IMAGE_THUNK_DATA 结构；</p><p>两个数组中都有 IMAGE_THUNK_DATA 结构类型的元素，它是一个指针大小的联合（union）；</p><p>每个 IMAGE_THUNK_DATA 元素对应与一个从可执行文件输入的函数；</p><p>两个数组的结束都是由一个值为 0 的 IMAGE_THUNK_DATA 元素表示；</p><p>IMAGE_THUNK_DATA 结构实际上是一个双字，该结构在不同时刻有不同的含义，定义如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_THUNK_DATA STRUCT</span><br><span class="line">    union ul</span><br><span class="line">        ForwarderString     DWORD   ?       ; 指向一个转向者字符串的 RVA</span><br><span class="line">        Function            DWORD   ?       ; 被输入的函数的内存地址</span><br><span class="line">        Ordinal             DWORD   ?       ; 被输入的 API 的序数值</span><br><span class="line">        AddressOfData       DWORD   ?       ; 指向 IMAGE_IMPORT_BY_NAME</span><br><span class="line">    ends</span><br><span class="line">IMAGE_THUNK_DATA ENDS</span><br></pre></td></tr></table></figure><p>当 IMAGE_THUNK_DATA 值的最高位（双字的最高位）为 1 时，表示函数以序号方式输入，这时低 31 位（或这 64 位可执行文件的低 63 位）被看成一个函数序号；</p><p>当 IMAGE_THUNK_DATA 值的最高位（双字的最高位）为 0 时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个 RVA，指向一个 IMAGE_IMPORT_BY_NAME 结构；</p><p>IMAGE_IMPORT_BY_NAME 结构仅有 1 个字大小，存储了一个输入函数的相关信息，定义如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_IMPORT_BY_NAME STRUCT</span><br><span class="line">    Hint     WORD   ?</span><br><span class="line">    Name     BYTE   ?</span><br><span class="line">IMAGE_IMPORT_BY_NAME ENDS</span><br></pre></td></tr></table></figure><ol><li>Hint：本函数在其所驻留 DLL 的输入表中的序号，该域被 PE 装载器用来在 DLL 的输出表里快速查询函数；<br>该值不是必需的，一些链接器将它设为 0；</li><li>Name：含有输入函数的函数名，函数名是一个 ASCII 字符串，以 NULL 结尾；<br>这里虽然将 Name 的大小以字节为单位进行定义，但其实它是一个可变尺寸域，由于没有更好的表示方式，只好在定义中写成 BYTE；</li></ol><p>PE 装载器把导入函数输入至 IAT 的顺序：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 读取 IID 的 Name 成员，获取库名称字符串；</span><br><span class="line">2. 装载相应库：LoadLibrary(&quot;库名称.dll&quot;)</span><br><span class="line">3. 读取 IID 的 OriginalFirstThunk 成员，获取 INT 地址；</span><br><span class="line">4. 逐一读取 INT 数组中的值，获取相应的 IMAGE_IMPORT_BY_NAME（RVA）；</span><br><span class="line">5. 使用 IMAGE_IMPORT_BY_NAME 的 Hint 项或 Name 项，获取相应函数的起始位置；</span><br><span class="line">6. 读取 IID 的 FirstThunk 成员，获得 IAT 地址；</span><br><span class="line">7. 将上面获得的函数地址输入相应 IAT 数组中；</span><br><span class="line">8. 重复以上步骤 4～7，直到 INT 表结束（遇到 NULL）；</span><br></pre></td></tr></table></figure><h4 id="以-NOTEPAD-EXE-为例，梳理思路，强化学习"><a href="#以-NOTEPAD-EXE-为例，梳理思路，强化学习" class="headerlink" title="以 NOTEPAD.EXE 为例，梳理思路，强化学习"></a>以 NOTEPAD.EXE 为例，梳理思路，强化学习</h4><ol><li><p>在 PE 文件头的可选映像头中，数据目录表的第 2 个成员指向输入表；</p></li><li><p>数据目录表是 IMAGE_DIRECTORY_ENTRY_IMPORT，位于 IMAGE_OPTIONAL_HEADER32.DataDirectory[1]；</p></li><li><p>而 IMAGE_OPTIONAL_HEADER32 位于 IMAGE_NT_HEADERS，也就是 PE 头；</p></li><li><p>使用 WinHEX 打开 NOTEPAD.EXE，找到 PE 头的偏移位置（位于从文件开始偏移 3C 字节处）；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsqzcsjsnj316r0u041k.jpg" alt="PE头的偏移位置"></p></li><li><p>找到 PE 头后，IMAGE_OPTIONAL_HEADER32 是其的第 3 个成员，所以，直接定位到第 3 个成员，然后找到 DataDirectory：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsrf4o9j1j316q0u0dih.jpg" alt="IMAGE_DIRECTORY_ENTRY_IMPORT"></p><p>绿色是 IMAGE_NT_SIGNATURE；</p><p>黄色是 IMAGE_FILE_HEADER；</p><p>蓝色是 IMAGE_OPTIONAL_HEADER32 的其它成员，从 158 位置开始，是 DataDirectory 数组成员，也就是数据目录表成员，最后的红色则表示 DataDirectory[1]；</p><p>数据目录表的每个成员占 8 个字节，分别指向相关的结构体，前 4 个字节表示地址，后 4 个字节表示大小；</p><p>所以在这里，IMAGE_DIRECTORY_ENTRY_IMPORT 的相对虚拟地址是<code>7604</code>;</p></li><li><p>由于得到的地址是 RVA，所以还需要转换为 RAW，先来看看 RAW 的计算公式：RAW = RVA - VirtualAddress + PointerToRawData，这其中的 RVA 是已知的，也就是 <code>7604</code>，而 VirtualAddress 和 PointerToRawData 如何得知呢？</p><p>VirtualAddress 和 PointerToRawData 位于 IMAGE_SECTION_HEADER 结构体；</p><p>IMAGE_SECTION_HEADER 结构体在 PE 头的下方，所以 DataDirectory 数组之后就是 IMAGE_SECTION_HEADER 结构体，也就是 节区表（区块表）；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsypkauskj316x0u0wgw.jpg" alt="节区表（区块表）"></p><p>图中选中部分是 DataDirectory 数组；</p><p>红色是第 1 个节区的部分参数，第 3 个参数说明，此节区（.text）在内存中的起始位置（VirtualAddress）是 00001000，第 5 个参数说明，此节区在磁盘文件中的偏移（PointerToRawData）是 00000400；</p><p>绿色是第 2 个节区的部分参数，第 3 个参数说明，此节区（.data）在内存中的起始位置（VirtualAddress）是 00009000，这里为什么要看第 2 节区的 VirtualAddress 呢？因为确定了第 2 节区的起始位置，也就确定了第 1 节区的结束位置，也就是范围，很显然，1000 &lt; 7604 &lt; 9000，位于第 1 节区（.text）；</p><p>根据公式计算，第 1 节区的 RAW = 7604 - 1000 + 400，结果是<code>6A04</code>；</p></li><li><p>既然已知第 1 节区的 RAW，按下<code>ALT + G</code>或者菜单栏选择<code>位置 &gt;&gt; 转到偏移位置</code>：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsz701irwj316u0u0tbj.jpg" alt="第 1 节区的 RAW"></p><p>图中所示就是第 1 节区 IID，共有 5 个成员，分别来看一下：</p><ul><li><p>第 1 个成员是 OriginalFirstThunk：INT 的地址（RVA）；根据计算，其 RAW 是<code>6D90</code>；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnszcrj5gij316x0u00vr.jpg" alt="OriginalFirstThunk"></p><p>跳转到<code>6D90</code>可以看到输入名称表数组，最后一个单元为 NULL，跟随第 1 个成员，查看其名称，RVA：7A7A -&gt; RAW：6E7A</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsznj6kkfj316m0u041z.jpg" alt="跟随第 1 个成员"></p><p>初始的 2 个字节为 Ordinal，是库中函数的固有编号，Ordinal 后面是导入函数的名称字符串<code>PageSetupDlgW</code>（末尾以 Terminating NULL[‘\0’]结尾）；</p></li><li><p>第 2 个成员是 TimeDateStamp，由于这里的值为 0，故忽略；</p></li><li><p>第 3 个成员是 ForwarderChain，其值也为 0，忽略；</p></li><li><p>第 4 个成员是 Name：DLL 名字的指针；RVA：7AAC -&gt; RAW：6EAC；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnt02pzailj316s0u0n09.jpg" alt="DLL 名字的指针"></p><p>可以看到，包含<code>PageSetupDlgW</code>的库文件是<code>comdlg32.dll</code>；</p></li><li><p>第 5 个成员是 FirstThunk（IAT）：包含指向输入地址表（IAT）的 RVA；RVA：12C4 -&gt; RAW：6C4；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnt0aevkwrj316s0u0dim.jpg" alt="FirstThunk（IAT）"></p><p>选中区域即为 IAT 数组区域，对应于 cmdlg32.dll 库，与 INT 类似，由结构体指针组成，且以 NULL 结尾；</p></li></ul></li></ol><h3 id="EAT（Export-Address-Table，导出地址表）"><a href="#EAT（Export-Address-Table，导出地址表）" class="headerlink" title="EAT（Export Address Table，导出地址表）"></a>EAT（Export Address Table，导出地址表）</h3><p>在 Windows 系统中，“库”是为了方便其它程序调用而集中包含相关函数的文件（DLL / SYS）；</p><p>创建 DLL 时，实际上创建了一组能让 EXE 或其它 DLL 调用的函数；</p><p>程序运行时， PE 装载器会根据 DLL 文件中输出的信息修正被执行文件的 IAT；</p><p>当一个 DLL 函数能够被 EXE 或其它 DLL 文件使用时，它就被“输出了（Exported）”；</p><p>输出信息被保存在输出表中，DLL 文件通过输出表向系统提供输出函数名、序号和入口地址等信息；</p><p>EAT 是一种核心机制，它使不同的应用程序可以调用库文件中提供的函数，也就是说，只有通过 EAT 才能准确获得从相应库中导出函数的起始地址；</p><h4 id="IMAGE-EXPORT-DESCRIPTOR"><a href="#IMAGE-EXPORT-DESCRIPTOR" class="headerlink" title="IMAGE_EXPORT_DESCRIPTOR"></a>IMAGE_EXPORT_DESCRIPTOR</h4><p>与 IAT 一样，PE 文件内特定结构体（IMAGE_EXPORT_DESCRIPTOR）保存着导出信息，且 PE 文件中仅有一个用来说明库 EAT 的 IMAGE_EXPORT_DESCRIPTOR 结构体；</p><p>输出表的主要内容是一个表格，其中包括函数名称、输出序数等，序数是指 DLL 中某个函数的 16 位数字，在所指向的 DLL 中是独一无二的；<br>输出表是数据目录表的第 1 个成员，指向 IMAGE_EXPORT_DESCRIPTOR（简称 IED）结构；</p><p>IMAGE_EXPORT_DESCRIPTOR 结构体的重要成员：</p><table><thead><tr><th align="center">字段</th><th align="center">Size</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">Name</td><td align="center">DWORD</td><td align="center">模块（DLL）的真实名称</td></tr><tr><td align="center">NumberOfFunctions ⚠️</td><td align="center">DWORD</td><td align="center">实际 Export 函数的个数</td></tr><tr><td align="center">NumberOfNames ⚠️</td><td align="center">DWORD</td><td align="center">Export 函数中具名函数的个数（ENT）</td></tr><tr><td align="center">AddressOfFunctions ⚠️</td><td align="center">DWORD</td><td align="center">Export 函数地址数组（数组元素个数 = NumberOfFunction）</td></tr><tr><td align="center">AddressOfNames ⚠️</td><td align="center">DWORD</td><td align="center">函数名称地址数组（数组元素个数 = NumberOfNames）</td></tr><tr><td align="center">AddressOfNameOrdinals ⚠️</td><td align="center">DWORD</td><td align="center">序号地址数组（数组元素个数 = NumberOfNames）</td></tr></tbody></table><blockquote><p>ENT：输出函数名称表（Export Name Table）；</p><p>EAT：输出地址表（Export Address Table）；</p></blockquote><ol><li>Name：指向一个 ASCII 字符串的 RVA，这个字符串是与输出函数相关联的 DLL 的名字；</li><li>NumberOfFunctions： EAT 中的条目数量，0 表示没有代码或数据被输出；</li><li>NumberOfNames：输出函数名称表（Export Name Table，ENT），NumberOfNames 的值总是小于或等于 NumberOfFunctions 的值；</li><li>AddressOfFunctions：EAT 的 RVA，EAT 是一个 RVA 数组，数组中的每一个非零 RVA 都对应于一个被输出的序号；</li><li>AddressOfNames：ENT 的 RVA，ENT 是一个指向 ASCII 字符串的 RVA 数组，每一个 ASCII 字符串对应于一个通过名字输出的序号；</li><li>AddressOfNameOrdinals：输出序数表的 RVA，这个表是字（WORD）的数组，这个表将 ENT 中的数组索引映射到相应的输出地址表条目；</li></ol><p>设计输出表是为了方便 PE 装载器工作；</p><p>模块必须保存所有输出函数的地址，供 PE 装载器查询；</p><p>模块将这些信息保存在 AddressOfFunctions 域指向的数组中，而数组元素的数量存放在 NumberOfFunctions 域中；</p><p>如果有些函数是通过名字引出的，这些名字的 RVA 值会存放在 AddressOfNames 域指向的数组中，数组元素的数量存放在 NumberOfNames 域中，以供 PE 装载器查询；</p><p>AddressOfNames 域指向的数组中仅包含函数名，并不包含函数的地址；</p><p>AddressOfNameOrdinals 域指向的数组中包含（AddressOfNames 数组中）函数名对应的（在 AddressOfFunctions 数组中的）索引，所以，序数表和名称表的元素数量相同；</p><p>PE 装载器会通过 AddressOfNameOrdinals 域指向的数组获取 AddressOfNames 域指向的数组中的函数名在 AddressOfFunctions 域指向的数组中对应的索引，从而获取函数地址；</p><h4 id="以-KERNEL32-DLL-为例，梳理思路，强化学习"><a href="#以-KERNEL32-DLL-为例，梳理思路，强化学习" class="headerlink" title="以 KERNEL32.DLL 为例，梳理思路，强化学习"></a>以 KERNEL32.DLL 为例，梳理思路，强化学习</h4><ol><li><p>使用 WinHEX 打开 KERNEL32.DLL，找到 IMAGE_EXPORT_DESCRIPTOR，位于 IMAGE_OPTIONAL_HEADER32.DataDirectory[0]；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntuzfk614j316s0u0q5d.jpg" alt="IMAGE_EXPORT_DESCRIPTOR"></p><p>可以看到，IMAGE_EXPORT_DESCRIPTOR 的 RVA 为<code>262C</code>，则 RAW 为<code>1A2C</code>;</p></li><li><p>跳转到<code>1A2C</code>：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntv12k5gvj316i0u0773.jpg" alt="`1A2C`"></p><p>选中部分为 IMAGE_EXPORT_DESCRIPTOR 所有成员，红色部分依次是 Name、AddressOfFunctions、AddressOfNames 以及 AddressOfNameOrdinals；</p></li><li><p>首先，查看 Name，RVA：4B98 -&gt; RAW：3F98：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntv5oue9xj316t0u0diu.jpg" alt="3F98"></p><p>可以看到，库名称为<code>KERNEL32.dll</code>（以’\0’结尾）；</p></li><li><p>返回<code>1A2C</code>，然后查看 AddressOfFunctions，RVA：2654 -&gt; RAW：1A54：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvbhgjx1j316q0u0n00.jpg" alt="1A54"></p><p>可以看到，第 1 个输出函数的 RAV 为：A6E4；</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvei6fjpj316q0u0acp.jpg" alt="ImageBase"></p><p>KERNEL32.DLL 的 ImageBase 为：7C800000，故第 1 个输出函数的实际地址（VA）为：7C800000 + A6E4 = 7C80A6E4；</p><p>使用<code>OD</code>打开 KERNEL32.DLL：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvlbcvxfj31b40u0tbx.jpg" alt="使用`OD`打开 KERNEL32.DLL"></p><p>发现 7C80A6E4 对应的函数名为<code>ActivateActCtx</code>；</p></li><li><p>返回<code>1A2C</code>，接着查看 AddressOfNames，RVA：353C -&gt; RAW：293C：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvp6hfftj316j0u00vk.jpg" alt="293C"></p><p>指向函数名字符串的指针是：4BA5，则 RAW 为：3FA5：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvr1cbzqj316s0u041i.jpg" alt="3FA5"></p><p>对应的函数名为<code>ActivateActCtx</code>，与查看 AddressOfFunctions 时获取的函数名一致；</p></li><li><p>返回<code>1A2C</code>，最后来看 AddressOfNameOrdinals，RVA：4424 -&gt; RAW：3824：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvuyl8g5j316x0u0acs.jpg" alt="3824"></p><p>对应的索引值为 0，没问题；</p></li></ol></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Undeio</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://undeio.me/post/1876828466/" title="PE 文件格式">https://undeio.me/post/1876828466/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/PE/" rel="tag"><i class="fa fa-tag"></i> PE</a></div><div class="post-nav"><div class="post-nav-item"><a href="/post/3794155287/" rel="prev" title="VB 调试之分析 N-Code（二）"><i class="fa fa-chevron-left"></i> VB 调试之分析 N-Code（二）</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments utterances-container"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Undeio</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> 强力驱动</div><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="busuanzi"><span id="busuanzi_container_site_pv" style="display:none">本站总访问量<span id="busuanzi_value_site_pv"></span>次 </span><span>|</span> <span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></div><script>printIP();
    function printIP() {
        fetch('https://ipapi.co/ip/')
        .then(function(response) {
        response.text().then(txt => {
            const ip = txt;
            let foot = document.getElementsByClassName("footer-inner")[0];
            let node = document.createElement("div");
            node.setAttribute("class", "ip");
            node.innerHTML = "本次访问IP: " + ip;
            if (foot) {
                foot.appendChild(node);
            }
            return ip;
        });
        })
        .catch(function(error) {
        console.log(error)
        });
    }</script></div></footer><script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});</script><script src="/js/local-search.js"></script><script data-pjax>if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.4/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}</script><div class="pjax"><script>NexT.utils.loadComments('.utterances-container', () => {
  const script = document.createElement('script');
  script.src = 'https://utteranc.es/client.js';
  script.setAttribute('repo', "Undeio/undeio.github.io");
  script.setAttribute('issue-term', "title");
  script.setAttribute('theme', "github-light");
  script.crossOrigin = 'anonymous';
  script.async = true;
  document.querySelector('.utterances-container').appendChild(script);
});</script></div></body></html>