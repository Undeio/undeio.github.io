<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 添加 Utterance 评论功能</title>
    <url>/post/3357819964/</url>
    <content><![CDATA[<blockquote>
<p>每逢看到大佬们的精彩文章，感慨甚多之际，不能留言把欢甚是遗憾。<br>缺少了留言支持、请教解惑、互相探讨，总感觉博客没有灵魂。</p>
</blockquote>
<a id="more"></a>

<h4 id="废话连篇"><a href="#废话连篇" class="headerlink" title="废话连篇"></a>废话连篇</h4><p>曾记得，2016 年端午节，在<code>Github Pages</code>上写下了人生中的第一篇博客，那时就用的<code>Hexo + Next</code>主题，直至今日，一直对<code>Hexo + Next</code>甚是喜爱，感谢大佬，感谢开源 🙏 。</p>
<p>期间，经历了换工作、换电脑、换域名、换托管，诸多原因导致博客遗失，不过也是甚好，不能守着过去，要拥抱现在和未来（不应该是拥抱开源吗？）。</p>
<p>之前使用过<code>网易云跟帖</code>，大家都戏称灌水专用，现在业已关闭。</p>
<p>接着使用了<code>来必力</code>，一个来自韩国的评论插件，国内访问甚是感人，至于大佬们的反向代理，那时心有余而力不足，遂卒。</p>
<p>后来使用了<code>valine</code>，依托于<a href="https://www.leancloud.cn/">LeanCloud</a>在国内运营，对用户甚是友好，界面也是简洁清新，让人看一眼就喜爱，而且支持阅读统计等诸多功能，之后便一直使用。</p>
<p>偶然间，在<code>知乎</code>上闲逛时，发现了一位大兄关于评论插件的分析和感想，现在依稀记得的一句话就是”无论第三方插件的使用有多友好，数据都存在第三方，哪天他们歇业停工了，数据一样丢失。“，之后就对此耿耿于怀（当然不是对说这句的仁兄耿耿于怀）。</p>
<p>重建博客之际，对评论插件抱着谨慎的态度选之又选，决定将数据存在<code>Github</code>上，至于歇业停工，既然博客数据都不存在了，还留着评论数据作甚，就让他们同生共死吧。</p>
<p><code>Gitalk</code>和<code>Gitment</code>最先映入眼帘，之后在<code>Github</code>上发现<code>Gitment</code>好久没有更新了，只剩下一个选择。</p>
<p><code>Hexo</code>官方集成了<code>Gitalk</code>，轻车熟路的做好设置，<code>hexo clean | g | s</code>三部曲之后，熟悉的框框出现，然鹅，发现每篇文章都要手动初始化，翻阅<a href="https://github.com/gitalk/gitalk/wiki/%E8%AF%84%E8%AE%BA%E5%88%9D%E5%A7%8B%E5%8C%96">官方 Wiki</a>发现了自动初始化的脚本，底部有<a href="https://draveness.me/git-comments-initialize/">原作者</a> 的链接，遂前往，准备学习膜拜一番，看了大佬的思路解析，大呼过瘾之际也感落寞，原因无他，就是自己不会<code>Ruby</code>。在准备留言评论之际，发现又有<a href="https://www.lshell.com/post/use-github-action-and-python-to-automatically-initialize-gitalk-comments/">大佬</a>给出了使用<code>Python</code>初始化的思路，用轮子不是目的，读懂造轮子的思路学习造轮子，岂不快哉。</p>
<p>进入文章，阅读之际，大佬感慨且推荐了一个新的评论插件<code>utteranc</code>，揣着疑惑的心去<a href="https://utteranc.es/">官网</a>，去<a href="https://github.com/utterance/utterances">官方仓库</a>查看了一番，发现没有 Wiki，也没有文档，善用搜索引擎的我，搜索一番之后发现，似乎<code>Next</code>之前的某个版本集成过，但翻阅了现在的版本又毫无所获，教程都是根据集成时的方法写的，对我无用。</p>
<p>在这里，不得不提的是<code>Hexo</code>的一项前瞻性功能<code>代替配置文件</code>和<code>代替主题配置文件</code>，再也不用像之前一样，想要实现某个功能就去修改官方文件，它不破坏官方文件的完整性，可以无痛更新，之前最头疼的一件事儿就是<code>拉取官方更新之后合并冲突</code>。</p>
<p>这次重建博客，所有非官方功能，如 404、音乐、footer，都使用<code>注入</code>实现，我对这项功能的称呼，暂且这么叫吧。</p>
<p>以上都是废话，下面进入正题：</p>
<h4 id="首先，需要一个用来存储评论的仓库"><a href="#首先，需要一个用来存储评论的仓库" class="headerlink" title="首先，需要一个用来存储评论的仓库"></a>首先，需要一个用来存储评论的仓库</h4><ul>
<li>你可以新建一个仓库；</li>
<li>当然，也可以像我一样，存放在博客仓库的 Issues 中，毕竟我已经承诺了它们同生共死，说到就要做到；</li>
<li>Issues 无法删除，请谨慎选择，防止过多的无用 Issues 带来烦恼（设置 utterances 的时候，这句话依然有效）；</li>
</ul>
<h4 id="安装-utterances"><a href="#安装-utterances" class="headerlink" title="安装 utterances"></a>安装 utterances</h4><ul>
<li>点击<a href="https://github.com/apps/utterances">这里</a>打开安装页面，然后点击右上角的<code>安装</code>；</li>
<li>按下安装按钮，（不不不，不够严谨，按下是 201，抬起才是 202），你会跳转到<img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giukvthjlpj30fy0oqtbi.jpg" alt="第二步">如图所示的页面，选择第一步中创建的仓库或已有的仓库，然后点击<code>安装</code>，请记住仓库名，因为接下来要用；</li>
<li>接下来，会跳转到设置页面；</li>
</ul>
<h4 id="设置-utterances"><a href="#设置-utterances" class="headerlink" title="设置 utterances"></a>设置 utterances</h4><ul>
<li>在这里，请务必填写你在上一步中选择的仓库，并在前面加上仓库的所有者<img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giul8ahfszj30k60bfwfv.jpg" alt="第三步"></li>
<li>当然，如果你比较调皮，没有填写上一步中选择的仓库，还是有补救办法的，点击<a href="https://github.com/apps/utterances">这里</a>，其实就是安装页面，你会跳转到安装页面，你发现右上角的<code>安装</code>不见了，取而代之的是<code>配置</code>，就是它了，去配置页面修改吧；</li>
<li>至于这里，是配置 utterances 创建新的 Issues 时，给 Issues 起的名儿<img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giullxjlwfj30jo0i2q65.jpg" alt="配置">请自由发挥，因为使用了<a href="https://github.com/rozbo/hexo-abbrlink">abbrlink</a>，链接并不显示文章名称，所以我就选图中所示的选项了，自由发挥的同学，玩的开心；</li>
<li>这里是选填选项，给 utterances 创建的 Issues 设置标签<img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giulsj64dxj30jt072dgf.jpg" alt="设置标签"></li>
<li><code>Theme</code>就不用说了吧，主题选自己喜欢的，没喜欢的？给官方提交一个新主题；</li>
<li>接下来就是重头戏了，上面所有的选项都是为它服务的<img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giulyonf3xj30jz09lq41.jpg" alt="script">复制 script 并添加到你想要评论出现的地方，bingo！</li>
</ul>
<h4 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h4><p>因为要用<code>注入</code>来实现评论功能，那就不能修改官方的模板，自己撸了个 js 来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* utterances 评论插件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  query2add();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pjax 使用 pushState() 不会触发 hashchange 事件，需要拦截</span></span><br><span class="line"><span class="keyword">var</span> _wr = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> orig = history[type];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="keyword">new</span> Event(type);</span><br><span class="line">    e.arguments = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">window</span>.dispatchEvent(e);</span><br><span class="line">    <span class="comment">// 注意事件监听在url变更方法调用之前 也就是在事件监听的回调函数中获取的页面链接为跳转前的链接</span></span><br><span class="line">    <span class="keyword">var</span> rv = orig.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState = _wr(<span class="string">&quot;pushState&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 change 事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;pushState&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e &amp;&amp; e.arguments.length &gt; 2 &amp;&amp; e.arguments[2]</span></span><br><span class="line">  query2add();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 utterance 插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadUtterance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> js = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  <span class="comment">/* 以下内容改成第三步生成的配置 */</span></span><br><span class="line">  js.setAttribute(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;https://utteranc.es/client.js&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;repo&quot;</span>, <span class="string">&quot;Undeio/undeio.github.io&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;issue-term&quot;</span>, <span class="string">&quot;title&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;theme&quot;</span>, <span class="string">&quot;github-light&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;crossorigin&quot;</span>, <span class="string">&quot;anonymous&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;async&quot;</span>, <span class="string">&quot;async&quot;</span>);</span><br><span class="line">  <span class="comment">/* 以上内容需要修改 */</span></span><br><span class="line">  <span class="comment">// 添加到主体部分的末尾</span></span><br><span class="line">  <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;main-inner&quot;</span>)[<span class="number">0</span>].appendChild(js);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已存在组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query2add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有正文页面才有 post-copyright，也就是最后的版权声明</span></span><br><span class="line">  <span class="comment">// 当然，你也可以找一个自己正文才有的标识进行判断</span></span><br><span class="line">  <span class="keyword">let</span> postCopyRight = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;post-copyright&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (postCopyRight &amp;&amp; postCopyRight[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="comment">// 存在评论就放弃添加</span></span><br><span class="line">    <span class="keyword">let</span> utterances = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;utterances&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (utterances &amp;&amp; utterances[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loadUtterance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无图无真相<img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giumvnbuw0j30gu0hm0vd.jpg" alt="真相"><br>最终效果<img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giun047pynj30w10admy8.jpg" alt="效果"><br>才疏学浅，实现比较粗糙，如果你有更好的实现，请给我留言。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Utterance</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器小记</title>
    <url>/post/592731679/</url>
    <content><![CDATA[<h3 id="通用寄存器拆分"><a href="#通用寄存器拆分" class="headerlink" title="通用寄存器拆分"></a>通用寄存器拆分</h3><p>EAX / EBX / ECX / EDX</p>
<p>例如：</p>
<ul>
<li>EAX = 12345678</li>
<li>&nbsp;&nbsp;&nbsp;AX = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5678</li>
<li>&nbsp;&nbsp;&nbsp;AH = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;56</li>
<li>&nbsp;&nbsp;&nbsp;AL = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;78<a id="more"></a></li>
<li>ESP 永远指向堆栈的最顶端；</li>
<li>堆栈顶端为 ESP，依次向下为 ESP + 4、ESP + 8 ，以此类推；</li>
<li>EIP 永远指向 CPU 即将执行的地址；</li>
<li>寄存器从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 存放的是起始位置的地址；</li>
</ul>
<h3 id="标志位寄存器"><a href="#标志位寄存器" class="headerlink" title="标志位寄存器"></a>标志位寄存器</h3><ul>
<li><p>OF 是<code>溢出标志位</code>;</p>
<ul>
<li>当指令改变了符号位且返回错误值的时候，OF 为 1，表示溢出成立；</li>
<li>运算结果超出机器能够表示的范围称为溢出；</li>
</ul>
</li>
<li><p>PF 是 <code>奇偶标志位</code>；</p>
<ul>
<li>当指令的<code>返回值的二进制</code>表现形式中<code>1</code>的个数为偶数个时，PF 为 1；</li>
<li>运算结果的最低 16 位中含 1 的个数为偶数；</li>
<li>如：11，101，110，1001，1010，1100，1111</li>
</ul>
</li>
<li><p>ZF 是<code>0 标志符</code>.</p>
<ul>
<li>当前指令的运算结果为 0，则 ZF 为 1；</li>
</ul>
</li>
<li><p>SF 是<code>符号位标志符</code>;</p>
<ul>
<li>当指令的运算结果为负数时，SF 为 1；</li>
<li>SF 与运算结果的最高位相同；</li>
</ul>
</li>
<li><p>CF 是<code>进位标志符</code>；</p>
<ul>
<li>当指令的无符号运算结果超过最大值时，CF 为 1；</li>
<li>最高位产生进位或借位；</li>
</ul>
</li>
<li><p>AF 是<code>辅助进位标志符</code>；</p>
<ul>
<li>当指令的运算结果的低 4 位向高 4 位有进位或借位时，AF 为 1；</li>
</ul>
</li>
<li><p>TF 是<code>跟踪标志符</code>；</p>
<ul>
<li>用于调试单步操作；</li>
<li>若 TF 为 1，则每条指令执行结束后，产生中断；</li>
</ul>
</li>
<li><p>DF 是<code>方向标志符</code>；</p>
<ul>
<li>用来控制串处理指令的处理方向；</li>
<li>若 DF 为 1，则串处理中地址自动递减，否则自动自增；</li>
<li>若 DF 为 1，每次操作后使 SI 和 DI 递减，DF 为 0 时则自增；</li>
</ul>
</li>
<li><p>IF 是<code>中断标志符</code>；</p>
<ul>
<li>用来控制 CPU 是否响应可屏蔽中断；</li>
<li>若 IF 为 1 则允许中断，否则禁止中断；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的汇编指令</title>
    <url>/post/1025109479/</url>
    <content><![CDATA[<h3 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h3><h4 id="NOP"><a href="#NOP" class="headerlink" title="NOP"></a>NOP</h4><ul>
<li>NOP 的机器码是<code>90</code>；</li>
<li>NOP 是空指令，就是没有操作，无操作；</li>
<li>使用 <code>NOP</code> 来填充指令执行后多出来的字节，而不是用<code>00</code>来填充；</li>
</ul>
<a id="more"></a>

<h4 id="PUSH-压入堆栈"><a href="#PUSH-压入堆栈" class="headerlink" title="PUSH 压入堆栈"></a>PUSH 压入堆栈</h4><p>PUSH 的用法：</p>
<ul>
<li><code>PUSH 0x1 / 0xF</code>：把十六进制数字压入堆栈顶部；</li>
<li><code>PUSH EAX / EBX</code>：把指定寄存器中的数据压入堆栈顶部；</li>
<li><code>PUSH [00401000]</code>：把指定内存地址中的数据压入堆栈顶部；</li>
</ul>
<h4 id="POP-弹出堆栈"><a href="#POP-弹出堆栈" class="headerlink" title="POP 弹出堆栈"></a>POP 弹出堆栈</h4><p>POP 的用法：</p>
<ul>
<li><code>POP EAX / EBX</code>：将堆栈顶部的内容弹出并放入指定的寄存器；</li>
</ul>
<h4 id="PUSHAD"><a href="#PUSHAD" class="headerlink" title="PUSHAD"></a>PUSHAD</h4><ul>
<li>通用寄存器指：EAX / ECX / EDX / EBX / ESP / EBP / ESI / EDI；</li>
<li>PUSHAD 保护现场 / 备份现场，将通用寄存器的数据自上而下依次压入堆栈，最后一个寄存器的数据处于堆栈顶部；</li>
<li>PUSHAD 是 32 位操作；</li>
<li><code>PUSHAD</code> 相当于是<code>PUSH EAX, PUSH ECX, PUSH EDX, PUSH EBX, PUSH ESP, PUSH EBP, PUSH ESI, PUSH EDI</code>八条命令的合集；</li>
</ul>
<h4 id="POPAD"><a href="#POPAD" class="headerlink" title="POPAD"></a>POPAD</h4><ul>
<li>通用寄存器指：EAX / ECX / EDX / EBX / ESP / EBP / ESI / EDI；</li>
<li>POPAD 还原现场，将堆栈顶部的数据依次弹出并自下而上依次填充到通用寄存器；</li>
<li>POPAD 是 32 位操作；</li>
<li><code>POPAD</code> 相当于是<code>POP EDI, POP ESI, POP EBP, POP ESP, POP EBX, POP EDX, POP ECX, POP EAX</code>八条命令的合集；</li>
</ul>
<h4 id="PUSHA"><a href="#PUSHA" class="headerlink" title="PUSHA"></a>PUSHA</h4><ul>
<li>PUSHA 和 PUSHAD 功能相同，用于备份现场；</li>
<li>PUSHA 是 16 位操作；</li>
<li><code>PUSHA</code> 相当于是<code>PUSH AX, PUSH CX, PUSH DX, PUSH BX, PUSH SP, PUSH BP, PUSH SI, PUSH DI</code>八条命令的合集；</li>
</ul>
<h4 id="POPA"><a href="#POPA" class="headerlink" title="POPA"></a>POPA</h4><ul>
<li>POPA 和 POPAD 功能相同，用于还原现场；</li>
<li>POPA 是 16 位操作；</li>
<li><code>POPA</code> 相当于是<code>POP DI, POP SI, POP BP, POP SP, POP BX, POP DX, POP CX, POP AX</code>八条命令的合集；</li>
</ul>
<h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h4><ul>
<li>MOV 本意为<code>move，移动</code>，但功能相当于复制/赋值；</li>
<li><code>MOV EAX, ECX</code>：两个操作数的长度必须相同；</li>
<li><code>MOV EAX, ECX</code>：复制<code>ECX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，4 字节操作；</li>
<li><code>MOV AX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>AX（第一个参数）</code>，2 字节操作；</li>
<li><code>MOV AL, CL</code>：复制<code>CL（第二个参数）</code>的数据到<code>AL（第一个参数）</code>，1 字节操作；</li>
<li><code>MOV [00402000], EAX</code>：复制<code>EAX（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，4 字节操作；</li>
<li><code>MOV [00402000], AX</code>：复制<code>AX（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，2 字节操作；</li>
<li><code>MOV [00402000], AH</code>：复制<code>AH（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，1 字节操作；</li>
</ul>
<h4 id="MOVSX"><a href="#MOVSX" class="headerlink" title="MOVSX"></a>MOVSX</h4><ul>
<li><code>MOVSX EAX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，如果<code>EAX（第一个参数）</code>的长度比<code>CX（第二个参数）</code>长，剩余的长度用<code>CX（第二个参数）</code>的符号位填充；</li>
<li>正数用 0 填充，负数用 F 填充；</li>
</ul>
<h4 id="MOVZX"><a href="#MOVZX" class="headerlink" title="MOVZX"></a>MOVZX</h4><ul>
<li><code>MOVZX EAX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，如果<code>EAX（第一个参数）</code>的长度比<code>CX（第二个参数）</code>长，剩余的长度用 0 填充；</li>
<li>带 0 扩展传送命令；</li>
</ul>
<h4 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h4><ul>
<li>LEA：复制<code>第二个参数的内存地址</code> 或 <code>第二个参数运算后的内存地址</code>到<code>第一个参数</code>；</li>
<li><code>LEA EAX, [00401000]</code>：第一个参数必须是通用寄存器，第二个参数必须是内存地址；</li>
<li><code>LEA EAX, [ECX + 16]</code>：第一个参数必须是通用寄存器，第二个参数必须是内存地址；</li>
</ul>
<h4 id="XCHG-互换-交换"><a href="#XCHG-互换-交换" class="headerlink" title="XCHG 互换 / 交换"></a>XCHG 互换 / 交换</h4><ul>
<li><code>XCHG EAX, ECX</code>：第一个参数可以是通用寄存器或内存地址，第二个参数必须是通用寄存器；</li>
<li><code>XCHG [00401000], ECX</code>：第一个参数可以是通用寄存器或内存地址，第二个参数必须是通用寄存器；</li>
</ul>
<h4 id="SHR-二进制右移"><a href="#SHR-二进制右移" class="headerlink" title="SHR 二进制右移"></a>SHR 二进制右移</h4><h4 id="SHL-二进制左移"><a href="#SHL-二进制左移" class="headerlink" title="SHL 二进制左移"></a>SHL 二进制左移</h4><h4 id="CLD"><a href="#CLD" class="headerlink" title="CLD"></a>CLD</h4><ul>
<li>用来操作方向标志位 DF，CLD 使 DF 复位，即让 DF = 00；</li>
</ul>
<h4 id="STD"><a href="#STD" class="headerlink" title="STD"></a>STD</h4><ul>
<li>用来操作方向标志位 DF，STD 使 DF 置位，即让 DF = 01；</li>
</ul>
<h3 id="数学指令"><a href="#数学指令" class="headerlink" title="数学指令"></a>数学指令</h3><h4 id="ADD-SUB-加法-减法"><a href="#ADD-SUB-加法-减法" class="headerlink" title="ADD / SUB | 加法 / 减法"></a>ADD / SUB | 加法 / 减法</h4><ul>
<li><code>ADD / SUB</code>的返回结果放在第一个参数中；</li>
</ul>
<h4 id="ADC-带进位的加法"><a href="#ADC-带进位的加法" class="headerlink" title="ADC 带进位的加法"></a>ADC 带进位的加法</h4><ul>
<li><code>ADC EAX, ECX</code> = <code>EAX + ECX + 0 | 1</code>：两个参数累加并且加上<code>进位标识符CF</code>的值为最终结果；</li>
</ul>
<h4 id="SBB-带进位的减法"><a href="#SBB-带进位的减法" class="headerlink" title="SBB 带进位的减法"></a>SBB 带进位的减法</h4><ul>
<li><code>SBB EAX, ECX</code> = <code>EAX - ECX - 0 | 1</code>：两个参数相减并且减去<code>进位标识符CF</code>的值为最终结果；</li>
</ul>
<h4 id="INC-DEC-自增-自减"><a href="#INC-DEC-自增-自减" class="headerlink" title="INC / DEC | 自增 / 自减"></a>INC / DEC | 自增 / 自减</h4><ul>
<li><code>INC EAX</code>：每执行一次该指令，参数的值自增 1；</li>
<li><code>DEC EAX</code>：每执行一次该指令，参数的值自减 1；</li>
</ul>
<h4 id="MUL-无符号乘法"><a href="#MUL-无符号乘法" class="headerlink" title="MUL 无符号乘法"></a>MUL 无符号乘法</h4><ul>
<li><code>MUL ECX</code>：<code>MUL CL | CX | ECX</code>默认和 <code>AL | AX | EAX</code>做乘法运算，运算结果分别存放到<br><code>AL | DX:AX | EDX:EAX</code>中，其中<code>DX 或 EDX</code>存放高位，<code>AX 或 EAX</code>存放低位；</li>
</ul>
<h4 id="DIV-无符号除法"><a href="#DIV-无符号除法" class="headerlink" title="DIV 无符号除法"></a>DIV 无符号除法</h4><ul>
<li><code>DIV CL</code>：默认的被除数为<code>EAX</code>，如果 <code>CL（除数）</code>是 8 位，那么<code>商</code>放在<code>AL</code>中，<code>余数</code>放在<code>AH</code>中；</li>
<li><code>DIV CX</code>：默认的被除数为<code>EAX</code>，如果 <code>CX（除数）</code>是 16 位，那么<code>商</code>放在<code>AX</code>中，<code>余数</code>放在<code>DX</code>中；</li>
<li><code>DIV ECX</code>：默认的被除数为<code>EAX</code>，如果 <code>ECX（除数）</code>是 32 位，那么<code>商</code>放在<code>EAX</code>中，<code>余数</code>放在<code>EDX</code>中；</li>
</ul>
<h4 id="IMUL-有符号乘法"><a href="#IMUL-有符号乘法" class="headerlink" title="IMUL 有符号乘法"></a>IMUL 有符号乘法</h4><ul>
<li>立即数：自然数；</li>
<li>单操作数：<code>IMUL CL | CX | ECX</code>默认和 <code>AL | AX | EAX</code>做乘法运算，运算结果分别存放到<br><code>AL | DX:AX | EDX:EAX</code>中，其中<code>DX 或 EDX</code>存放高位，<code>AX 或 EAX</code>存放低位；</li>
<li>双操作数：<code>IMUL AX, CX | 0x2</code>：第一个参数必须是通用寄存器，第二个参数可以是通用寄存器、内存地址或立即数，运算结果存放到第一个参数中；</li>
<li>三操作数：<code>IMUL AX, CX, 0x2</code>：第一个参数必须是通用寄存器，第二个参数可以是通用寄存器或内存地址，第三个参数必须是立即数，将第二个参数和第三个参数的运算结果存放到第一个参数中；</li>
</ul>
<h4 id="IDIV-有符号除法"><a href="#IDIV-有符号除法" class="headerlink" title="IDIV 有符号除法"></a>IDIV 有符号除法</h4><ul>
<li><code>IDIV CL</code>：默认的被除数为<code>EAX</code>，如果 <code>CL（除数）</code>是 8 位，那么<code>商</code>放在<code>AL</code>中，<code>余数</code>放在<code>AH</code>中；</li>
<li><code>IDIV CX</code>：默认的被除数为<code>EAX</code>，如果 <code>CX（除数）</code>是 16 位，那么<code>商</code>放在<code>AX</code>中，<code>余数</code>放在<code>DX</code>中；</li>
<li><code>IDIV ECX</code>：默认的被除数为<code>EAX</code>，如果 <code>ECX（除数）</code>是 32 位，那么<code>商</code>放在<code>EAX</code>中，<code>余数</code>放在<code>EDX</code>中；</li>
</ul>
<h4 id="XADD-先交换后相加"><a href="#XADD-先交换后相加" class="headerlink" title="XADD 先交换后相加"></a>XADD 先交换后相加</h4><ul>
<li><code>XADD EAX, ECX</code>：先交换两个参数的值，然后进行加法运算，运算结果保存在第一个参数中；</li>
</ul>
<h4 id="NEG-取反"><a href="#NEG-取反" class="headerlink" title="NEG 取反"></a>NEG 取反</h4><ul>
<li><code>NEG EAX</code>：如题，取反</li>
</ul>
<h3 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h3><h4 id="AND-OR-XOR-NOT"><a href="#AND-OR-XOR-NOT" class="headerlink" title="AND / OR / XOR / NOT"></a>AND / OR / XOR / NOT</h4><ul>
<li>全部以二进制形式进行比较 / 操作；</li>
<li><code>AND EAX, ECX</code>：双 1 为 1，否则为 0；</li>
<li><code>OR EAX, ECX</code>：逢 1 为 1，否则为 0；</li>
<li><code>XOR EAX, ECX</code>：不同为 1，相同为 0；</li>
<li><code>NOT EAX</code>：二进制取反；</li>
</ul>
<h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h4><ul>
<li><code>CMP EAX, ECX</code>：两个参数相减进行比较，如果运算结果为 0，则 <code>ZF（0 标志位）</code>为 1；</li>
<li>通用寄存器、内存地址和立即数之间可以相互比较；</li>
</ul>
<h4 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h4><ul>
<li><code>TEST EAX, EAX</code>：判断 EAX 自身是否为 0；</li>
<li>如果运算结果为 0，且 ZF（0 标志位）为 1，则说明 EAX 自身为 0；</li>
</ul>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h4 id="JMP-无条件跳转"><a href="#JMP-无条件跳转" class="headerlink" title="JMP 无条件跳转"></a>JMP 无条件跳转</h4><ul>
<li><code>JMP 00401018</code>：无条件跳转；</li>
</ul>
<h4 id="JE-JZ"><a href="#JE-JZ" class="headerlink" title="JE / JZ"></a>JE / JZ</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>ZF（0 标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNE-JNZ"><a href="#JNE-JNZ" class="headerlink" title="JNE / JNZ"></a>JNE / JNZ</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>ZF（0 标志位）</code>为 0 则跳转；</li>
<li>与<code>JE / JZ</code>相反；</li>
</ul>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><ul>
<li><code>SF（符号位标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNS"><a href="#JNS" class="headerlink" title="JNS"></a>JNS</h4><ul>
<li><code>SF（符号位标志位）</code>为 0 则跳转；</li>
<li>与<code>JS</code>相反；</li>
</ul>
<h4 id="JP-JPE"><a href="#JP-JPE" class="headerlink" title="JP / JPE"></a>JP / JPE</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>PF（奇偶标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNP-JPO"><a href="#JNP-JPO" class="headerlink" title="JNP / JPO"></a>JNP / JPO</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>PF（奇偶标志位）</code>为 0 则跳转；</li>
<li>与<code>JP / JPE</code>相反；</li>
</ul>
<h4 id="JO"><a href="#JO" class="headerlink" title="JO"></a>JO</h4><ul>
<li><code>OF（溢出标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNO"><a href="#JNO" class="headerlink" title="JNO"></a>JNO</h4><ul>
<li><code>OF（溢出标志位）</code>为 0 则跳转；</li>
<li>与<code>JO</code>相反；</li>
</ul>
<h4 id="JB"><a href="#JB" class="headerlink" title="JB"></a>JB</h4><ul>
<li><code>CF（进位 / 借位 标志位）</code>为 1 则跳转；</li>
<li>JB 不关注符号位，只关注无符号位的运算；</li>
</ul>
<h4 id="JNB"><a href="#JNB" class="headerlink" title="JNB"></a>JNB</h4><ul>
<li><code>CF（进位 / 借位 标志位）</code>为 0 则跳转；</li>
<li>与<code>JB</code>相反；</li>
</ul>
<h4 id="JL"><a href="#JL" class="headerlink" title="JL"></a>JL</h4><ul>
<li><code>SF（）符号位标志位</code>为 1 则跳转；</li>
<li>与 JB 不同的是，JL 关注有符号位的运算；</li>
<li>JL 会忽略<code>CF（进位 / 借位 标志位）</code>的变化；</li>
</ul>
<h4 id="JBE"><a href="#JBE" class="headerlink" title="JBE"></a>JBE</h4><ul>
<li><code>OF（溢出标志位）为 1</code>或<code>ZF（0 标志位）为 0</code>则跳转；</li>
<li>小于等于；</li>
</ul>
<h4 id="JNBE-JA"><a href="#JNBE-JA" class="headerlink" title="JNBE / JA"></a>JNBE / JA</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>OF（溢出标志位）为 0</code>并且<code>ZF（0 标志位）为 1</code>则跳转；</li>
<li>必须是大于；</li>
</ul>
<h4 id="CALL-RETN"><a href="#CALL-RETN" class="headerlink" title="CALL / RETN"></a>CALL / RETN</h4><ul>
<li>CALL 可以理解为 CALLBACK；</li>
<li>CALL 会执行一个子程序，可以理解为执行了一个函数；</li>
<li>RETN 在 CALL 所执行的子程序中时，会返回该 CALL 所在的主程序，并继续向下执行；</li>
<li>RETN 与其他指令单独使用时，和 JMP 的功能相同；</li>
</ul>
<h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><ul>
<li>LOOP 相当于</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XOR ECX, ECX</span><br><span class="line">MOV ECX, 6</span><br><span class="line">DEC ECX</span><br><span class="line">&#x2F;&#x2F; CMP ECX, 0</span><br><span class="line">TEST ECX, ECX</span><br><span class="line">JNZ [DEC ECX 所在的地址]</span><br></pre></td></tr></table></figure>

<ul>
<li>与以上指令不同的是：LOOP 执行时第一次循环计数器不会自减；</li>
<li>约定俗成：使用 ECX 作为计数器；</li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>直接寻址：指令后面直接写出此次运算使用的地址，称为直接寻址；</li>
<li>间接寻址：只有执行到某一行指令才能知道此次运算使用的地址，称为间接寻址；</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之断点</title>
    <url>/post/2731277808/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版</li>
<li>简称<code>OD</code>；</li>
</ul>
<a id="more"></a>

<h4 id="断点的分类"><a href="#断点的分类" class="headerlink" title="断点的分类"></a>断点的分类</h4><h5 id="F2-断点"><a href="#F2-断点" class="headerlink" title="F2 断点"></a>F2 断点</h5><ul>
<li><code>F2断点</code>又叫<code>普通断点</code>、<code>CC断点</code>、<code>int3断点</code>；</li>
<li>在<code>OD</code>反汇编窗口（<code>C</code>窗口）中，双击语句的某一行或按下 F2 会设置（触发）一个<code>int3 断点</code>；</li>
<li><code>int3</code>是一个断点（中断）指令，在汇编中机器码是<code>CC</code>，所以，<code>F2断点</code>又可以称为<code>int3断点</code>或<code>CC断点</code>；</li>
<li>在使用 F2 设置断点后，CPU 会引发一个异常，而 OD 会捕获这个异常，从而中断程序；</li>
<li>可以使用命令<code>bp xxxxxxxx</code>快速设置一个<code>CC断点</code>；</li>
<li><code>bp</code>可以为内存地址设置断点，也就是为某条语句设置断点；</li>
<li><code>bp</code>当然也可以为<code>API（函数）</code>设置一个断点，如<code>bp MessageBoxA</code>，断点会设置在 API 的行首，也就是函数的第一行；</li>
<li>通常情况下，当使用<code>bp</code>为<code>API</code>设置断点时，该<code>API</code>应该是可见的，也就是在反汇编窗口按下<code>Ctrl + N</code>后，在函数窗口能找得到时，才能使用<code>bp</code>设置断点，不过偶尔在找不到的情况下，也能使用<code>bp</code>设置断点，这种情况时可以买一注彩票；</li>
<li>使用<code>bp MessageBoxA</code>也就是为<code>API</code>设置断点后，会在系统领空下，这个<code>API</code>的行首设置断点；</li>
<li>使用<code>bpx MessageBoxA</code>也就是为<code>API</code>设置断点后，会在程序领空下，所有调用这个<code>API</code>的位置设置断点；</li>
<li><code>F2断点</code>的设置没有数量限制，可以设置无数个，只要你看着爽；</li>
<li><code>F2断点</code>很容易被检测，从而触发反调试；</li>
<li><code>F2断点</code>重载程序后不会丢失；</li>
</ul>
<h5 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h5><ul>
<li><code>内存断点</code>是通过修改内存属性为不可访问、不可执行来实现的；</li>
<li><code>内存断点</code>同时只能存在一个；</li>
<li><code>内存断点</code>在重载程序后会丢失，需要重新设置；</li>
</ul>
<h5 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h5><ul>
<li><code>硬件断点</code>最多可以设置 4 个；</li>
<li><code>硬件断点</code>在设置位置的下一条指令中断；</li>
<li>可以使用命令<code>HE xxxxxxxx</code>快速设置一个<code>硬件断点</code>；</li>
<li>可以使用命令<code>HE MessageBoxA</code>在<code>API</code>的行首快速设置一个<code>硬件断点</code>；</li>
</ul>
<h5 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h5><ul>
<li>满足某个条件的<code>CC断点</code>;</li>
<li>使用<code>shift + F2</code>快速设置条件断点；</li>
</ul>
<h5 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h5><ul>
<li>和条件断点类似，多了记录日志等功能，更加详细的设置条件；</li>
<li>使用<code>shift + F4</code>快速设置条件断点；</li>
</ul>
<h5 id="API-断点"><a href="#API-断点" class="headerlink" title="API 断点"></a>API 断点</h5><ul>
<li>给系统提供的 API 设置的<code>CC断点</code>；</li>
<li><code>MessageBoxA</code>中的<code>A</code>表示使用<code>ASCII</code>编码；</li>
<li><code>MessageBoxW</code>中的<code>W</code>表示使用<code>Unicode</code>编码；</li>
</ul>
<h5 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h5><ul>
<li>消息断点实际上就是条件记录断点；</li>
<li>在操作窗口或控件时，都会发送一个消息；</li>
<li>在<code>OD</code>的<code>W</code>窗口刷新来获取交互消息；</li>
<li>检测交互（消息循环）来设置<code>消息断点</code>，如<code>101 按键抬起</code>、<code>202 鼠标左键抬起</code>等；</li>
<li>断点生效后，修改条件来记录操作日志，在<code>OD</code>的<code>L</code>窗口查看记录的日志或将日志输出到指定文件来进一步进行分析；</li>
</ul>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>断点</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（一）</title>
    <url>/post/2293324257/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网;</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来源于<a href="http://xuepojie.com/">学破解论坛</a>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy1j9yekwj30oc065t9q.jpg" alt="分析"><br>就是它了，选中它并右键<code>在输入函数上切换断点</code>，然后去<code>断点窗口（B 窗口）</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后运行程序，“随便输入”一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序停在了设置断点的<code>API</code>的行首，在堆栈窗口可以看到<code>API</code>的各种参数，而参数<code>Buffer</code>里存放着函数返回的数据，选中<code>Buffer</code>右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy267st5oj30t00drq4u.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下<code>Ctrl + F9</code>或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现<code>Buffer</code>对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下<code>F7 或 F8</code>，返回到调用<code>API</code>的程序，发现接下来将要执行的代码很可疑：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy2kqa9a0j30sz0dt0uo.jpg" alt="程序"><br>一个比较，一个跳转，并且文字显示和序列号有关；</p>
</li>
<li><p>分析一下这几行可疑的代码：</p>
<ul>
<li><p><code>MOV EDX,CrackMe.00403008</code>将<code>00403008</code>这个地址拷贝到<code>EDX</code>，执行一下这行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy2xlpyn3j308805374d.jpg" alt="EDX"></p>
<p>在<code>EDX</code>存放的地址中发现一串可疑字符串，选中<code>EDX</code>右键<code>数据窗口中跟随</code>，原来可疑字符串只是前面几位，而后面那几个字符是我们输入的字符；</p>
</li>
<li><p><code>MOV EBX,DWORD PTR DS:[403010]</code>将<code>00403010</code>这个地址中的数据的前四个字节拷贝到<code>EBX</code>，执行一下这行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy3ehrs27j30as0ay3zf.jpg" alt="EBX"></p>
<p>既然<code>EBX</code>中存放的是数据，而数据又看不懂，怎么知道是什么呢？<code>OD</code>很强大，选择那行代码并右键<code>数据窗口中跟随，然后选择内存地址</code>或者在数据窗口选中那行代码的数据并选择<code>数据窗口中跟随地址</code>就可以看到<code>EBX</code>中存放的内容了，原来是我们输入的“序列号”；</p>
</li>
<li><p><code>CMP EBX,DWORD PTR DS:[403008]</code>这行代码就没什么好说的了，减法比较是否相等，还使用了一个障眼法，<code>EDX</code>放地址，<code>EBX</code>放数据，在这里再取出<code>EDX</code>的数据进行比较；</p>
</li>
<li><p><code>JE SHORT CrackMe.00401087</code>这行也没啥说的，<code>JE</code>根据<code>ZF 标志位</code>进行跳转，而如果上一步的计算结果为<code>0</code>，则<code>ZF</code>为<code>1</code>，<code>JE</code>跳转成立，也就是说，如果<code>EDX</code>和<code>EBX</code>中的数据相同，那么序列号就是对的，<code>JE</code>跳转并向下执行，最后弹出<code>正确！</code>，反之则不跳转向下执行，弹出<code>序列号错误！</code>，看来第一步中发现的可疑字符串就是真正的序列号了；</p>
</li>
<li><p>如果想要输入啥都能通过验证，那么可以将<code>JE</code>改为<code>JMP</code>无条件跳转，保存修改到文件就获得了一个新的程序；</p>
</li>
<li><p>但我们的目的是找出真正的序列号，所以嘛，复制那串字符去试一下，果然，一切如我们所料！</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（三）</title>
    <url>/post/4122547819/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网;</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来源于<a href="http://xuepojie.com/">学破解论坛</a>；</li>
<li>文中所有的数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><h5 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h5><ol>
<li>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；<ul>
<li>这个 CrackMe 不一般，有两个部分，两个按钮，那就分两部分分析喽（这句话绕不绕）：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeer5jilj309a0740su.jpg" alt="CrackMe"></li>
</ul>
</li>
<li>倒入<code>OD</code>开始分析：<ul>
<li>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</li>
<li>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyek762n6j30k20cgq4j.jpg" alt="第一部分"><br>很好的开始，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</li>
<li>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</li>
<li>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeq2lafej311s0kx415.jpg" alt="Buffer"></li>
<li>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</li>
<li>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，多么令人兴奋的内容，这么简单吗，会不会有诈？<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeumc7cqj30m60bbmyl.jpg" alt="第一部分找到了"></li>
<li>那就分析一下，看看到底是啥：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyf5uv9tsj30nc0b1gms.jpg" alt="第一部分结束"><br>看来第一部分很简单，逻辑简单粗暴，只要不对直接弹出错误；<br>第一部分到此结束。<br>既然第一部分这么简单，那难点肯定在第二部分，去看看！</li>
</ul>
</li>
</ol>
<h5 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h5><ul>
<li>倒入<code>OD</code>开始分析：<ul>
<li>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</li>
<li>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，还是那个可疑的函数：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfexxb79j30kc0cmabo.jpg" alt="第二部分"><br>很好的开始，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</li>
<li>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</li>
<li>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfhdwjazj311o0l076u.jpg" alt="Buffer"></li>
<li>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</li>
<li>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，哦豁，好像没啥有用的内容，等等，下面还有个<code>GetWindowTextA</code>，对对，我们输入了用户名和密码，那就得获取两次，而第一次获取的是密码，那就<code>F9</code>再运行程序；</li>
<li>是的，又获取了一次，而这次获取的是用户名，执行到用户代码，果然是下面这个<code>GetWindowTextA</code>，那下面就是比较的代码了呗，毕竟它位于获取和弹窗之间；</li>
<li>那就分析一下它的流程：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfxtvb0yj30ng0ecq43.jpg" alt="开始"><ul>
<li>第一行<code>TEST EAX, EAX</code>不迷茫，<code>TEST EAX, EAX</code>表示检查<code>EAX</code>自身是否为 0，而第二行的<code>JE SHORT 硬编码寻.0040167E</code>指向了一个<code>MessageBoxA</code>，那就说明<code>EAX</code>很重要，既然弹窗提示的是<code>必须输入用户名才可以</code>，那它不是用户名的长度是什么，况且<code>EAX</code>里的数据刚好和用户名长度相同；</li>
<li>接下来，它对用户名做了一系列的运算，并把运算的结果放到了指定的内存中，暂时还不知道它想干嘛：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyh5fsj3gj30ox082753.jpg" alt="用户名"></li>
<li>同样的，又对输入的假序列号进行了一系列运算，并把运算结果放到了指定的内存中，不过相对于用户名，序列号的处理比较简单，只是进行了除法运算，并存储了余数：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyh8v4k4vj30oz05faah.jpg" alt="假码"></li>
<li>直到序列号运算完毕，一个<code>JMP</code>跳下来，分析之后，终于知道了它要干什么：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyhc0gpmtj30oy08ddgr.jpg" alt="比较"><br>原来，它上面进行的一系列运算，是为这一步的比较做准备；</li>
<li>至此，终于分析出了结果：这里没有硬编码，而是软编码，序列号是根据用户名计算出来的</li>
<li>至于计算的规则：<ul>
<li>用户名的运算规则：用户名的下标从零开始，每个字节依次和<code>A</code>进行除法运算，然后用余数和下标异或之后的值加 2；</li>
<li>序列号的运算规则：序列号的每个字节和<code>A</code>进行除法运算，然后用余数和用户名运算的结果进行比较；</li>
<li>序列号的算法：任意数字和<code>A</code>进行乘法运算，并加上用户名每个字符运算的结果就是这个用户名对应的序列号，运算的结果必须可以转为<code>ASCII</code>码中的数字；</li>
<li>例如：<ul>
<li>用户名： yang</li>
<li>运算的结果：03 08 04 02</li>
<li>序列号算法：<code>5 * A + 3 = 35</code> <code>4 * A + 8 = 30</code> <code>5 * A + 4 = 36</code> <code>5 * A + 2 = 34</code></li>
<li>转成 ASCII：5064<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyhyvwfqlj30d2074aaa.jpg" alt="成功"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（二）</title>
    <url>/post/3097998650/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网;</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来源于<a href="http://xuepojie.com/">学破解论坛</a>；</li>
<li>文中所有的数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy5o1g2gpj30g90bwjsq.jpg" alt="函数"><br>很好的开始，在<code>GetDlgItemTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy5y9rif4j30sr0fsq51.jpg" alt="运行"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，哇，密密麻麻全是汇编语句，往下翻了翻，也没发现什么关键字、有用的信息，接着<code>F9</code>运行，直接弹出了错误信息：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy69uwm08j303z03z0sn.jpg" alt="弹窗"></p>
</li>
<li><p>看来此路不通啊，但是“程序给我们关上了一扇门，同时又开了一扇窗”，没错，就是它，弹窗，在最开始的函数列表中也有它的身影<code>MessageBoxA</code>，那就从它入手试试；</p>
</li>
<li><p>禁用<code>GetDlgItemTextA</code>并设置<code>MessageBoxA</code>断点，重新运行程序，输入并运行程序后，拦截到了即将要弹出的信息，信息显示在堆栈窗口：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy6hpjnooj30ug0i0wgm.jpg" alt="错误"><br>如果程序继续运行，将弹出<code>错误！</code>弹窗；</p>
</li>
<li><p>堆栈窗口的顶部显示的是调用信息，包括调用地址、返回地址等<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy6m2r60qj30cw05q0t2.jpg" alt="堆栈"></p>
</li>
<li><p>堆栈顶端，也就是当前<code>ESP</code>指向的堆栈中则是调用地址，也就是说这个地址调用了<code>MessageBoxA</code>这个<code>API</code>，根据程序的流程：程序经过比较之后，发现序列号不对，所以调用<code>MessageBoxA</code>并弹出错误窗口。<br>按照这个逻辑，如果跟随调用地址，是不是就能找到程序进行比较的代码？那还等什么，右键堆栈顶端的地址（堆栈中被标注黑色背景的地址就是堆栈顶端）选择<code>反汇编窗口中跟随</code>，就来到了调用<code>MessageBoxA</code>的程序，查看上面的代码，发现了一些端倪：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy7fm1cz5j30ue0j8jur.jpg" alt="调用"><br>上面有一个<code>JNZ</code>跳转进来，从而调用了<code>MessageBoxA</code>，所以弹出了错误弹窗，而<code>JNZ</code>的下面还有一个<code>MessageBoxA</code>，那可以猜测，如果不跳转继续向下执行，很有可能弹出的就是注册成功的弹窗，<code>JNZ</code>根据<code>ZF 标志位</code>进行跳转，如果修改<code>ZF 标志位</code>为<code>1</code>，就可以验证一下猜测是否正确，如何修改呢，继续往上翻代码，嘿嘿，发现一个有用的东西<code>GetDlgItemTextA</code>，在调用地址双击数据窗口设置<code>CC断点</code>，重载程序<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy84b4uhoj30uc0j7acn.jpg" alt="重载"></p>
</li>
<li><p>输入并运行程序后，在最后设置断点的地方停了下来，那下面就是要执行的代码了，分析一下看能不能找到隐藏的序列号：</p>
<ul>
<li><p>才分析了几行代码，有一种上了恶当的感觉，感觉它在转移某些内容，就暂且将它转移的内容称为“可疑字符串”：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy8q1uc0zj30p50740ts.jpg" alt="序列号"></p>
</li>
<li><p>不管了，继续分析，依然没有收获：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy90t76crj30om05zjrs.jpg" alt="没有收获"></p>
</li>
<li><p>直到分析了一个轮回，终于有了收获，程序会用我们输入的序列号的每一个字节的机器码减 14 后，和指定的机器码进行比较：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy9zbazz5j30p10ac75f.jpg" alt="循环"></p>
</li>
<li><p>而我们利用<code>MessageBoxA</code>断点，分析的<code>JNZ</code>的跳转条件是：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyb22if59j30p10hewgy.jpg" alt="JNZ"></p>
</li>
<li><p>如何让条件成立呢？恰恰在我们没有分析到的代码，因为我们输入的序列号是错误的，所以正确的代码根本不会执行，更谈不上分析了：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybg7od2pj30p20acjsn.jpg" alt="正确"><br>在这里，如果是正确的序列号，那么每次比较完成后，<code>EBP - 10</code>和<code>EBP - 34</code>作为两个计数器，它们会正确的同时自增，在最后的比较长度时也就会相等了；</p>
</li>
</ul>
</li>
<li><p>所以，正确的序列号是什么呢？<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybxcwm3ej30p00abjtb.jpg" alt="序列号"></p>
<ul>
<li>在比较的位置设置断点，获取每次比较时给定的字符的机器码，然后加上 14，最后转为 ASCII 码，就是正确的序列号；</li>
<li>获取到的给定字符的机器码：1D 1E 1F 44 61 51 3C 5B 36 55 51</li>
<li>字符的机器码加 14 之后的值：31 32 33 58 75 65 50 6F 4A 69 65</li>
<li>转换为 ASCII 码后的值：123XuePoJie</li>
</ul>
</li>
<li><p>最后，完整的分析图：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyciwo9jqj30y80u0tf0.jpg" alt="完整图"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（五）</title>
    <url>/post/755681865/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网;</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来源于<a href="http://xuepojie.com/">学破解论坛</a>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻还真不少，善用搜索，<code>GetDlgItemTextA</code>没找到，那就试试<code>GetWindowTextA</code>，还真有，就它了，在<code>GetWindowTextA</code>上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p><code>F9</code>运行程序，然鹅，输入内容并点击验证按钮后，程序并没有暂停；</p>
</li>
<li><p>界面有按钮，试试消息断点，还是没用，又尝试<code>硬件断点</code>以及<code>内存断点</code>均无效之后，只能去翻大佬的教程，以下内容是学习了<a href="http://xuepojie.com/"><code>Shark恒</code></a>大佬的教程之后自己的总结；</p>
</li>
<li><p>使用一个特殊的<code>API：TranslateMessage</code>，没错，它的功能就是字面的意思<code>翻译虚拟按键消息为字符消息</code>，很好很强大；</p>
</li>
<li><p>在<code>API</code>列表页面搜索，还真有，设置断点，然后在<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，还没有完，在断点上右键<code>断点&gt;&gt;条件记录</code>或者<code>Shift + F4</code>（也就是<code>条件记录断点</code>，毕竟<code>API断点</code>的本质就是<code>CC断点</code>），修改条件：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjea06qzj311u0nfad3.jpg" alt="TranslateMessage"></p>
</li>
<li><p>然后运行程序，输入并点击验证，程序在<code>TranslateMessage</code>函数的行首暂停下来，然后<code>Ctrl + F9</code>或者点击菜单栏的调试选项并选择<code>执行到返回</code>，然后<code>F8</code>单步执行到程序领空；</p>
</li>
<li><p>然后在<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，搜索输入的序列号：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjv4k2qij311w0ngn0d.jpg" alt="查找"><br>找到最接近<code>输入的序列号</code>的内容，设置<code>内存访问断点</code>:<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjz6z1umj311m0n7tc9.jpg" alt="内存访问断点"></p>
</li>
<li><p>运行程序，程序暂停在了读取序列号的地方，开始分析：<br>好聪明的“程序”，开始转移数据了：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizk98xwaej313w0ncdis.jpg" alt="转移数据"></p>
</li>
<li><p>既然它都挪窝儿了，咱也别闲着了：在<code>EDI</code>上右键选择<code>数据窗口中跟随</code>,果然，输入的序列号在这里了，选择序列号的数据右键<code>断点&gt;&gt;删除内存访问断点</code>删除第一次设置的<code>内存访问断点</code>，也可以理解为设置在<code>ESI</code>上的<code>内存访问断点</code>，既然数据都转移了，断点也就没意义了，所以要重新设置在<code>EDI</code>上，再次选择序列号的数据右键<code>断点&gt;&gt;内存访问</code>，这样就实时掌握了输入的序列号的动向了：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizko5erudj31450o7gpl.jpg" alt="EDI"></p>
</li>
<li><p>继续运行程序，终于来到来最关键的地方：比较<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizlfw3ua4j313q0s4dky.jpg" alt="比较"><br>分析完毕，逻辑简单粗暴：</p>
<ul>
<li>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>最后，恢复寄存器的内容并<code>RETN</code>，直接弹出错误的弹窗；</li>
</ul>
</li>
<li><p>分析的时候已经发现了正确的序列号，也就是可疑字符串，试一下：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizm3afyiyj30am0btacd.jpg" alt="完工"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（六）</title>
    <url>/post/1208254864/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网;</li>
<li><code>OD</code>插件：<code>中文搜索引擎</code>和<code>ApiBreak</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>【歪坑牌 CM2.2】来源于<a href="http://xuepojie.com/">学破解论坛</a>；</li>
<li><a href="http://xuepojie.com/"><code>Shark恒</code></a>大佬教了一种方法，但中间部分内容需要经验判断，才疏学浅的我一直不明白，经过多次失败后总结出了属于自己的方法，So，设置断点的思路来源于大佬，分析的过程属于自己；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
<ul>
<li>这个软件的操作有点不同寻常，填写内容之后会提示注册成功，并且通过重启来验证是否正确：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ctzk1nmj30vq089dh5.jpg" alt="流程"></li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻还真不少，搜索一下，<code>GetDlgItemTextA</code>没找到，那就试试<code>GetWindowTextA</code>，还真有，在<code>GetWindowTextA</code>上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p><code>F9</code>运行程序，输入并点击登录之后，还是熟悉的弹窗，点击弹窗的确定按钮之后，嘿，又回到了解放前，这让我很困惑，难道它是在弹窗之后运行吗？毫无头绪；</p>
</li>
<li><p><code>TranslateMessage</code>呢？没有 Buffer，无从下手；</p>
</li>
<li><p>给<code>MessageBox</code>设置断点？皮，它都重启了，断点有什么*用，逆推呢？设置断点跟随之后发现没有什么有价值的内容；</p>
</li>
<li><p>试一试<code>内存断点</code>，暂停的地方不重要而且在断点位置无限循环，根本连登录按钮都点不了，既然都没有登录肯定没有验证，断点的地方当然不重要了；</p>
</li>
<li><p>试试<code>消息断点</code>，暂停了，但没有 Buffer，无从下手；</p>
</li>
<li><p>试试<code>中文搜索引擎</code>，跟了很久，一无所获；</p>
</li>
<li><p>至于<code>硬件断点</code>，一直不懂它的工作原理，不敢乱用，说白了就是用不明白；</p>
</li>
<li><p>既然自己搞不定，关了它放弃又不是我的性格，那还能怎么样？<code>量力而行，虚心请教</code>，以下内容是学习之后的总结：</p>
<ul>
<li><p>原来，<code>中文搜索引擎</code>不只是找关键字的，之前的用法只是个皮毛，还可以找到其它有用的信息，而恰恰这才是重点：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0e6c5pycj312m0ksmzu.jpg" alt="关注点"></p>
</li>
<li><p>如果看到<code>software</code>说明这个程序使用了注册表，而关键信息可能就存储在注册表中：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ear0vunj31220kyjsu.jpg" alt="注册表"></p>
</li>
<li><p>既然它将输入的内容存储在注册表中，那么验证的时候一定会去注册表取回内容，所以这个节点才是关键的环节，重载程序，删除之前设置的无用断点，接下来就是重点了；</p>
</li>
<li><p>至于如何设置断点呢，那就要使用今天的主角儿了<code>ApiBreak</code>，点击菜单栏的插件选项并选择<code>ApiBreak &gt;&gt; API断点</code>，然后选择<code>注册表</code>以及<code>RegQueryValueExA</code>选项之后，点击确定;(翻译一下<code>RegQueryValueExA</code>：<code>Reg</code>是注册表，<code>Query</code>是查询，<code>Value</code>是值，<code>ExA</code>是 16 进制，连起来应该是<code>设置查询注册表16进制值的断点</code>，不知道对不对)<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0eovwbz4j312m0kv77d.jpg" alt="设置断点"></p>
</li>
<li><p>设置好断点之后，运行程序，程序会中断多次，应该是查询了很多次，但我们的关注点只是两个：<code>用户名</code>和<code>密码</code>，那就继续运行程序，直到在堆栈窗口看到需要的信息：</p>
<p><code>用户名</code>出现了两次，第一次<code>Buffer</code>中没有地址，第二次<code>Buffer</code>中才有地址，第二次才是我们关注的重点， 在<code>Buffer</code>上右键<code>数据窗口中跟随</code>，然后<code>Ctrl + F9</code>执行到返回，果然，它获取了我们输入的用户名：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0f4rlxcbj312j0kttc1.jpg" alt="用户名"><br>同样的情况也会出现在<code>密码</code>身上，继续运行程序，获取密码：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0fbu0phrj312i0kvgp0.jpg" alt="密码"></p>
</li>
<li><p>既然它已经获取了用户名和密码，那就上正菜吧：<br>获取密码后，在<code>Buffer</code>上右键<code>数据窗口中跟随</code>，然后<code>Ctrl + F9</code>执行到返回，果然，它获取了我们输入的密码，在<code>数据窗口</code>选中密码数据右键<code>断点 &gt;&gt; 内存访问</code>设置<code>内存访问断点</code>：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0fkgngw7j312k0kqdi4.jpg" alt="内存访问断点"></p>
</li>
<li><p>然后继续运行程序，程序中断了，但看了看代码发现这里不是重点，而且继续运行还会中断，数一数，中断的次数刚好是密码的长度，并且每运行一次，<code>ESI寄存器</code>中存储的密码都会向前移动一位；</p>
</li>
<li><p>继续运行程序，程序再次中断，重点来了，开始分析：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0g4fjgc6j312e0rfgq5.jpg" alt="分析完毕"><br>分析完毕，逻辑似曾相识的感觉，没错，和<code>逆向分析之硬编码寻找序列号（五）</code>中的逻辑一模一样：</p>
<ul>
<li>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>最后，恢复寄存器的内容并<code>RETN</code>，然后弹窗，最后回到解放前；</li>
</ul>
</li>
</ul>
</li>
<li><p>分析完了，那真正的密码是什么呢？当然就是“可疑字符串”：一串看起来杂乱无章的字符，那密码的计算规则又是什么呢？</p>
<p><code>RETN</code>返回的地方永远是调用它的位置的下一行，那如果跟着<code>RETN</code>是不是就能找到调用它的地方，结果是肯定的：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0laiieabj312h0rfadz.jpg" alt="调用"><br>如果<code>JNZ</code>是返回的位置，那上面一行的<code>CALL</code>就是调用的地方，如何证明呢？很简单，<code>JNZ</code>根据<code>ZF 标志位</code>跳转，如果跳转肯定就注册失败了，那不跳转是不是就成功了？试一试，将<code>ZF 标志位</code>置 1，然后运行程序，正如所料，注册成功：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0lezrrqtj30bi067t8s.jpg" alt="注册成功"></p>
<p>这就说明，这个<code>CALL</code>很重要，给<code>CALL</code>的位置设置断点，重载程序，程序在<code>CALL</code>的位置暂停，既然<code>CALL</code>内部是判断，那上面很可能就是获取并处理了，既然正确的密码是一串杂乱无章的字符，那么它应该需要一个<code>CALL</code>去处理，所以，大胆的猜测一下，上面那个<code>CALL</code>可能就是处理程序，给上面那个<code>CALL</code>也设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0lu3l9iuj312g0rfq7j.jpg" alt="处理"></p>
<p>再次重载程序，程序中断，<code>F8</code>向下执行，查看中间那两行代码干了什么，很有可能就是判断<code>CALL</code>（也就是函数）的参数：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0m4afip8j312g0rh78w.jpg" alt="参数"></p>
<ul>
<li>两行代码执行后，<code>EAX</code>的数据在<code>寄存器窗口</code>看的很清楚，就是我们输入的假码；</li>
<li>而<code>EDX</code>的数据是什么呢？选中<code>EDX</code>右键<code>数据窗口中跟随</code>，数据一目了然，正是比较时用的可疑字符串；</li>
<li>这也就证明了，上面那个<code>CALL</code>就是处理数据用的；</li>
<li>而密码的规则：在好多个<code>CALL</code>之间挑来挑去分析之后，发现是一串固定的字符串加上用户名的 16 进制表示；</li>
<li>如：yang 转换成 16 进制是<code>79616E67</code>，那么密码就是<code>€队蠹易仿耄79616E67</code>；</li>
</ul>
</li>
<li><p>测试一下：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0mxfxvr3j30v508p758.jpg" alt="测试"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（四）</title>
    <url>/post/1116999438/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网;</li>
<li><code>OD</code>插件：<code>中文搜索引擎</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来源于<a href="http://xuepojie.com/">学破解论坛</a>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><p>事实证明：不能“以貌取人”。</p>
<p>刚打开软件的时候，心里还想着，这么简陋？分分钟就逆向完毕了，结果，“啪啪啪”实力打脸，针扎的疼。</p>
<p>嗯，还在学习阶段，等我功力深厚之时，定会找回场子！</p>
<ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻，呀呵，看着简陋，用的<code>API</code>还真不少，那就搜索吧，没有<code>GetDlgItemTextA</code>？那就拿<code>GetWindowTextA</code>下手吧：在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>居然没有断下来，也没有弹窗，这让我很尴尬：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8frx378j305905zglj.jpg" alt="尴尬"></p>
</li>
<li><p>嗯，界面有按钮，那就试试消息断点，熟练的设置好<code>消息断点</code>，运行程序，输入，点击按钮，还是没有断下来；</p>
</li>
<li><p>不怕，还有<code>内存断点</code>、<code>硬件断点</code>，挨个试了一遍之后，没有一个成功的，灰心丧气呀，怎么像刺猬 🦔 一样无从下手？</p>
</li>
<li><p>等等，看了看程序的界面，猛的想起了大佬说的一个工具：</p>
<p><code>中文搜索引擎</code>：这玩意儿可以参考，但不要过分依赖，友好的开发者可能只是关闭你的程序不让你调试，至于不友好的，知道为啥要用虚拟机吗？</p>
</li>
<li><p>重载程序，在<code>反汇编窗口</code>右键选择<code>中文搜索引擎</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8ldzoguj311o0njq5w.jpg" alt="中文搜索引擎"></p>
<p>然后<code>Ctrl + F</code>搜索熟悉的字眼儿<code>Wrong Code DUDE</code>，果然有，双击来到<code>反汇编窗口</code>，嘿嘿，这里看起来很重要嘛：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8xso4qtj30m90by402.jpg" alt="关键"></p>
<ul>
<li>一个失败的字样；</li>
<li>一个成功的字样；</li>
<li>紧挨着上面有一个跳转：可以猜测，如果跳转的话，可能就显示成功了；</li>
<li>跳转上面是一个<code>CALL</code>，那它很可能是比较的<code>CALL</code>；</li>
<li>至于更上面的代码，那肯定是获取用的呗，瞎猜的；</li>
</ul>
</li>
<li><p>既然找到了可疑的代码，那就双击<code>CALL</code>给它下一个<code>CC断点</code>，然后运行程序，输入序列号点击验证后，程序暂停在了<code>CALL</code>的位置，那就<code>F7</code>进<code>CALL</code>看看，验证一下猜测；</p>
</li>
<li><p>刚一进<code>CALL</code>，就在寄存器窗口发现了熟悉的字样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz99kl1svj311n0nlgoq.jpg" alt="call"></p>
<p>既然把“序列号”都传进来了，那应该就是比较了，开始分析：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizaftudazj30xb0u0n15.jpg" alt="分析"></p>
</li>
<li><p>分析完成，比较的部分是常规方法，就是中断程序有点麻烦！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
</search>
