<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 添加 Utterance 评论功能</title>
    <url>/posts/3357819964/</url>
    <content><![CDATA[<blockquote>
<p>每逢看到大佬们的精彩文章，感慨甚多之际，不能留言把欢甚是遗憾。<br>缺少了留言支持、请教解惑、互相探讨，总感觉博客没有灵魂。</p>
</blockquote>
<hr>
<h4 id="最新版本Next主题已集成Utterance，So，此方法已弃用-❕❕❕"><a href="#最新版本Next主题已集成Utterance，So，此方法已弃用-❕❕❕" class="headerlink" title="最新版本Next主题已集成Utterance，So，此方法已弃用 ❕❕❕"></a>最新版本<code>Next</code>主题已集成<code>Utterance</code>，So，此方法已弃用 ❕❕❕</h4><hr>
<span id="more"></span>

<h4 id="废话连篇"><a href="#废话连篇" class="headerlink" title="废话连篇"></a>废话连篇</h4><p>曾记得，2016 年端午节，在<code>Github Pages</code>上写下了人生中的第一篇博客，那时就用的<code>Hexo + Next</code>主题，时至今日，一直对<code>Hexo + Next</code>甚是喜爱，感谢大佬，感谢开源 🙏 。</p>
<p>期间，经历了换工作、换电脑、换域名、换托管，诸多原因导致博客遗失，不过也是甚好，不能守着过去，要拥抱现在和未来（不应该是拥抱开源吗？）。</p>
<p>之前使用过<code>网易云跟帖</code>，大家都戏称灌水专用，现在业已关闭。</p>
<p>接着使用了<code>来必力</code>，一个来自韩国的评论插件，国内访问甚是感人，至于大佬们的反向代理，那时心有余而力不足，遂卒。</p>
<p>后来使用了<code>valine</code>，依托于<a href="https://www.leancloud.cn/">LeanCloud</a>在国内运营，对用户甚是友好，界面也是简洁清新，让人看一眼就喜爱，而且支持阅读统计等诸多功能，之后便一直使用。</p>
<p>偶然间，在<code>知乎</code>上闲逛时，发现了一位大兄关于评论插件的分析和感想，现在依稀记得的一句话就是“无论第三方插件的使用有多友好，数据都存在第三方，哪天他们歇业停工了，数据一样丢失。”，之后就对此耿耿于怀（当然不是对说这句话的仁兄耿耿于怀）。</p>
<p>重建博客之际，对评论插件抱着谨慎的态度选之又选，决定将数据存在<code>Github</code>上，至于歇业停工，既然博客数据都不存在了，还留着评论数据作甚，就让他们同生共死吧。</p>
<p><code>Gitalk</code>和<code>Gitment</code>最先映入眼帘，之后在<code>Github</code>上发现<code>Gitment</code>好久没有更新了，只剩下一个选择。</p>
<p><code>Hexo</code>官方集成了<code>Gitalk</code>，轻车熟路的做好设置，<code>hexo clean | g | s</code>三部曲之后，熟悉的框框出现，然鹅，发现每篇文章都要手动初始化，翻阅<a href="https://github.com/gitalk/gitalk/wiki/%E8%AF%84%E8%AE%BA%E5%88%9D%E5%A7%8B%E5%8C%96">官方 Wiki</a>发现了自动初始化的脚本，底部有<a href="https://draveness.me/git-comments-initialize/">原作者</a> 的链接，遂前往，准备学习膜拜一番，看了大佬的思路解析，大呼过瘾之际也感落寞，原因无他，就是自己不会<code>Ruby</code>。在准备留言评论之际，发现又有<a href="https://www.lshell.com/post/use-github-action-and-python-to-automatically-initialize-gitalk-comments/">大佬</a>给出了使用<code>Python</code>初始化的思路，用轮子不是目的，读懂造轮子的思路学习造轮子，岂不快哉。</p>
<p>进入文章，阅读之际，大佬既感且叹地推荐了一个新的评论插件<code>utterances</code>，揣着疑惑的心去<a href="https://utteranc.es/">官网</a>，去<a href="https://github.com/utterance/utterances">官方仓库</a>查看了一番，发现没有 Wiki，也没有文档，善用搜索引擎的我，搜索一番之后发现，似乎<code>Next</code>主题之前的某个版本集成过，但翻阅了现在的版本又毫无所获，教程都是根据集成时的方法写的，对我无用。</p>
<p>在这里，不得不提的是<code>Hexo</code>的一项前瞻性功能<code>代替配置文件</code>和<code>代替主题配置文件</code>，再也不用像之前一样，想要实现某个功能就去修改官方文件，它不破坏官方文件的完整性，可以无痛更新，之前最头疼的一件事儿就是<code>拉取官方更新之后合并冲突</code>。</p>
<p>这次重建博客，所有非官方功能，如 404、音乐、footer，都使用<code>注入</code>实现，我对这项功能的称呼，暂且这么叫吧。</p>
<p>以上都是废话，下面进入正题：</p>
<h4 id="首先，需要一个用来存储评论的仓库"><a href="#首先，需要一个用来存储评论的仓库" class="headerlink" title="首先，需要一个用来存储评论的仓库"></a>首先，需要一个用来存储评论的仓库</h4><ul>
<li>你可以新建一个仓库；</li>
<li>当然，也可以像我一样，存放在博客仓库的 Issues 中，毕竟我已经承诺了它们同生共死，说到就要做到；</li>
<li>Issues 无法删除，请谨慎选择，防止过多的无用 Issues 带来烦恼（设置 utterances 的时候，这句话依然有效！）；</li>
</ul>
<h4 id="安装-utterances"><a href="#安装-utterances" class="headerlink" title="安装 utterances"></a>安装 utterances</h4><ul>
<li><p>点击<a href="https://github.com/apps/utterances">这里</a>打开安装页面，然后点击右上角的<code>安装</code>；</p>
</li>
<li><p>按下安装按钮，（不不不，不够严谨，按下是 201，抬起才是 202），你会跳转到：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giukvthjlpj30fy0oqtbi.jpg" alt="第二步"></p>
<p>如图所示的页面，选择第一步中创建的仓库或已有的仓库，然后点击<code>安装</code>，请记住仓库名，因为接下来要用；</p>
</li>
<li><p>接下来，会跳转到设置页面；</p>
</li>
</ul>
<h4 id="设置-utterances"><a href="#设置-utterances" class="headerlink" title="设置 utterances"></a>设置 utterances</h4><ul>
<li><p>在这里，请务必填写你在上一步中选择的仓库，并在前面加上仓库的所有者：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giul8ahfszj30k60bfwfv.jpg" alt="第三步"></p>
</li>
<li><p>当然，如果你比较调皮，没有填写上一步中选择的仓库，还是有补救办法的，点击<a href="https://github.com/apps/utterances">这里</a>，其实就是安装页面，你会跳转到安装页面，你发现右上角的<code>安装</code>不见了，取而代之的是<code>配置</code>，就是它了，去配置页面修改吧；</p>
</li>
<li><p>至于这里，是配置 utterances 创建新的 Issues 时，给 Issues 起的名儿：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giullxjlwfj30jo0i2q65.jpg" alt="配置"></p>
<p>请自由发挥，因为使用了<a href="https://github.com/rozbo/hexo-abbrlink">abbrlink</a>，链接并不显示文章名称，所以我就选图中所示的选项了，自由发挥的同学，玩的开心；</p>
</li>
<li><p>这里是选填选项，给 utterances 创建的 Issues 设置标签：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giulsj64dxj30jt072dgf.jpg" alt="设置标签"></p>
</li>
<li><p><code>Theme</code>就不用说了吧，主题选自己喜欢的，没喜欢的？给官方提交一个新主题；</p>
</li>
<li><p>接下来就是重头戏了，上面所有的选项都是为它服务的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giulyonf3xj30jz09lq41.jpg" alt="script"></p>
<p>复制 script 并添加到你想要评论出现的地方，bingo！</p>
</li>
</ul>
<h4 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h4><p>因为要用<code>注入</code>来实现评论功能，那就不能修改官方的模板，自己撸了个 js 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* utterances 评论插件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  query2add();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pjax 使用 pushState() 不会触发 hashchange 事件，需要拦截</span></span><br><span class="line"><span class="keyword">var</span> _wr = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> orig = history[type];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="keyword">new</span> Event(type);</span><br><span class="line">    e.arguments = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">window</span>.dispatchEvent(e);</span><br><span class="line">    <span class="comment">// 注意事件监听在url变更方法调用之前 也就是在事件监听的回调函数中获取的页面链接为跳转前的链接</span></span><br><span class="line">    <span class="keyword">var</span> rv = orig.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState = _wr(<span class="string">&quot;pushState&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 change 事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;pushState&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e &amp;&amp; e.arguments.length &gt; 2 &amp;&amp; e.arguments[2]</span></span><br><span class="line">  query2add();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 utterance 插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadUtterance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> js = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  <span class="comment">/* 以下内容改成第三步生成的配置 */</span></span><br><span class="line">  js.setAttribute(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;https://utteranc.es/client.js&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;repo&quot;</span>, <span class="string">&quot;Undeio/undeio.github.io&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;issue-term&quot;</span>, <span class="string">&quot;title&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;theme&quot;</span>, <span class="string">&quot;github-light&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;crossorigin&quot;</span>, <span class="string">&quot;anonymous&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;async&quot;</span>, <span class="string">&quot;async&quot;</span>);</span><br><span class="line">  <span class="comment">/* 以上内容需要修改 */</span></span><br><span class="line">  <span class="comment">// 添加到主体部分的末尾</span></span><br><span class="line">  <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;main-inner&quot;</span>)[<span class="number">0</span>].appendChild(js);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已存在组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query2add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有正文页面才有 post-copyright，也就是最后的版权声明</span></span><br><span class="line">  <span class="comment">// 当然，你也可以找一个自己正文才有的标识进行判断</span></span><br><span class="line">  <span class="keyword">let</span> postCopyRight = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;post-copyright&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (postCopyRight &amp;&amp; postCopyRight[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="comment">// 存在评论就放弃添加</span></span><br><span class="line">    <span class="keyword">let</span> utterances = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;utterances&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (utterances &amp;&amp; utterances[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loadUtterance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无图无真相</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giumvnbuw0j30gu0hm0vd.jpg" alt="真相"></p>
<p>最终效果</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giun047pynj30w10admy8.jpg" alt="效果"></p>
<blockquote>
<p>才疏学浅，实现比较粗糙，如果你有更好的实现，请给我留言。</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Utterance</tag>
      </tags>
  </entry>
  <entry>
    <title>Anti-Attach 与修正镜像大小</title>
    <url>/posts/2914862446/</url>
    <content><![CDATA[<blockquote>
<p>在不方便使用调试器启动程序的时候，可以先运行目标程序，再使用调试器附加到目标进程；</p>
<p>Ring3 调试器附加使用 DebugActiveProcess 函数，在附加相关进程时，会先执行 ntdll.dll 下的 ZwContinue 函数，最后停留在 ntdll.dll 的 DgbBreakPoint 处；</p>
<p>事实上，调试器会在此处设置一个 INT3 断点，然后由调试器自己来捕获；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-9">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>OEP 检索工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-12">PEiD</a>，来自互联网；</li>
<li>进程管理工具为<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-11">Estricnina</a>，来自互联网；</li>
<li>反 Anti-Attach 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-13">POKEMON_AntiAttach</a>；</li>
<li>Dump 工具为 OD 插件 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-1">OllyDump</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>PE 重建工具为<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-2">LoadPE</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>运行 CM 后虚拟机变得非常卡，打开任务管理器会发现当前 CM 的 CPU 占用率为 99%；</p>
</li>
<li><p>打开 OD，在文件菜单选择附加 CM 后，会提示无法附加：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gohdorzjcrj31dr0u0wkd.jpg" alt="在文件菜单选择附加"></p>
<p>不过这个 CM 的 Anti-Attach 好像不够完善，在弹出所有异常弹窗后，还是会附加成功；</p>
</li>
<li><p>同时查看堆栈窗口，可以看到调用来自 DgbBreakPoint：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gohdy8e3lxj31do0u077b.jpg" alt="DgbBreakPoint"></p>
<p>并且函数的首行指令被替换为 INT3；</p>
</li>
<li><p>F7 单步执行，程序返回到调用的下一行：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goi013tc3fj31220k20ua.jpg" alt="程序返回到调用的下一行"></p>
<p>这里是 DbgUiRemoteBreakin 函数内部，为了使运行中进程能够即时中断到调试器中，操作系统提供了函数 DbgUiRemoteBreakin，其内部通过调用 DbgBreakPoint 产生一个中断异常从而被调试器捕获；</p>
<p>为了实现及时中断，需要在运行中的进程中创建远程线程，线程回调函数就是 DbgUiRemoteBreakin 函数，最后的 RtlExitUserThread 就是结束远程线程；</p>
</li>
<li><p>使用 LoadPE 的 PE 编辑器打开程序，收集程序的重要信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goi1aat81ej30te0diwez.jpg" alt="LoadPE"></p>
<p>基址是：00400000，镜像大小是：6000，代码段 RVA：10000，数据段 RVA 是：2000，不过 NumberOfRvaAndSize 肯定是不对的，应该是 10（10 进制的 16）；</p>
</li>
<li><p>接着使用 PEiD 自带的插件 GenOEP 获取程序的 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goi1n3cj1fj307205odfs.jpg" alt="GenOEP"></p>
<p>OEP 为 401000，处于 LoadPE 获取的代码段区间，应该是正确的；</p>
</li>
<li><p>信息收集完成，运行 CM，然后使用 Estricnina 挂起 CM 的所有线程：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1gokei0mukhj20rk0dcdgc.jpg" alt="Estricnina"></p>
<p>暂停 CM 的线程只是为了让 CPU 占用率降低，使虚拟机用起来不是那么的卡；</p>
</li>
<li><p>接着，使用 POKEMON_AntiAttach 绕过程序的反附加：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomvgefpl5j30re0y075v.jpg" alt="POKEMON_AntiAttach"></p>
</li>
<li><p>使用 LoadPE 定位到 CM 的进程，修正进程的映像尺寸：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomvlz209ij30xe0u0juo.jpg" alt="修正进程的镜像尺寸"></p>
<p>PE 的 IMAGE_OPTIONAL_HEADER 结构体中有个字段叫 SizeOfImage，作用是指出 PE 文件在载入内存后的总尺寸，还有个字段叫 ImageBase，表示 PE 文件在内存中的首选载入地址；</p>
<p>在 Dump 文件时，一些关键参数是通过 MODULEENTRY32 结构的快照获取的，因此可以通过在 modBaseSize 和 modBaseAddr 字段中填入错误的值，让 Dump 软件无法正确读取进程中的数据，但由于修改 modBaseAddr 会使系统出现问题，因此只能修改 modBaseSize 的值；</p>
<p>某些壳在做 Anti-Dump 的时候，会对内存中的 SizeOfImage 大小进行修改，通常是改得很小，这样，Dump 工具读取当前值后获取的就会是一个映像尺寸不对的无用文件；</p>
<p>所以，所谓的修复镜像大小，就是读取磁盘文件的 SizeOfImage 与内存中的 SizeOfImage 进行大小比对，然后利用文件中的值进行修正；</p>
</li>
<li><p>接着，使用 OD 附加当前进程，程序中断在 ntdll.DbgBreakPoint 函数中，然后 goto 到 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomwnj75c1j31dr0u0q6y.jpg" alt="OEP"></p>
<p>可以看到，由于当前程序处于运行状态，所以代码段已经解码了；</p>
<p>设置 EIP 为 OEP，即让 CPU 即将执行的指令指向 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomwrwqqzkj31dm0u0q7v.jpg" alt="设置 EIP 为 OEP"></p>
<p>然后跟随任意调用，获取 IAT 相关信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomwv8fhqhj31dm0u0jul.jpg" alt="获取IAT相关信息"></p>
<p>IAT 起始 RVA 为：2000，Size 为：1C；</p>
</li>
<li><p>使用 OllyDump 将内存数据 Dump 下来：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomwyygosgj30p80jwt9e.jpg" alt="OllyDump"></p>
</li>
<li><p>使用 ImportREC 获取并重建 IAT：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomx1e69tej30wk0oodgu.jpg" alt="ImportREC"></p>
</li>
<li><p>直接运行修复后的程序，弹出错误弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomxckkw6ij31ji0u0tb8.jpg" alt="直接运行修复后的程序"></p>
</li>
<li><p>将修复后的程序拖入 LoadPE，重建 PE：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomx7wlxblj30tg0qawft.jpg" alt="重建 PE"></p>
</li>
<li><p>导入 OD 并运行程序，完美运行：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gomxef1j81j31dl0u0tci.jpg" alt="完美运行"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>PE</tag>
        <tag>ReCrypt</tag>
        <tag>Anti-Dump</tag>
        <tag>Anti-Attach</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDbg 即时调试功能的强大用途</title>
    <url>/posts/1803464375/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-9">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-3">PETools</a>，来自互联网；</li>
<li>IAT 重建工具为<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>PE 编辑工具为<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-2">LoadPE</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>最开始使用的是原版 OD，后续发现定位 OEP 比较麻烦，遂替换为修改版 OD，使用<code>内存执行断点</code>即可轻松到达 OEP；</p>
</li>
<li><p>运行 CM 后会发现虚拟机变得非常卡，打开任务管理器会发现当前 CM 的 CPU 占用率为 99%；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goerw4it5jj30ma0ngq3w.jpg" alt="任务管理器"></p>
</li>
<li><p>使用 OD 打开 CM，会弹出错误弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goes0ese2cj312y06mjrk.jpg" alt="错误弹窗1"></p>
<p>提示不是一个有效的 32 位可执行程序，这个肯定是 PE 头有问题，点击确定后，EP 停留在系统 DLL 区段；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goes48dp08j31el0u041v.jpg" alt="内存窗口"></p>
<p>打开内存映射窗口，发现程序只有一个区段；</p>
<p>F9 运行后，又弹出错误弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goesbm67kdj31el0u0mzh.jpg" alt="又弹出错误弹窗"></p>
<p>提示不知道如何继续，因为某个地址不可读，同时查看内存窗口，发现没有提示的区段；</p>
</li>
<li><p>打开 LoadPE，在设置中勾选<code>外壳扩展选项</code>保存并退出：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goeshkziu0j30ss0iqgm5.jpg" alt="外壳扩展选项"></p>
<p>这样就将 LoadPE 添加到了系统的右键菜单；</p>
</li>
<li><p>在 CM 上右键选择在 LoadPE 的 PE 编辑器中打开：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goesokbd7vj30ti0r8gmx.jpg" alt="在 LoadPE 的 PE 编辑器"></p>
<p>大部分数据看起来都很正常，唯一异常的是<code>NumberOfRvaAndSize</code>也就是数据目录表（DataDirectory）的项数，好像这个数值自 Windows NT 发布以来一直是 16（也就是 16 进制的 10）；</p>
<p>修改 NumberOfRvaAndSize 的值为 10，然后保存；</p>
</li>
<li><p>运行修改的程序，发现打不开了，难道是改坏了？导入 OD 看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goevb0cwnaj31bg06w0sz.jpg" alt="入口点超出代码段范围"></p>
<p>首先是弹窗提示入口点超出代码段范围，这是加壳程序载入 OD 后的正常反应；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goevepukfvj31a90u0n1h.jpg" alt="EP"></p>
<p>点击确定后，程序暂停在 00405000 处，查看内存映射窗口，发现修改之前的 1 个区段变成了 5 个区段（不含 PE 头）；</p>
<p>通过区段描述判断，当前处于壳所在的区段，暂停在程序的入口点（EP），看来修改 NumberOfRvaAndSize 的值是为了反调试；</p>
<p>F9 运行程序，又是访问不存在区段的弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goevo4ziyej31ab0u0mzt.jpg" alt="依然弹出错误弹窗"></p>
<p>既然程序都不能正常运行，常规定位 OEP 的方法肯定是不行的；</p>
<p>有没有可能是把程序改坏了，恢复 NumberOfRvaAndSize 的值试试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goewytg9d3j31d00esmyx.jpg" alt="恢复 NumberOfRvaAndSize"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goex0uf6iyj31ec0u0whk.jpg" alt="还是不能运行"></p>
<p>还是不能运行，看来还是有某些反调试没有绕过；</p>
</li>
<li><p>打开 OD，设置即时调试功能：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goexd4h2bkj31ek0u0ju1.jpg" alt="设置即时调试功能"></p>
<p>恢复按钮可用时表示即时调试功能设置成功，然后退出 OD；</p>
</li>
<li><p>尝试使用 LoadPE 设置 INT3 断点的功能直接到达 EP，看程序是否能运行：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goexhlq7aij311o0jy3z9.jpg" alt="设置 INT3 断点"></p>
<p>点击确定后，OD 自动附加到了 CM 上，可以看到入口的 PUSHAD 被替换为 INT3：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goexjkpk6aj30y80hut9g.jpg" alt="PUSHAD 被替换为 INT3"></p>
<p>手动修改 INT3 为 PUSHAD，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goexl42a8kj31600jwt9p.jpg" alt="还是这个错误"></p>
<p>还是这个错误，只能另寻它法了；</p>
</li>
<li><p>在前面已经知道，程序正常运行后会有 5 个区段，通常情况下，外壳会依次解压各区段，然后调用代码段的代码，最后程序正常运行：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goey7dx0mnj30te0dkt93.jpg" alt="使用 LoadPE 查看区段"></p>
<p>使用 LoadPE 查看程序的区段，.text 是第 1 区段，也就是说，正常情况下，外壳会首先解压该区段，至于后面的区段是运行时解压还是全部解压后运行，.text 段都已经解压完成了；</p>
<p>此时如果让后面的某个区段产生异常并中断程序，然后给代码段设置访问断点，是不是就可以到达 OEP 了；</p>
<p>以相邻的 .rdata 段为例，当外壳解压 .rdata 区段的数据时，肯定是要将解压的数据写入该区段，此时如果 .rdata 区段没有写入权限，程序肯定会产生异常并中断，这时， .text 段可能已经解压完成了，如果给代码段设置内存访问断点（并恢复 .rdata 段的写入权限）然后运行程序，是不是就可以到达 OEP 了；</p>
<p>当然，不能保证 .rdata 段就一定是在 .text 段之后解压，如果 .rdata 不行，还有其它 3 个区段可以尝试；</p>
<p>不过，作为只读数据段，像 IAT 之类的只读数值应该只会写入此区段；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goeyt9yhutj31ei0kujtg.jpg" alt="修改权限"></p>
<p>取消 .rdata 段的写入权限，并保存（有 save 点 save，没 save 点 ok）；</p>
</li>
<li><p>修改完成后，运行修改权限后的程序，OD 自动附加到了程序上，说明程序产生异常并崩溃了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goez5gyvjyj31ej0u0770.jpg" alt="程序产生异常并崩溃"></p>
<p>通过查看 EAX 和提示信息可以得知，是这条指令尝试将 MessageBoxA 的地址写入 .rdata 区段时，由于（.rdata）没有写入权限而产生了异常；</p>
<p>接下来，手动恢复 .rdata 区段的权限，当前只有 1 个区段，说明解压写入都是在这个区段中进行的，所以需要给这个区段赋予所有权限；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goezckg4gcj312w0eodgo.jpg" alt="恢复权限"></p>
<p>然后 F7 单步执行指令，可以看到数据被成功写入 .rdata 对应的地址中：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gof029tq8sj31ej0u0djq.jpg" alt="数据被成功写入"></p>
</li>
<li><p>接下来就要验证代码段是否解压完成了，goto 到 00401000：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goezqhgfdzj316w0he0tn.jpg" alt="goto 到 00401000"></p>
<p>可以看到代码段已经解压了，但还有一个问题：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goezrkhl1nj30rm03mgll.jpg" alt="还有一个问题"></p>
<p>按照预想，代码段解压后给代码段设置内存访问断点就可以到达 OEP 了，但现实是当前只有 1 个区段；</p>
</li>
<li><p>既然代码段已经解压，那就可以在数据窗口 goto 到代码段占用的内存空间，给代码段占用的内存单元设置内存访问断点，和直接给代码段设置内存访问断点是一样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goezz61recj31el0u041q.jpg" alt="给代码段占用的内存单元设置内存访问断点"></p>
<p>无法保证所有程序都会顺序访问代码段的地址，所以给代码段占用的所有单元设置访问断点会更有保障；</p>
<p>断点设置好后，运行程序，成功到达 OEP；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gof05eomx7j30xs0aaq3b.jpg" alt="成功到达 OEP"></p>
</li>
<li><p>使用 PETools 将程序数据 Dump 下来；</p>
</li>
<li><p>跟随任意调用，定位 IAT：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gof0awpdnuj315w0hyq4e.jpg" alt="跟随任意调用"></p>
<p>此处为间接调用；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gof0nueem3j31050u0dhg.jpg" alt="定位 IAT"></p>
<p>IAT 没有被重定向；</p>
</li>
<li><p>使用 ImportREC 获取输入表并修复 Dumped 的程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gof0sd63h9j30wm0oq0tq.jpg" alt="ImportREC"></p>
</li>
<li><p>修复后的程序可以运行，但导入 OD 后会提示不是有效的 32 位可执行文件，需要修改 NumberOfRvaAndSize 的值为 10；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gof1ana5d0j31eo0u00w1.jpg" alt="修改 NumberOfRvaAndSize"></p>
<p>修改后再次导入 OD，完美！</p>
</li>
<li><p>最后，用完即时调试功能后，需要手动关闭，不然任何程序崩溃后都会被 OD 附加；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gof1hhtllpj31er0u0dk5.jpg" alt="用完即时调试功能后"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>PE</tag>
        <tag>ReCrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDbg 反调试之 IsDebuggerPresent</title>
    <url>/posts/1969921723/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-10">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7morb9trj3087083mx8.jpg" alt="打开"></p>
<ul>
<li>ID 不可输入，应该是根据电脑硬件的某些特征生成的；</li>
<li>输入随机注册码点击 Check 之后，没有任何反馈；</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>既然程序有输入，有按钮，那可用的 API 可就多了。按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，用的<code>API</code>不多，一眼就看到了<code>GetWindowTextA</code>，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，嘿嘿，程序窗口一闪而过，而且<code>OD</code>的右下角也显示了程序的状态：<code>已终止</code>，;</p>
</li>
<li><p>如果说程序损坏的话，那么刚开始的时候应该也是打不开的；</p>
</li>
<li><p>如果说<code>OD</code>出现了问题，那么程序应该倒入不进来，而且查看不了 API 列表；</p>
</li>
<li><p>到底是什么问题呢？不绕弯子，程序有反调试，至于是如何反调试的？它就是今天的主角儿<code>IsDebuggerPresent</code>:</p>
<ul>
<li><p>先了解一下这个 API：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IsDebuggerPresent</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">     确定调用进程是否由用户模式的调试器调试。</span><br><span class="line"> 返回值</span><br><span class="line">     如果当前进程运行在调试器的上下文，返回值为非零值。</span><br><span class="line">     如果当前进程没有运行在调试器的上下文，返回值为零。</span><br></pre></td></tr></table></figure>

<p>看着好绕，大白话：检测当前程序是否正在被调试，没有被调试返回 0，只要返回值不是 0，那就表示程序正在被调试；</p>
</li>
</ul>
</li>
<li><p>既然知道它是一个 Windows API，那我们不妨按下<code>Ctrl + N</code>去函数列表看看这个程序是否调用了<code>IsDebuggerPresent</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7nnd0jurj316d0n974i.jpg" alt="API"></p>
<p>果然，在函数列表中发现了<code>IsDebuggerPresent</code>，不过，怎么证明它被调用了，而不是放在函数列表中迷惑我们呢？</p>
</li>
<li><p>很简单，给它设置一个断点，然后运行程序，没有意外，程序中断了，那就说明程序调用了这个 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7o1rwvmpj316b0n8dgl.jpg" alt="中断"></p>
<p>我们都知道<code>API 断点</code>会中断在函数的行首，也就是说，<code>IsDebuggerPresent</code>这个函数并没有执行，如果<code>Ctrl + F9</code>执行到返回，这个函数才算执行完毕了，而一旦它执行完毕，就意味着程序是否被调试它已经检测完成了，但从代码上看，只有区区 4 行，它是如何检测的呢，分析一下；</p>
</li>
<li><p>分析一下这 4 行代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOVZX</span> <span class="built_in">EAX</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">2</span>]   <span class="comment">; 将 EAX 中的地址，存储的第 2 个字节的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>

<p>嘛意思？往下分析；</p>
<ul>
<li><p><code>FS:[18]</code>中的<code>FS 寄存器</code>的地址是什么呢？</p>
<p><code>SF 标志位</code>指向<code>FS 寄存器</code>的地址；</p>
</li>
<li><p>开始分析代码，先是第 1 行代码<code>MOV EAX,DWORD PTR FS:[18]</code>：将<code>FS:[18]</code>中的地址拷贝到 <code>EAX</code>；</p>
<blockquote>
<p><code>FS 寄存器</code>从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 位存放的是起始位置的地址；</p>
</blockquote>
<p>对这句话很困惑？那我们按下<code>Ctrl + G</code>跟随一下这个地址，在这里，我的机器上，<code>FS</code>的地址是<code>7FFDF000</code>，那<code>FS:[18]</code>的地址就显而易见了，是<code>7FFDF018</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7pi19cnvj316d0nz0ua.jpg" alt="FS"></p>
<p><code>FS:[18]</code>的地址是<code>7FFDF018</code>，按下<code>F7</code>，单步执行代码，同时查看<code>EAX 寄存器</code>，丝毫不差，<code>FS:[18]</code>存放的正是<code>FS 寄存器</code>的起始地址<code>7FFDF000</code>，既然第 1 行代码搞定，那就开始分析第二行；</p>
</li>
<li><p>第 2 行代码<code>MOV EAX,DWORD PTR DS:[EAX+30]</code>：将 EAX 中的地址加 0x30 之后的地址拷贝到<code>EAX</code>；</p>
<p>与上一步相同，按下<code>Ctrl + G</code>跟随<code>7FFDF030</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7puc1wkhj316e0o0ta1.jpg" alt="加30"></p>
<p>没有意外，运行结果与我们分析的一致：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7pzqqa7hj316f0o0t9r.jpg" alt="运行后"></p>
</li>
<li><p>第 3 行代码<code>MOVZX EAX,BYTE PTR DS:[EAX+2]</code>：将 EAX 中的地址，存储的第 2 个字节的数据拷贝到 EAX；</p>
<p>跟随一下这个地址，看看它存储的是什么内容：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7q63xhhtj316c0ncwfo.jpg" alt="数据"></p>
<p>它存储的数据很简单，第二个字节是<code>01</code>，而根据<code>没有被调试返回 0，只要返回值不是 0，那就表示程序正在被调试</code>这句话来看，很明显，它检测到我们正在调试程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7q9nu35cj316b0nzgmb.jpg" alt="返回"></p>
<p>至此，恍然大明白，原来这 4 行代码就可以检测程序有没有被调试，至于为什么这里存放的是<code>01</code>这个数据，不得而知；</p>
</li>
<li><p>顺带提一嘴，如果程序倒入<code>OD</code>没有运行，那么<code>EBX 寄存器</code>指向的地址就是以上三行代码执行后需要取出数据的地址，也就是存放 01 的地址；</p>
</li>
</ul>
</li>
<li><p>既然已经明白了它是如何检测的以及知道了它的返回值，那如何绕过呢？</p>
<p>当然是修改返回值，也就是<code>EAX 寄存器</code>的值喽，没有调试返回 0，那返回 0 就是没有调试；</p>
</li>
<li><p>原理也明白了，也能绕过了，那么，它检测到程序被调试后，是如何退出程序的呢？意犹未尽；</p>
<p>不修改返回值，跟随一下<code>RETN</code>，看看它接下来会做什么？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7qkxbg5mj31690nbq3n.jpg" alt="退出消息"></p>
<p>哦豁，它用<code>PostQuitMessage</code>提交了退出消息，接着跟；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7qpagltqj316a0ncwf9.jpg" alt="退出进程"></p>
<p>然后，调用退出进程函数<code>ExitProcess</code>，再运行一下下，结束！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDbg 反调试之 ProcessHeap &amp; NTGlobalFlag</title>
    <url>/posts/3503361299/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-2">HideDebugger</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-14">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>使用搜索引擎搜寻良久并未找到通俗易懂的说明，在<a href="https://ctf-wiki.github.io/ctf-wiki/">CTF Wiki</a>上发现了描述，但无奈自己功力尚浅，无法透彻理解，遂将链接奉上，感兴趣的同学可以去学习一下<a href="https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntglobalflag-zh/">NtGlobalFlag</a>，<a href="https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/heap-flags-zh/">Heap Flags</a>；</p>
</li>
<li><p>文中使用的<code>CrackMe</code>无特定要求，可以使用任意一款；</p>
</li>
<li><p>了解一下两个标志，以下描述引用自<a href="https://ctf-wiki.github.io/ctf-wiki/">CTF Wiki</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NtGlobalFlag</span><br><span class="line"></span><br><span class="line">描述</span><br><span class="line">    1. 在 32 位机器上, NtGlobalFlag字段位于PEB(进程环境块)0x68的偏移处, 64 位机器则是在偏移0xBC位置.</span><br><span class="line">    2. 该字段的默认值为 0.</span><br><span class="line">    3. 当调试器正在运行时, 该字段会被设置为一个特定的值.</span><br><span class="line">    4. 尽管该值并不能十分可信地表明某个调试器真的有在运行, 但该字段常出于该目的而被使用</span><br></pre></td></tr></table></figure>

<p>呃，至于<code>ProcessHeap</code>，实在是总结不出具体的描述性语言，感兴趣的同学去<a href="https://ctf-wiki.github.io/ctf-wiki/">CTF Wiki</a>看吧；</p>
</li>
<li><p>接下来就用实例来说明一下这两个标志的用法：</p>
<ul>
<li><p>首先选择一个<code>CrackMe</code>倒入<code>OD</code>：</p>
<p>之前学习<code>IsDebuggerPresent</code>的时候学习到：如果程序倒入<code>OD</code>之后没有运行，那么<code>EBX</code>寄存器指向的位置就是<code>IsDebuggerPresent</code>检测的位置，用代码表示就是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOVZX</span> <span class="built_in">EAX</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">2</span>]   <span class="comment">; 将 EAX 中的地址，存储的第 2 个字节的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>

<p>在这里简单计算一下，就当作复习之前的知识了，以这个<code>CrackMe</code>为例：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkafiohmmj31ff0u0gxv.jpg" alt="为例子"></p>
<p>手动计算一下<code>IsDebuggerPresent</code>要检测的位置：</p>
<ol>
<li><p><code>MOV EAX,DWORD PTR FS:[18]</code>：<code>FS 寄存器</code>从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 位存放的是起始位置的地址，也就是说，在这里，<code>FS:[18] == 7FFDF000</code>；</p>
</li>
<li><p><code>MOV EAX,DWORD PTR DS:[EAX+30]</code>：这个很好计算嘛，<code>[EAX+30] == 7FFDF030</code>，使用<code>Ctrl + G</code>跟随一下这个地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkarqpe18j31ff0u0n8e.jpg" alt="计算并跟随"></p>
<p><code>7FFDF030</code>中存储的地址不正是<code>EBX</code>中的地址嘛；</p>
</li>
</ol>
</li>
<li><p>回顾完之前的内容，开始学习本次内容的第一个标志<code>NtGlobalFlag</code>：</p>
<p>根据对<code>NtGlobalFlag</code>描述可知：在 32 位机器上, NtGlobalFlag 字段位于 PEB(进程环境块)0x68 的偏移处；</p>
<p>首先，什么是 PEB?查询了许久之后又引出了 TEB，不太理解，但找到一些感觉描述很通俗的话：</p>
<ul>
<li><p>TEB：即 Thread Environment Block ，它记录相关线程的信息，每一个线程都有自己的 TEB，每个 TEB 都有自己的 TIB（Thread Information Block）,即线程信息块，每当创建一个线程，系统均会为每个线程分配 TEB，而且 TEB 永远放在 FS 寄存器指定的数据段的 0 偏移处；</p>
</li>
<li><p>PEB：即（Process Envirorment Block Structure），英文翻译过来就是进程环境信息块，在你进行打开这个程序或以调试方式打开这个程序，那么操作系统会对你这个进程的进程环境块的一些标志设置一系列的属性，如果你使用系统的调试方法，那么系统就会把相对应的标志位给设置上；</p>
<ol>
<li><p>TEB 结构体位于 FS 段选择符所指的段内存的起始地址处，也就是 0 偏移处；</p>
</li>
<li><p>PEB 成员位于距 TEB 结构体 Offset 30 的位置，也就是 0x30 偏移处；</p>
</li>
<li><p>那么就有两种获取 PEB 的方法：</p>
<ul>
<li>既然 TEB 位于 <code>FS 寄存器</code> 0 偏移处，在本文中就是<code>7FFDF000</code>，而 PEB 位于距 TEB 结构体 0x30 偏移处，那么是不是可以直接理解为：PEB 位于<code>FS 寄存器</code> 0x30 偏移处，即<code>FS:[30]</code>就是 PEB，在本文中就是<code>7FFDF030</code>；</li>
<li>TEB 位于 <code>FS 寄存器</code> 0 偏移处，在本文中就是<code>7FFDF000</code>，如何获取<code>FS 寄存器</code> 0 偏移处即文中的<code>7FFDF000</code>呢？当然是<code>FS:[18]</code>了，既然拿到 TEB 本身，如何获取 PEB 呢？方法就和上面复习的一样了；</li>
</ul>
</li>
</ol>
</li>
<li><p>既然找到了 PEB 的位置，而根据对<code>NtGlobalFlag</code>的定义得知，它位于 PEB 0x68 偏移处；</p>
<p>本文中 PEB 为<code>7FFDF030</code>地址中的数据<code>7FFD8000</code>，也就是初始<code>EBX</code>指向的地址，再偏移 0x68 计算为<code>7FFD8068</code>，也就是说，如果<code>7FFD8068</code>地址的数据不为 0，则表示检测到正在调试程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkcwq4qc1j31ff0u0n7p.jpg" alt="NtGlobalFlag"></p>
<p>整理一下代码的实现：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">68</span>]   <span class="comment">; 将 EAX 中的地址加 0x68 之后的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">OR</span> <span class="built_in">EAX</span>,<span class="built_in">EAX</span>                      <span class="comment">; 是否为 0</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>

<p>验证一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkdsmdg1kj31ff0u0tjp.jpg" alt="验证NtGlobalFlag"></p>
</li>
</ul>
</li>
<li><p>再来说说第二个标志<code>ProcessHeap</code>：</p>
<p>对这个标志的了解少之又少，暂时没有查到直接关联的资料，只能大概总结一下：</p>
<ol>
<li><p>位于 PEB 偏移 0x18 处，本文中 PEB 是<code>7FFD8000</code>，偏移 0x18 之后是<code>7FFD8018</code>；</p>
</li>
<li><p>把偏移后的地址中的 DWORD 长度的数据作为地址，偏移 0x10，即对本文的<code>7FFD8018</code>中的数据<code>00140000</code>偏移 0x10；</p>
</li>
<li><p>如果这个位置的数据不为 0，即本文的<code>00140010</code>不为 0，则表示检测到正在调试程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkdjjn9lfj31ff0u0akf.jpg" alt="ProcessHeap"></p>
<p>整理一下代码的实现：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">18</span>]   <span class="comment">; 将 EAX 中的地址加 0x18 之后的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">10</span>]   <span class="comment">; 将 EAX 中的地址加 0x10 之后的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">OR</span> <span class="built_in">EAX</span>,<span class="built_in">EAX</span>                      <span class="comment">; 是否为 0</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>

<p>验证一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkdp9qncvj31ff0u0qdy.jpg" alt="验证ProcessHeap"></p>
</li>
</ol>
</li>
<li><p>两个标志分析完毕，接下来就要说说如何绕过了，不能每次都手动修改吧；</p>
<p>这里需要借助两个<code>OD</code>插件<code>HideDebugger</code>和<code>HideOD</code>；</p>
<p>设置如下图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gll7skb4c3j31ff0u048h.jpg" alt="插件设置"></p>
<p>细心的同学会发现，这里的设置和上节课一模一样，是的，设置相同，但是重点不同；</p>
<p>虽然之前设置了某些选项，但只是照猫画虎，不知其意，相信学完这节内容，就会理解这样设置的意图；</p>
</li>
<li><p>验证一下插件是否生效：</p>
<p>程序倒入<code>OD</code>不要运行，在<code>数据窗口</code>中跟随<code>EBX</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gll8umchjbj31ff0u07ez.jpg" alt="前两个绕过"></p>
<p>可以在<code>数据窗口</code>直观的看到，<code>IsDebuggerPresent</code>和<code>NtGlobalFlag</code>检测的位置已经成功置 0，绕过检测，至于<code>ProcessHeap</code>，<code>Ctrl + G</code>跟随地址查看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gll931b41xj31ff0u0qd9.jpg" alt="最后一个绕过"></p>
</li>
</ul>
</li>
<li><p>聊完两个标志，再来聊聊另外一个知识点：一个崩溃：</p>
<p>一个崩溃不是说 Windows 的 API 又有特殊的用途或参数，或者说是开发人员思路清奇把 API 用出了花儿，而是<code>OD</code>的 bug：当被调试的程序通过 OutputDebugString 输出超长的一串调试字符串的时候，OllyDbg 无法处理导致崩溃；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDbg 反调试之 ZwQueryInformationProcess</title>
    <url>/posts/3209676884/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-2">HideDebugger</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-13">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>查询微软官方文档，本次使用的 API<code>ZwQueryInformationProcess</code>未来可能会弃用，所以目前暂不做深入研究，有需要之时再做深入；</p>
</li>
<li><p>这次使用的反调试 API 很独特：它本身的设计初衷应该是用作异常处理，但却被<code>CrackMe</code>的作者用在了验证方面，不得不说，这位高人对 API 理解的很透彻，很独到，同时也提醒了我，反向思维很重要；</p>
</li>
<li><p>这里就说说本次使用的 API：<code>SetUnhandledExceptionFilter</code>、<code>UnhandledExceptionFilter</code>、<code>ZwQueryInformationProcess</code>；</p>
<ul>
<li><p>先来说说第二个 API <code>UnhandledExceptionFilter</code>：</p>
<p>这是官方文档的描述：</p>
<blockquote>
<p>An application-defined function that passes unhandled exceptions to the debugger, if the process is being debugged. Otherwise, it optionally displays an Application Error message box and causes the exception handler to be executed. This function can be called only from within the filter expression of an exception handler.</p>
</blockquote>
<p>对这段文档的理解：通过判断当前进程是否正在被调试，如果正在被调试，就把异常交给调试器，如果没有，就把异常交给进程的 UnhandledExceptionFilter 处理；</p>
<p>这里就不禁产生了一个疑问：如何判断当前进程是否正在被调试？</p>
</li>
<li><p>再来看第三个 API <code>ZwQueryInformationProcess</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZwQueryInformationProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索有关指定进程的信息</span><br><span class="line">参数</span><br><span class="line">    ProcessInformationClass：要检索的过程信息的类型</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在官方说明的开始有这么一段话：</p>
<blockquote>
<p><code>[ZwQueryInformationProcess may be altered or unavailable in future versions of Windows. Applications should use the alternate functions listed in this topic.]</code></p>
</blockquote>
<p>意思是：这个 API 可能会在未来的 Windows 版本中被更改或弃用，若要开发应用，请使用本文列出的其他替代 API。</p>
</li>
<li><p>这个 API 的第二参数<code>ProcessInformationClass</code>：<code>要检索的过程信息的类型</code>，本身有很多可选的值，而<code>ProcessDebugPort，值是 7</code>是我们关注的重点：</p>
<blockquote>
<p>Retrieves a DWORD_PTR value that is the port number of the debugger for the process. A nonzero value indicates that the process is being run under the control of a ring 3 debugger.</p>
</blockquote>
<p>意思是：检索四子节长度的值，该值是该进程的调试器的端口号。非零值表示该进程正在 Ring3 调试器的控制下运行。</p>
<p>也就是说，调用这个函数，在把第二参数设置为<code>7</code>的情况下，只要返回非零值就表示我们正在调试程序，很好很强大，同时也解释了在学习上一个 API 时留下的疑惑；</p>
</li>
</ul>
</li>
<li><p>最后来看看第一个 API <code>SetUnhandledExceptionFilter</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SetUnhandledExceptionFilter</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    设置异常捕获函数</span><br><span class="line">参数</span><br><span class="line">    lpTopLevelExceptionFilter：指向顶级异常处理函数的指针，只要 UnhandledExceptionFilter 函数获得控制权且未在调试过程，该指针就会被调用</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这是官方对 API 的说明；</p>
<blockquote>
<p>Enables an application to supersede the top-level exception handler of each thread of a process.</p>
<p>After calling this function, if an exception occurs in a process that is not being debugged, and the exception makes it to the unhandled exception filter, that filter will call the exception filter function specified by the lpTopLevelExceptionFilter parameter.</p>
</blockquote>
</li>
<li><p>这是官方对参数<code>lpTopLevelExceptionFilter</code>的说明，请自行理解；</p>
<blockquote>
<p>A pointer to a top-level exception filter function that will be called whenever the UnhandledExceptionFilter function gets control, and the process is not being debugged. A value of NULL for this parameter specifies default handling within UnhandledExceptionFilter.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>学习完这三个 API，说说自己的理解：</p>
<ol>
<li><p><code>SetUnhandledExceptionFilter</code>可以为异常设置处理函数，参数<code>lpTopLevelExceptionFilter</code>指向自定义的异常处理函数，但要触发这个函数，必须满足一个条件：<code>UnhandledExceptionFilter</code>被调用；</p>
</li>
<li><p>同时，要想<code>UnhandledExceptionFilter</code>被调用，也得满足两个条件：程序没有被调试，并且这个异常没有被处理；</p>
</li>
<li><p>当同时满足以上条件时，就会触发自定义的异常处理函数来处理异常；</p>
</li>
<li><p>那么，程序是如何检测程序是否被调试呢？那就要用到<code>ZwQueryInformationProcess</code>了，也就是说，本次的反调试主角其实是<code>ZwQueryInformationProcess</code>（虽然它就要被弃用了）；</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>下面开始进入正题：</p>
<ul>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzea2h39j30h807uaa4.jpg" alt="打开软件"></p>
<p>很常规的软件，随便输入内容并点击 Check 后，没有任何反馈；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<p>既然已经学习了需要的 API，那就不用去 API 窗口看了，直接给三个函数设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzq6vknpj31ff0u012b.jpg" alt="设置断点并做好备注"></p>
<p>其实地址栏已经显示了地址对应的 API 名称，不过无法保证任何时候都会显示，况且，做备注是一个好的习惯，不是吗？</p>
<p>同时需要先禁用<code>ZwQueryInformationProcess</code>断点，否则程序会多次中断，但不会中断在理想的位置，况且按照对 API 的理解，只有<code>UnhandledExceptionFilter</code>调用它的时候才会检测程序是否被调试，所以，在<code>UnhandledExceptionFilter</code>出现后再启用也为时不晚；</p>
</li>
<li><p>接着<code>F9</code>运行程序，程序会中断在<code>SetUnhandledExceptionFilter</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzxn8v3hj31ff0u0tkf.jpg" alt="SetUnhandledExceptionFilter"></p>
<p>根据 API 说明，它的参数指向自定义异常处理函数，那么就在它的参数地址上设置断点，看看程序是否会触发这个自定义函数；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk01ign7fj31ff0u0484.jpg" alt="参数设置断点"></p>
</li>
<li><p>继续运行程序，程序主窗体弹出，输入内容并点击 Check 后，程序再次中断，这次是中断在了<code>UnhandledExceptionFilter</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk05cb5zxj31ff0u0k39.jpg" alt="UnhandledExceptionFilter"></p>
<p>其实，细心的同学一眼就看到了它调用了另一个 API <code>ZwQueryInformationProcess</code>；</p>
<p>既然它都要调用<code>ZwQueryInformationProcess</code>了，那我们就需要去启用<code>ZwQueryInformationProcess</code>断点了；</p>
</li>
<li><p>激活<code>ZwQueryInformationProcess</code>断点并运行程序，程序会再次中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0bobp81j31ff0u04ag.jpg" alt="ZwQueryInformationProcess"></p>
<p>可以看到，<code>堆栈窗口</code>中，它的第二参数<code>InfoClass=7</code>，那就说明它本次执行的目的就是检测程序是否正在被调试，而它的第三参数<code>Buffer=0012F5E4</code>则存放的是返回值，<code>数据窗口</code>中跟随一下；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0htm7h8j31ff0u0wq1.jpg" alt="数据窗口"></p>
<p>事实上，我们确实正在调试这个这个程序，那我们就看看它的返回值是否是非零值；</p>
</li>
<li><p>既然要看它的返回值，那就不能直接运行程序了，<code>Ctrl + F9</code>执行到返回，同时查看<code>数据窗口</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0sudvwnj31ff0u0wpw.jpg" alt="执行到返回"></p>
<p>果然，返回值是一个非零值，也就说检测到正在调试程序；</p>
<p>既然检测到了正在调试程序，如何触发自定义的异常处理函数呢？当然是将返回值置 0；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0xlkckij31ff0u0k2k.jpg" alt="置0"></p>
<p>选中返回值用 00 填充，直接修改也是可以的；</p>
</li>
<li><p>既然已经修改了返回值，也就是绕过了检测，那么<code>ZwQueryInformationProcess</code>断点也就没用了，禁用<code>ZwQueryInformationProcess</code>断点并运行程序，程序会中断在：为<code>SetUnhandledExceptionFilter 的参数</code>设置的断点位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk14tbrvij31ff0u0n9e.jpg" alt="参数断点"></p>
</li>
<li><p>毫无悬念了，这里就是用来验证的关键代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2bmg6nqj31ff0u0wqc.jpg" alt="验证"></p>
<p>把我们输入的内容进行一系列操作之后，去和一个指定的内容做比较；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2h1fpwqj31ff0u0n8f.jpg" alt="比较"></p>
<p>到这里就可以理解为什么点击 Check 之后没有任何反馈了，是因为验证失败后没有任何操作；</p>
<p>既然已经知道会跳转到失败，如何看到成功的弹窗呢？当然是修改<code>ZF</code>标志位，让<code>JNZ</code>不成立：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2n9tg0jj31ff0u0k2k.jpg" alt="修改"></p>
<p>继续向下执行，期待已久的成功弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2rmsxwmj31ff0u0146.jpg" alt="成功"></p>
</li>
<li><p>既然已经知道了它的反调试原理，但又不想每次都手动修改，那该如何绕过能，这里需要借助插件：<code>HideDebugger</code>和<code>HideOD</code>，设置如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk39bp648j31ff0u0qeb.jpg" alt="插件"></p>
<p>无图无真相：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk3e9o4irj31ff0u07g4.jpg" alt="无图无真相"></p>
<p>插件的作用就是永远保持<code>ZwQueryInformationProcess</code>的参数为<code>7</code>时的返回值为 0；</p>
</li>
<li><p>总结：不得不说，能人背后有能人，这波操作很清奇，也就是说：如果从事物的多个角度去观察，去思考，可能会有不一样的理解与收获；</p>
<p>期待自己早日变得更加强大，加油 💪💪💪❗️</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDbg 反调试之检测进程名&amp;窗口类名&amp;窗口标题名</title>
    <url>/posts/140693809/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><code>OD</code>补丁程序<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-6">re-pair</a>；</li>
<li>类名检测工具<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-7">Greatis WinDowse</a>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-12">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>重点依然是学习 Windows API；</p>
</li>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk4zdntwnj306u05wjrb.jpg" alt="打开软件"></p>
<p>如果没有打开<code>OD</code>，程序可以打开并显示如上，如果打开了<code>OD</code>，程序则无法打开；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先，<code>Ctrl + N</code>查看一下 API 列表，很意外，出奇的干净，只有区区两个 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk4yoy6d9j31ff0u0dov.jpg" alt="API列表"></p>
<p>还好有一个我们认识的<code>ExitProcess</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExitProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    结束调用的进程及其所有的线程；</span><br></pre></td></tr></table></figure>

<p>那就只能从它下手了：设置 CC 断点并设置好备注；</p>
</li>
<li><p>接着，运行程序，程序会中断在我们设置的断点<code>ExitProcess</code>函数的行首，然后在<code>堆栈窗口</code>右键<code>反汇编窗口中跟随</code>来到调用这个函数的位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk4zzxwewj31ff0u0145.jpg" alt="反汇编窗口中跟随"></p>
<p>这里很困惑？困惑的同学没学懂，再复习一下 API 吧；</p>
<p>常规操作是：<code>Ctrl + F9</code>执行到返回，然后看它获取的数据，再进行下一步操作；</p>
<p>然鹅，别忘了<code>ExitProcess</code>的功能：结束进程及其所有的线程。</p>
<p>如果我们<code>Ctrl + F9</code>执行到返回，是不是意味着我们手动执行了结束进程的函数，那么，这个断点的意义是什么？</p>
<p>所以，我们要跟随函数到调用它的地方，往上看，为什么要调用它？</p>
</li>
<li><p>来到<code>反汇编窗口</code>，发现调用位置的同时，也发现了很多 API，其中大部分都不认识，但是有一根救命稻草<code>GetProcAddress</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk50duycnj31ff0u014a.jpg" alt="反汇编窗口"></p>
<p>既然 API 列表没有内容的同时发现了<code>GetProcAddress</code>，那是不是说明，大多数函数都被隐藏了，而<code>GetProcAddress</code>就是关键呢？</p>
<p>再来复习一下<code>GetProcAddress</code>的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetProcAddress</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定的动态链接库中的输出库函数地址；</span><br><span class="line">    （获取函数列表中不显示且被调用的隐藏函数的地址；）</span><br><span class="line">    （捕捉间接加载或调用的其他隐藏函数；）</span><br><span class="line">参数</span><br><span class="line">    hModule：包含此函数的 DLL 模块的句柄；</span><br><span class="line">    （程序的句柄）</span><br><span class="line">    IpProcName：包含函数名的以 NULL 结尾的字符串；</span><br><span class="line">    （程序的名字）</span><br></pre></td></tr></table></figure>

<p>毫无疑问，给<code>GetProcAddress</code>设置断点并做好备注，看看都有哪些隐藏的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk50u2kmtj31ff0u07fg.jpg" alt="GetProcAddress"></p>
</li>
<li><p>然后重载并运行程序后程序会中断，接着多次运行直到中断在了<code>ExitProcess</code>后，发现只是调用了以下隐藏函数：<code>CreateToolhelp32Snapshot</code> <code>OpenProcess</code> <code>Process32First</code> <code>Process32Next</code> <code>TerminateProcess</code> <code>lstrcmpA</code> <code>FindWindowA</code>；</p>
<ul>
<li><p>其中，<code>OpenProcess</code> <code>TerminateProcess</code> <code>lstrcmpA</code>很熟悉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知 PID 获取程序的句柄；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TerminateProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过进程句柄终止指定进程及其所有线程；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lstrcmpA</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    区分大小写的字符串比较；</span><br><span class="line"></span><br><span class="line">lstrcmpi</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    不区分大小写的字符串比较；</span><br></pre></td></tr></table></figure></li>
<li><p>至于其他几个，需要学习一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateToolhelp32Snapshot</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    给所有进程的详细信息拍摄快照，返回快照句柄供其他 API调用；</span><br><span class="line">参数</span><br><span class="line">    dwFlags：用来指定“快照”中需要返回的对象；</span><br><span class="line">    th32ProcessID：指定将要快照的进程ID；</span><br><span class="line">        - 该参数只有在dwFlags设置了TH32CS_SNAPHEAPLIST或者TH32CS_SNAPMODULE后才有效；</span><br><span class="line">        - 该参数为 0 则获取当前进程快照；</span><br><span class="line">        - 其他情况下参数会被忽略，所有的进程都会被快照；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process32First</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    获取进程快照第一个进程的句柄；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process32Next</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    获取进程快照下一个进程的句柄；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FindWindowA</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">    lpClassName：指向类名的字符串或一个可以确定类名字符串的原子；</span><br><span class="line">    lpWindowName：指向窗口名（即窗口标题）的字符串；</span><br><span class="line">作用</span><br><span class="line">    检索并处理顶级窗口的类名和窗口标题匹配指定的字符串；</span><br><span class="line">    不搜索子窗口；</span><br><span class="line">    不区分大小写；</span><br><span class="line">    如果有指定的类名或窗口标题则表示成功返回一个窗口的句柄；否则返回零；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>了解这些 API 后，重载并运行程序，程序中断后，分别给这些 API 设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk518c8dvj31ff0u012g.jpg" alt="设置断点并做好备注"></p>
</li>
<li><p>设置好所有断点后，再次运行程序，发现程序并不是和刚才一样中断在<code>ExitProcess</code>，而是中断在新设置的断点<code>CreateToolhelp32Snapshot</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk51l5855j31ff0u0alh.jpg" alt="CreateToolhelp32Snapshot"></p>
<ul>
<li><p>根据<code>CreateToolhelp32Snapshot</code>的用法，发现它的参数<code>Flags</code>并不是<code>TH32CS_SNAPHEAPLIST 或 TH32CS_SNAPMODULE</code>二者中的任何一个，那么它的参数将被忽略，所以，在这里它会获取所有进程的快照，并返回快照的句柄供其他 API 调用；</p>
</li>
<li><p>接着，<code>Ctrl + F9</code>执行到返回，在<code>EAX</code>中有一个返回值，那么它是不是一个句柄呢？去<code>句柄窗口</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk51xpoxlj31ff0u0gw9.jpg" alt="句柄窗口有"></p>
<p>可以看到，<code>句柄窗口</code>有一个相同的句柄，结果不言而喻；</p>
</li>
</ul>
</li>
<li><p>继续运行程序，程序再次中断，这次是中断在<code>Process32First</code>：</p>
<ul>
<li><p>可以看到，它要获取的第一个进程的句柄是<code>hSnapshot = 00000038</code>，而它的第二参数是一个指向进程详细信息的指针，<code>数据窗口</code>中跟随一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk52gpq0qj31ff0u07g3.jpg" alt="数据窗口中跟随"></p>
</li>
<li><p>接着<code>Ctrl + F9</code>执行到返回，可以看到，它获取到了信息并且信息一致：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk52sggjzj31ff0u0drl.jpg" alt="信息一致"></p>
</li>
</ul>
</li>
<li><p>接着运行程序，程序中断在<code>FindWindowA</code>，而它给定的参数是<code>Class = &quot;OllyDbg&quot;</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk5353sccj31ff0u0al6.jpg" alt="FindWindowA"></p>
<ul>
<li><p>根据<code>FindWindowA</code>的用法<code>如果有指定的类名或窗口标题则表示成功返回一个窗口的句柄；否则返回零；</code>，如果接下来<code>Ctrl + F9</code>执行到返回后，<code>EAX</code>是非零的值，是不是意味着找到了与<code>Class = &quot;OllyDbg&quot;</code>指定的类名匹配的窗口，并且拿到了它的句柄？</p>
</li>
<li><p>先来看看<code>OD</code>的类名与标题是什么，这里要借助一个软件<code>Greatis WinDowse</code>：</p>
<p><code>Greatis WinDowse</code>需要安装；<br><code>Greatis WinDowse</code>的用法是：将鼠标悬停在需要检测的窗口的标题栏即可；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk53ggz5tj31ff0u04ax.jpg" alt="类名与标题"></p>
<p>可以看到，检测到的标题与窗口标题完全一致，那类名不言而喻；</p>
</li>
<li><p>接下来<code>Ctrl + F9</code>执行到返回后，发现<code>EAX</code>里的确有一个非零的值，如何证明它就是<code>OD</code>的句柄呢，再次打开<code>Greatis WinDowse</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk53smw27j31ff0u0tk6.jpg" alt="OD的句柄"></p>
<p>检测到的句柄与<code>EAX</code>的值完全相同，那<code>OD</code>可就危险了；</p>
</li>
</ul>
</li>
<li><p>到了这里，如果继续运行程序，肯定会获得一个程序结束的大礼包，有继续运行程序冲动的同学需要加强学习了，既然拿到了<code>OD</code>的句柄，也就是生杀大权，那么，应该跟着它，看看它拿着句柄要干什么？So，<code>F8</code>单步执行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk549889lj31ff0u0dqa.jpg" alt="来到了这里"></p>
<p>程序来到了这里，先不要执行代码，观察一下，如果没有猜错，下面的<code>ExitProcess</code>就是刚运行程序设置的第一个断点调用的位置；</p>
<ul>
<li><p>再来查看一下代码，前三行，两个比较一个跳转，既然找到了与指定类名相同的窗口，那么句柄也就是<code>EAX</code>肯定不为 0，所以第三行的跳转一定会成立；</p>
</li>
<li><p>紧接着看看下面两个跳转，除了起始位置不同，都完美的跳过了<code>ExitProcess</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk54mk4r7j31qs0ms76z.jpg" alt="两个跳转"></p>
</li>
<li><p>当然，以上都只是推论，代码并没有执行，如何证实推论？当然是将句柄也就是<code>EAX</code>置 0：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk54yys42j31ff0u0gwj.jpg" alt="EAX置0"></p>
</li>
<li><p>然后继续<code>F8</code>单步执行程序，果不其然，程序跳过了<code>ExitProcess</code>，来到了<code>lstrcmpA</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk557lbrrj31ff0u0k2t.jpg" alt="字符串比较"></p>
<p>用获取到的第一个进程的标题名和给定字符串做比较；</p>
</li>
<li><p>继续向下执行，逻辑瞬间清晰：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk55qvbguj31ff0u04aj.jpg" alt="逻辑清晰"></p>
<p>至此，终于理清了它反调试的套路：</p>
<ol>
<li>首先使用<code>CreateToolhelp32Snapshot</code>获取进程快照；</li>
<li>接着使用<code>Process32First</code>获取进程快照第一个进程的句柄；</li>
<li>然后使用<code>FindWindowA</code>获取给定类名或标题的进程的句柄，如果获取成功，则使用句柄关闭这个程序的所有进程及线程；</li>
<li>如果使用<code>FindWindowA</code>获取失败，则通过<code>Process32First</code>获取的第一个进程的标题与给定字符串进行比较，相同则关闭这个程序；</li>
<li>如果第一个进程的信息比较不相同，则使用<code>Process32Next</code>获取进程快照的下一个进程，并用其标题与给定字符串比较，相同则关闭程序，不同则取下一个，直到进程快照中的所有进程比较完毕；</li>
</ol>
</li>
</ul>
</li>
<li><p>既然已经跳过了这个程序对<code>OD</code>的检测，是不是意味着现在可以看到最开始的弹窗呢？禁用所有断点并运行程序：<br><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk560iqxxj31ff0u0k0o.jpg" alt="弹窗"></p>
<p>完工！</p>
</li>
<li><p>不不不，没有完工，既然知道了这个程序的反调试原理，如何绕过呢，不能每次都手动吧？这里需要借助一个<code>OD</code>补丁程序<code>re-pair</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk56aya3ej31ff0u0n8v.jpg" alt="补丁程序"></p>
<p>补丁程序会生成了一个名称随机的<code>OD</code>主程序，试试效果如何：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk56lopeqj31ff0u04ap.jpg" alt="完工啦"></p>
<p>再多句嘴，插件<code>HideDebugger</code>虽然也有<code>FindWindow/EnumWindows</code>选项，但只能绕过标题名检测，无法绕过类名检测：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk56vnr87j31ff0u0wqt.jpg" alt="HideDebugger"></p>
<p>这次是真的完工了！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDbg 反调试之检测进程名</title>
    <url>/posts/1165783651/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-11">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>本次内容学习 Windows API 才是重点；</p>
</li>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhnceosakj30aq07ot8q.jpg" alt="打开软件"></p>
<p>既然是学习反调试，那么注册码当然不是重点，重点是它对<code>OD</code>的影响，打开<code>OD</code>，发现闪了一下然后被关闭了，嗯，反调试了；</p>
<p>还有一个现象就是：给<code>OD</code>改个名后，就不会被反调试了，即使是<code>OD</code>载入程序并运行，也不会被反调试；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先，<code>Ctrl + N</code>查看 API 列表，API 很多，搜索<code>GetProcAddress</code>设置 CC 断点；</p>
<ul>
<li><p>了解一下 Windows API <code>GetProcAddress</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetProcAddress</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定的动态链接库中的输出库函数地址；</span><br><span class="line">    （获取函数列表中不显示且被调用的隐藏函数的地址；）</span><br><span class="line">    （捕捉间接加载或调用的其他隐藏函数；）</span><br><span class="line">参数</span><br><span class="line">    hModule：包含此函数的 DLL 模块的句柄；</span><br><span class="line">    （程序的句柄）</span><br><span class="line">    IpProcName：包含函数名的以 NULL 结尾的字符串；</span><br><span class="line">    （程序的名字）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>接着，<code>F9</code>运行程序，程序会在设置断点的 API 上中断多次，每中断一次，都代表获取了一个隐藏的函数；</p>
</li>
<li><p>在大约中断了 143 次后，对接下来获取到的 3 个重要的 API 设置 CC 断点：<code>EnumProcesses</code>、<code>EnumProcessesModules</code>、<code>GetModuleBaseNameA</code>；</p>
<ul>
<li><p>国际惯例，分别了解一下这几个 API ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnumProcesses</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索进程列表中每一个进程的标识符；</span><br><span class="line">    （枚举进程的 PID；）</span><br><span class="line">    （获取进程列表所有进程的 PID；）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnumProcessesModules</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定进程中每个模块的句柄；</span><br><span class="line">    （获取进程的基址；）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetModuleBaseNameA</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定模块的基本名称；</span><br><span class="line">    （获取进程名；）</span><br></pre></td></tr></table></figure></li>
<li><p>设置断点的方法：</p>
<p>程序中断后，在<code>堆栈窗口</code>确认是需要的 API 后，在函数名称所在行右键菜单选择复制到剪贴板，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqpoeyaqj31ff0u013m.jpg" alt="复制"></p>
<p>接着<code>Ctrl + F9</code>执行到返回，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqqvhbvhj31ff0u0n80.jpg" alt="执行到返回"></p>
<p>然后<code>bp EAX</code>设置断点，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqrzoin0j31ff0u0qf2.jpg" alt="设置断点"></p>
<p>在断点窗口双击断点进入汇编窗口，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqrsjy18j31ff0u0n6k.jpg" alt="断点窗口"></p>
<p>在注释栏双击并粘贴复制的函数名，也就是给断点设置备注，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqtz1wgmj31ff0u0gxm.jpg" alt="注释"></p>
<p>断点设置完成；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqupj78mj31ff0u0gum.jpg" alt="注释完成"></p>
<p>至于为什么要设置备注，如果有 10 个没有设置备注的断点，那就傻傻分不清了；</p>
</li>
</ul>
</li>
<li><p>这里不得不提一下 PID，它的全称是<code>Process ID</code>，通俗易懂嘛，<code>进程 ID</code>；</p>
<ul>
<li><p>至于怎么查看 PID，打开任务管理器，选择<code>进程</code>列，就显示了当前所有程序的诸如程序名、PID、用户名等等信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrn2d1q8j30mc0vcq46.jpg" alt="任务管理器"></p>
<p>而我们使用的<code>OD</code>也赫然在列；</p>
</li>
<li><p>当然，如果你的进程列表中没有 PID 这一列，不要慌，你的电脑没问题，点击菜单栏中的<code>查看</code>按钮并选择<code>选择列</code>选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrqp0c07j30me0v8t9y.jpg" alt="选择列"></p>
</li>
<li><p>然后勾选<code>PID</code>复选框并确定，你的进程列表中就有 PID 这一列了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrsbmu0qj30mc0v6jst.jpg" alt="复选框"></p>
</li>
</ul>
</li>
<li><p>了解并知道如何查看 PID 之后，就要进入正题了：</p>
<p>以我的机器为例，<code>OD</code>的 PID 是<code>1380</code>，这是一个 10 进制数，要在<code>OD</code>里使用它，当然要转换为 16 进制：</p>
<p>进制转换的方法很多，比如使用网页提供的进制转换器，使用系统内置的计算器，使用<code>OD</code>自带的进制转换，这里以<code>OD</code>为例：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhs12msd7j30d408qjrf.jpg" alt="16进制"></p>
<p>随便双击一个寄存器，然后修改它的<code>无符号</code>值，<code>十六进制</code>栏就会显示对应的 16 进制数，这里<code>OD</code>的 PID 对应的 16 进制数就是<code>564</code>；当然，修改寄存器的值只是为了进制转换，一定不要点击确定哦；</p>
</li>
<li><p>设置好 3 个函数的断点后，继续运行程序，程序会再次中断，不过，不再是中断在<code>GetProcAddress</code>，而是中断在新设置的第一个断点，也就是<code>EnumProcesses</code>：</p>
<ul>
<li><p>我们已经了解了<code>EnumProcesses</code>的功能：获取进程列表所有进程的 PID；</p>
</li>
<li><p>既然<code>EnumProcesses</code>不需要参数，那么堆栈窗口<code>ESP + 4</code>的位置，存储的就是它的返回值，数据窗口中跟随一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhssuz2luj31ff0u0k33.jpg" alt="数据窗口"></p>
</li>
<li><p>接着<code>Ctrl + F9</code>执行到返回，发现以基址为起始位置的部分地址的内容被覆盖了，而<code>OD</code>的 PID 也在其中：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhsu51my1j31ff0u0n90.jpg" alt="od16"></p>
</li>
</ul>
</li>
<li><p>既然是要了解反调试对<code>OD</code>的影响，当然要跟随<code>OD</code>的数据了，在<code>OD</code>的 PID 上设置<code>内存访问断点</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhsx5pxacj31ff0u013l.jpg" alt="内存访问断点"></p>
</li>
<li><p>继续运行程序，程序再次中断，一眼就看到了<code>OD</code>的 PID 被当作参数传递给了函数<code>OpenProcess</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhtbacm5dj31ff0u0gx2.jpg" alt="参数"></p>
<ul>
<li><p><code>OpenProcess</code>这个函数的作用是什么呢，了解一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知 PID 获取程序的句柄；</span><br></pre></td></tr></table></figure></li>
<li><p><code>OD</code>危险了，因为这个<code>CrackMe</code>拿到了它的句柄，也就是它的生杀大权；</p>
</li>
<li><p><code>F8</code>单步步过执行程序，看看是否如是：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhthr6mxdj31ff0u0al0.jpg" alt="拿到句柄"></p>
<p>因为函数的返回值一般都在<code>EAX</code>，所以我们大胆猜测，<code>EAX</code>中应该就是<code>OD</code>的句柄，如何证明呢？去<code>句柄窗口</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhtm3151xj31ff0u0tjy.jpg" alt="句柄窗口"></p>
<p><code>句柄窗口</code>中有一个数值相同的句柄，而这个函数是用来获取句柄的，又把<code>OD</code>的 PID 当作了参数，那么它返回的应该就是<code>OD</code>的句柄，所以可以确定，<code>EAX</code>中就是<code>OD</code>的句柄也就是<code>000000C4</code>;</p>
</li>
</ul>
</li>
<li><p>继续运行程序，程序再次中断，来到了我们设置的三个函数断点中的其二，也就是<code>EnumProcessesModules</code>：获取指定进程的基址</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvdso10zj31ff0u0wpw.jpg" alt="获取基址"></p>
<p>在数据窗口中跟随存放函数执行结果的地址，然后<code>Ctrl + F9</code>执行到返回后，可以发现<code>OD</code>的基址是<code>00400000</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvfcc0plj31ff0u0ams.jpg" alt="基址"></p>
</li>
<li><p>继续<code>F9</code>运行程序，程序再次中断，这次是<code>GetModuleBaseNameA</code>：</p>
<p>执行到返回发现，它通过进程和基址获取到了<code>OD</code>的名称：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvrs35erj31ff0u0dr0.jpg" alt="名称"></p>
</li>
<li><p>接下来就不能直接<code>F9</code>运行程序了，因为再运行下去程序可能就结束了，所以使用<code>F8</code>单步执行，看看它获取了进程名之后要做什么：</p>
<ul>
<li><p>咦，又一个把<code>OD</code>句柄当作参数传递的函数，了解一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvyuodhhj31ff0u0n8h.jpg" alt="close"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CloseHandle</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知对象的句柄关闭句柄；</span><br></pre></td></tr></table></figure></li>
<li><p>继续执行后，去<code>句柄窗口</code>查看，已经找不到<code>OD</code>的句柄了，说明它被关闭了；</p>
</li>
<li><p>接着向下运行，发现一个把<code>OD</code>的名称当作参数的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhw42p6njj31ff0u0n8g.jpg" alt="名称"></p>
<p>使用<code>F7</code>步入跟进后，发现它是将<code>OD</code>的名称转换为 UpperCase，紧跟着下一个函数把转换后的名称和给定字符进行了比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwc8u9y2j31ff0u07g5.jpg" alt="比较"></p>
</li>
<li><p>上一步执行完毕后，由于比较的结果相同，跳转失败，程序又重新通过<code>OpenProcess</code>使用<code>OD</code>的 PID 获取了<code>OD</code>的句柄：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwl1yxpvj31ff0u0tkk.jpg" alt="重新获取"></p>
</li>
<li><p>接着，把<code>OD</code>的句柄作为参数传递给<code>TerminateProcess</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwpt69mlj31ff0u0k2p.jpg" alt="句柄当做参数"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TerminateProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过进程句柄终止指定进程及其所有线程；</span><br></pre></td></tr></table></figure>

<p>了解了这个 API 的用途后，继续运行程序，结果不言而喻：灵光一闪，程序关闭！</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDbg 反调试之综合练习</title>
    <url>/posts/3051308746/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-2">HideDebugger</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-15">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>本次内容涉及了小部分脱壳以及一个<code>OD</code>无法处理的异常<code>int 68</code>；</p>
</li>
<li><p>简单的脱壳和<code>int 68</code>说明：</p>
<p>要想看到<code>int 68</code>异常，需要用到<code>HideDebugger</code>和<code>HideOD</code>插件，不然程序运行不到那里就退出了，至于两个插件的配置，翻阅上篇文章，这里不再赘述；</p>
<ul>
<li><p>首先，这个程序很奇怪，没有打开<code>OD</code>的情况下程序也打不开，眼疾手快的同学可以在任务管理器窗口发现打开程序的同时有个进程一闪而过；</p>
</li>
<li><p>在开始之前，需要设置一下<code>OD</code>，为了能捕获所有异常，需要设置如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo98arrrbj31ff0u0gvn.jpg" alt="设置OD"></p>
</li>
<li><p>既然打不开，那还等什么，直接倒入<code>OD</code>分析：</p>
<p>倒入后，会弹出了弹窗，而这个弹窗正说明了这个程序有壳：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloa6ipooej313c06sjrl.jpg" alt="有壳"></p>
<p>关闭弹窗继续；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glnj7u4ww4j31ff0u0k16.jpg" alt="奇怪"></p>
<p>如果在这里能发现异常，说明基础知识还是比较扎实的；</p>
<p>是的，第二行代码<code>POPAD</code>就很奇怪，往上翻也只有一行空指令，奇怪在哪里呢？<code>POPAD</code>是弹栈的意思，也就是说，这条指令会把 8 个通用寄存器的数据从栈中弹出，恢复到程序压栈前的状态，而前面却没有对应的压栈指令<code>PUSHAD</code>，所以很奇怪；</p>
</li>
<li><p>既然<code>POPAD</code>前面有一行空指令，那岂不是可以直接写一个<code>PUSHAD</code>就解决了，我不但这么想了，而且还这么做了，不过立马就后悔了，原因无他，程序倒入<code>OD</code>没有运行的话，本就处于<code>EP</code>位置，在<code>EP</code>前面写代码，如何运行？被自己的灵机一动蠢哭了；</p>
</li>
<li><p>不过怀疑归怀疑，如何确定<code>POPAD</code>这个指令有问题呢，继续运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo991kaugj31ff0u0akc.jpg" alt="程序中断"></p>
<p>程序中断，在<code>OD</code>的最下方给出了原因，是因为有一个异常：<code>访问违规</code>，也就是说<code>PUSH 474988</code>这行指令无法压栈，无法压栈的原因是什么呢？应该是堆栈地址不对，就好比去澡堂子洗澡，给你的是 183 号衣柜的钥匙，而你非要放入 96 号衣柜，这肯定是放不进去的；</p>
<p>如何证实这个猜想呢？去<code>内存窗口</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo9hudfdbj31ff0u0477.jpg" alt="堆栈区间"></p>
<p>可以看到，系统分配给堆栈的地址是<code>0012C000</code>开始，大小<code>4000</code>，加法运算一下，刚好<code>00130000</code>，也就是说，堆栈的区间是<code>0012C000 - 0012FFFF</code>；</p>
<p>回过头来看<code>ESP</code>的地址，<code>ESP</code>指向堆栈顶端嘛：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo9mnhbmvj31ff0u07e3.jpg" alt="ESP"></p>
<p>很明显，<code>PUSH 474988</code>这行指令要压栈的地址，超出了堆栈的范围，所以才会引发异常；</p>
</li>
<li><p>既然找到了问题，那问题的根源是什么？<code>POPAD</code>，有可能是它改变了<code>ESP</code>的地址，从而导致后面的异常，重载程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo9ynnu5dj31ff0u0gvh.jpg" alt="未运行"></p>
<p>观察<code>POPAD</code>前，<code>ESP</code>的数据，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo9zy8jjvj31ff0u0qck.jpg" alt="运行后"></p>
<p>此时明显看到，<code>ESP</code>指向的地址，已经不在堆栈范围内，所以这个压栈指令会产生一个异常；</p>
</li>
<li><p>那么如何修改绕过这个异常呢？</p>
<p>既然<code>POPAD</code>前，<code>ESP</code>指向的地址在堆栈范围内，那如果不让它弹栈岂不是没有影响了，那就让它入栈<code>PUSHAD</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloa9p6p8nj31ff0u048h.jpg" alt="pushad"></p>
<p>然后运行程序，那个异常没有出现，看来已经绕过了，然鹅，程序却展示了一堆”乱码”：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloacagzksj31ff0u0wo4.jpg" alt="乱码"></p>
<p>在<code>汇编窗口</code>任意位置右键<code>分析 &gt; 从模块中删除分析</code>，然后乱码就消失了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloai1oghzj31ff0u0n6q.jpg" alt="解码"></p>
</li>
<li><p>兴奋之余扫了一眼<code>OD</code>左下角，又是一个<code>访问违规</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloam91kdtj31ff0u0woj.jpg" alt="又一个访问违规"></p>
<p>而它就是我们今天要了解的第二个异常<code>INT 68</code>，具体的描述也没有在搜索引擎中找到，暂且就知道它是一个<code>OD</code>无法处理的异常；</p>
<p>至于绕过方法很简单，就是将这行指令改为<code>NOP</code>即可：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloarbasscj31ff0u0ak3.jpg" alt="改为nop"></p>
<p>然后继续运行程序，发现程序正常运行了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloataudrgj31ff0u014h.jpg" alt="程序运行"></p>
</li>
</ul>
</li>
<li><p>反调试小记：</p>
<p>既然绕过脱壳和<code>int 68</code>异常，程序就正常运行了，那还反调试啥？别忘了，前面为了看到<code>int 68</code>异常，我们使用了两个插件，而如果没有这两个插件呢？</p>
<ul>
<li><p>把<code>HideDebugger</code>和<code>HideOD</code>插件从<code>OD</code>移除并重启<code>OD</code>，然后将程序倒入<code>OD</code>；</p>
</li>
<li><p>倒入程序后，<code>Ctrl + N</code>查看 API 列表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1globd2ax57j31ff0u0do8.jpg" alt="函数列表"></p>
<p>可以看到，函数不多而且没有什么特殊的，但<code>GetProcAddress</code>却在其中，这就很值得思考了，是不是函数都被隐藏了，果断给<code>GetProcAddress</code>设置断点并做好备注；</p>
</li>
<li><p>然后运行程序，程序会中断多次，而<code>GetProcAddress</code>会获取到所有隐藏或间接调用的函数，把认为可疑的函数设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glocd77gw8j31ff0u07dz.jpg" alt="断点做备注"></p>
<p>可以看到有三个断点被禁用了，这是经过思考之后的决定：</p>
<ol>
<li><code>GetProcAddress</code>：既然程序中断的位置已经改变，那就说明所有隐藏函数获取完毕，这个断点就没有意义了：“飞鸟尽良弓藏”；</li>
<li><code>CloseHandle</code>：关闭句柄，用处不大；</li>
<li><code>OpenProcess</code>：获取句柄，这个用途范围太大，况且，获取了就是要操作，直接拦截关闭岂不更香；</li>
</ol>
</li>
<li><p>获取所有隐藏函数后， 程序中断在<code>CreateToolhelp32Snapshot</code>：这个 API 是获取进程列表的所有程序的进程快照，并返回快照句柄供其他 API 使用，<code>Ctrl + F9</code>执行到返回；</p>
</li>
<li><p>既然已经获取了进程快照，那接下来应该就是调用<code>Process32First</code>或<code>Process32Next</code>来分析每个进程了吧？</p>
<p><code>F8</code>单步执行程序，程序又来到了未解密的代码段，右键<code>分析 &gt; 从模块中删除分析</code>解码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glocy1e9w9j31ff0u0dpe.jpg" alt="分析代码"></p>
<p><code>Ctrl + A</code>分析一下解码后的代码，确实发现了<code>Process32First</code>，呃，不过不在一个代码块，打脸是不是来的有点快；</p>
</li>
<li><p>继续<code>F8</code>单步执行程序，程序跳转，来到了一个新的代码段，这里看上去非常可疑：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glod4sudjrj31ff0u0gw7.jpg" alt="非常可疑"></p>
<p>有一处用<code>OpenProcess</code>获取句柄然后用<code>TerminateProcess</code>关闭程序，还有两个结构很类似的代码结构，继续往下翻，数一数，共有 6 处相同的结构：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glodjl22b5j31ff0u0wpf.jpg" alt="很一致"></p>
</li>
<li><p>既然觉得可疑，那就单步执行分析一下代码：</p>
<p>没有打脸，它确实调用了<code>Process32First</code>和<code>Process32FirstW</code>，二者的区别是：<code>Process32FirstW</code>是<code>Unicode</code>;</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glodpd2i7lj31ff0u0ajp.jpg" alt="调用Process32First"></p>
<p>继续运行程序，当然不会退出程序，因为进程列表的第一个进程肯定不是<code>OD</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glohkwrynmj30me0ve0tv.jpg" alt="进程列表"></p>
</li>
<li><p>然后多次运行程序，6 个结构相同的代码段依次比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glohisj5w1j31ff0u0qcn.jpg" alt="6个比较"></p>
</li>
<li><p>比较完会干什么？当然是调用<code>Process32Next</code>获取下一个进程的信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glohp0tbx1j31ff0u0qcp.jpg" alt="Process32Next"></p>
</li>
<li><p>继续向下执行，毫无悬念，又会回到 6 个循环组成的大循环，直到进程快照的所有进程比较完毕；</p>
</li>
<li><p>这里分析的差不多了，接下来迫不及待的想知道所有进程比较完毕后会做什么？很简单，无论它比较的结果是什么，都不让它结束程序，所以，把这里的<code>JNZ</code>都改成<code>JMP</code>，同样是 6 个：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glohvdo2lyj31ff0u0gvf.jpg" alt="JMP"></p>
</li>
<li><p>继续运行程序，直到所有进程比较完毕：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloi05b6qoj31ff0u0qcj.jpg" alt="PostQuitMessage"></p>
<p>程序中断在了<code>PostQuitMessage</code>，发送了退出程序的信息，这里就不能向下执行了，跟随它到调用的地方去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloi35nqeaj31ff0u0dph.jpg" alt="反汇编窗口跟随"></p>
<p>来到反汇编窗口，发现代码段很短：但很重要</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glokr3hvzuj31ff0u0akg.jpg" alt="代码段很短"></p>
<p>如果这个跳转成立，就不会调用<code>PostQuitMessage</code>，那就直接修改为<code>JMP</code>即可，甚至可以不用管它上面那个关键<code>CALL</code>是做什么的，这是为什么？很简单，因为这么半天了，连程序窗口都没有看到，如果允许程序调用<code>PostQuitMessage</code>就彻底没戏了，所以，在这个跳转上设置断点；</p>
</li>
<li><p>接着，重载并运行程序到最后设置的断点，需要先修改<code>POPAD</code>，接着修改大循环的<code>JNZ</code>为<code>JMP</code>，然后才能到达最后这个跳转的断点：</p>
<ul>
<li><p>重载程序的时候，会有提示弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glol2wpsbgj31am06yq3a.jpg" alt="重载弹窗"></p>
<p>这是因为，重载程序后，程序被加密了，我们在程序领空设置的断点无法识别，这个弹窗是提示我们程序领空设置的断点被禁用了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glol7yklm7j31ff0u0wnx.jpg" alt="断点禁用"></p>
</li>
<li><p>在修改完<code>POPAD</code>并运行程序后，程序会中断在<code>CreateToolhelp32Snapshot</code>，这时就可以启用程序领空的断点了；</p>
</li>
<li><p>运行到关键跳转的断点，修改<code>JE</code>为<code>JMP</code>达到绕过<code>PostQuitMessage</code>的目的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glolee6mnoj31ff0u048r.jpg" alt="绕过PostQuitMessage"></p>
</li>
</ul>
</li>
<li><p>接着<code>F9</code>运行程序，程序中断在<code>INT 68</code>，这个简单，直接修改为<code>NOP</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glolmnrznlj31ff0u0k17.jpg" alt="NOP填充"></p>
</li>
<li><p>继续运行程序，期待已久的程序界面终于出现了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glolus39ivj31ff0u0gwa.jpg" alt="终于出现"></p>
<p>至于界面卡顿，禁用所有断点就正常喽；</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDbg 断点</title>
    <url>/posts/2731277808/</url>
    <content><![CDATA[<h4 id="断点的分类"><a href="#断点的分类" class="headerlink" title="断点的分类"></a>断点的分类</h4><h5 id="F2-断点"><a href="#F2-断点" class="headerlink" title="F2 断点"></a>F2 断点</h5><ul>
<li><p><code>F2断点</code>又叫<code>普通断点</code>、<code>CC断点</code>、<code>int3断点</code>；</p>
</li>
<li><p>在<code>OD</code>反汇编窗口（<code>C</code>窗口）中，双击语句的某一行或按下 F2 会设置（触发）一个<code>int3 断点</code>；</p>
</li>
<li><p><code>int3</code>是一个断点（中断）指令，在汇编中机器码是<code>CC</code>，所以，<code>F2断点</code>又可以称为<code>int3断点</code>或<code>CC断点</code>；</p>
</li>
<li><p>在使用 F2 设置断点后，CPU 会引发一个异常，而 OD 会捕获这个异常，从而中断程序；</p>
<span id="more"></span></li>
<li><p>可以使用命令<code>bp xxxxxxxx</code>快速设置一个<code>CC断点</code>；</p>
</li>
<li><p><code>bp</code>可以为内存地址设置断点，也就是为某条语句设置断点；</p>
</li>
<li><p><code>bp</code>当然也可以为<code>API（函数）</code>设置一个断点，如<code>bp MessageBoxA</code>，断点会设置在 API 的行首，也就是函数的第一行；</p>
</li>
<li><p>通常情况下，当使用<code>bp</code>为<code>API</code>设置断点时，该<code>API</code>应该是可见的，也就是在反汇编窗口按下<code>Ctrl + N</code>后，在函数窗口能找得到时，才能使用<code>bp</code>设置断点，不过偶尔在找不到的情况下，也能使用<code>bp</code>设置断点，这种情况时可以买一注彩票；</p>
</li>
<li><p>使用<code>bp MessageBoxA</code>也就是为<code>API</code>设置断点后，会在系统领空下，这个<code>API</code>的行首设置断点；</p>
</li>
<li><p>使用<code>bpx MessageBoxA</code>也就是为<code>API</code>设置断点后，会在程序领空下，所有调用这个<code>API</code>的位置设置断点；</p>
</li>
<li><p><code>F2断点</code>的设置没有数量限制，可以设置无数个；</p>
</li>
<li><p><code>F2断点</code>很容易被检测，从而触发反调试；</p>
</li>
<li><p><code>F2断点</code>重载程序后不会丢失；</p>
</li>
</ul>
<p>当执行一个 int3 断点时，对应指令处第 1 个字节的内容会被调试器用 CC 指令替换，此时 OD 将 int3 隐藏，显示出来的仍是中断前的指令，实际上已经被替换为 CC；</p>
<p>当被调试程序执行 int3 命令导致一个异常时，调试器就会捕捉到这个异常，从而停在断点处，然后将断点处的指令恢复成原来的指令；</p>
<p>由于 int3 断点改变了原程序机器码，所以很容易被软件检测到，躲过检测的方法是将断点设置在函数内部或尾部；</p>
<h5 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h5><ul>
<li><code>内存断点</code>是通过修改内存属性为不可访问、不可执行来实现的；</li>
<li><code>内存断点</code>同时只能存在一个；</li>
<li><code>内存断点</code>在重载程序后会丢失，需要重新设置；</li>
<li><code>内存断点</code>会影响程序的运行速度；</li>
</ul>
<h5 id="内存访问一次性断点"><a href="#内存访问一次性断点" class="headerlink" title="内存访问一次性断点"></a>内存访问一次性断点</h5><p>在内存窗口（Alt + M），每个区段都有相应的权限（属性），选择区段并按下 F2 后，可以设置一次断点，且属性可以单独设置；</p>
<p>断点生效后会被自动删除，所以叫做一次性断点；</p>
<h5 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h5><ul>
<li><code>硬件断点</code>最多可以设置 4 个；</li>
<li><code>硬件断点</code>在设置位置的下一条指令中断；</li>
<li>可以使用命令<code>HE xxxxxxxx</code>快速设置一个<code>硬件执行断点</code>；</li>
<li>可以使用命令<code>HE MessageBoxA</code>在<code>API</code>的行首快速设置一个<code>硬件执行断点</code>；</li>
<li><code>HW xxxxxxxx</code>设置<code>硬件写入断点</code>；</li>
<li><code>HR xxxxxxxx</code>设置<code>硬件读取断点</code>；</li>
<li>硬件断点只能手动删除或执行删除；</li>
</ul>
<p>硬件断点和 DRx 调试寄存器有关；</p>
<p>DRx 调试器一共有 8 个（DR0 ～ DR7）：</p>
<ul>
<li>DR0 ～ DR3:调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点；</li>
<li>DR4 ～ DR5：保留，未公开具体作用；</li>
<li>DR6：调试寄存器组状态寄存器；</li>
<li>DR7：调试寄存器组控制寄存器；</li>
</ul>
<p>硬件断点的原理是使用 DR0 ～ DR3 设定地址，并使用 DR7 设定状态，因此最多设置 4 个断点；</p>
<p>硬件执行断点和 CC 断点的作用一样，但不会修改机器码，所以更难检测；</p>
<p>硬件断点的优点是速度快，在 int3 断点容易发现的地方设置硬件断点效果更好，缺点是只能设置 4 个；</p>
<h5 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h5><ul>
<li>满足某个条件的<code>CC断点</code>;</li>
<li>使用<code>shift + F2</code>快速设置条件断点；</li>
<li>OD 的条件断点可以按寄存器、存储器、消息等设断；</li>
</ul>
<h5 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h5><ul>
<li>多了记录断点处函数表达式或参数值的条件断点；</li>
<li>使用<code>shift + F4</code>快速设置条件记录断点；</li>
</ul>
<h5 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h5><ul>
<li>消息断点实际上就是条件记录断点；</li>
<li>在操作窗口或控件时，都会发送一个消息；</li>
<li>在<code>OD</code>的<code>W</code>窗口刷新来获取交互消息；</li>
<li>检测交互（消息循环）来设置<code>消息断点</code>，如<code>101 按键抬起</code>、<code>202 鼠标左键抬起</code>等；</li>
<li>断点生效后，修改条件来记录操作日志，在<code>OD</code>的<code>L</code>窗口查看记录的日志或将日志输出到指定文件来进一步进行分析；</li>
</ul>
<p>Windows 本身是由消息驱动的；</p>
<p>当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断；</p>
<p>消息断点与 int3 断点的区别是：int3 断点可以在程序启动前设置，消息断点只有在窗体被创建之后才能设置并拦截消息；</p>
<p>所有发送的消息都有 4 个参数：1 个窗口句柄（hwnd）、1 个消息编号（msg）和 2 个 32 位长（long）的参数；</p>
<p>Windows 通过句柄来标识它所代表的对象；</p>
<h5 id="API-断点"><a href="#API-断点" class="headerlink" title="API 断点"></a>API 断点</h5><ul>
<li>给系统提供的 API 设置的<code>CC断点</code>；</li>
<li><code>MessageBoxA</code>中的<code>A</code>表示使用<code>ASCII</code>编码；</li>
<li><code>MessageBoxW</code>中的<code>W</code>表示使用<code>Unicode</code>编码；</li>
</ul>
<h4 id="OD-基本指令"><a href="#OD-基本指令" class="headerlink" title="OD 基本指令"></a>OD 基本指令</h4><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + G</td>
<td align="center">跳转到指定地址</td>
</tr>
<tr>
<td align="center">F2</td>
<td align="center">设置断点</td>
</tr>
<tr>
<td align="center">Ctrl + F2</td>
<td align="center">重新载入</td>
</tr>
<tr>
<td align="center">Alt + F2</td>
<td align="center">关闭调试的程序</td>
</tr>
<tr>
<td align="center">F4</td>
<td align="center">运行到光标选定位置</td>
</tr>
<tr>
<td align="center">F7</td>
<td align="center">单步步入</td>
</tr>
<tr>
<td align="center">Ctrl + F7</td>
<td align="center">自动步入</td>
</tr>
<tr>
<td align="center">F8</td>
<td align="center">单步步过</td>
</tr>
<tr>
<td align="center">Ctrl + F8</td>
<td align="center">自动步过</td>
</tr>
<tr>
<td align="center">F9</td>
<td align="center">运行程序，有断点运行到断点</td>
</tr>
<tr>
<td align="center">Ctrl + F9</td>
<td align="center">执行到返回</td>
</tr>
<tr>
<td align="center">Ctrl + F11</td>
<td align="center">跟踪步入</td>
</tr>
<tr>
<td align="center">Ctrl + F12</td>
<td align="center">跟踪步过</td>
</tr>
<tr>
<td align="center">Ctrl + T</td>
<td align="center">设置 RUN 跟踪的条件</td>
</tr>
<tr>
<td align="center">Ctrl + E</td>
<td align="center">编辑数据</td>
</tr>
<tr>
<td align="center">;</td>
<td align="center">添加注释</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">添加标签</td>
</tr>
<tr>
<td align="center">空格</td>
<td align="center">编辑汇编指令</td>
</tr>
</tbody></table>
<h4 id="快速定位指定地址的四种方法"><a href="#快速定位指定地址的四种方法" class="headerlink" title="快速定位指定地址的四种方法"></a>快速定位指定地址的四种方法</h4><ol>
<li>goto 命令</li>
<li>设置断点</li>
<li>设置注释</li>
<li>设置标签</li>
</ol>
<h4 id="快速查找指定代码的四种方法"><a href="#快速查找指定代码的四种方法" class="headerlink" title="快速查找指定代码的四种方法"></a>快速查找指定代码的四种方法</h4><ol>
<li><p>代码执行法</p>
<p>在程序代码量不大且功能明确的情况下，逐条执行指令，直到需要查找的指令被触发，例如，触发 MessageBox 会弹窗；</p>
</li>
<li><p>字符串检索法</p>
<p>检索 OD 载入程序时摘录出来的字符串列表；</p>
</li>
<li><p>API 检索法：在调试代码中设置断点</p>
<p>检索 OD 通过 IAT 摘录的 API 函数列表，查找符合程序行为特征的函数调用；</p>
</li>
<li><p>API 检索法：在 API 代码中设置断点</p>
<p>向 DLL 代码库中符合程序行为特征的 API 添加断点；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>文章资料</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>断点</tag>
      </tags>
  </entry>
  <entry>
    <title>SFX 功能定位 OEP</title>
    <url>/posts/3371155739/</url>
    <content><![CDATA[<blockquote>
<p>对壳一无所知的情况下，通过简单的操作完成程序的脱壳，从而增加成就感，获得学习的乐趣及动力；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li>加壳工具使用了<a href="https://upx.github.io/">UPX</a>，感谢 🙏 开源，以及 <a href="http://www.aspack.com/">ASPACK</a>：收费软件，可以试用；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h4><p>壳（也叫“外壳”）是一种专用加密软件技术；</p>
<p>壳分为：压缩壳、加密壳、虚拟机保护软件；</p>
<h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><ol>
<li><p>首先，将原始程序导入 OD，然后查看 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv7l4xkb9j31dp0u0jv3.jpg" alt="原始程序导入 OD"></p>
<p>可以看到，原始程序的 OEP 是：00401000；</p>
</li>
<li><p>安装 UPX，然后打开并给 CM 加壳：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv797t16ij31340u076k.jpg" alt="给 CM 加壳"></p>
<p>将 CM 拖入 UPX，选项默认，点击 RUN 即可；</p>
<p>不会生成新文件，而是直接在源程序上加壳，所以，记得备份源程序；</p>
</li>
<li><p>打开 OD 设置 SFX：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv7j8uzeuj31dx0u0n2e.jpg" alt="设置 SFX"></p>
<p>打开调试设置，在异常选项卡下，勾选全部选项，是为了防止 SFX 在自动分析中，中断在某个异常而导致失败；</p>
<p>然后，在 SFX 选项卡下，勾选 <code>块方式跟踪</code>或<code>字节方式跟踪</code>其一，它们的区别是查找速度与准确率，首先选择速度较快的<code>块方式跟踪</code>；</p>
</li>
<li><p>然后将加壳后的程序载入 OD，发现没有任何反应，即使切换 SFX 选项卡为<code>字节方式跟踪</code>也没有任何反应，这是为什么呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv7vp6yy2j31e30u0jut.jpg" alt="没有任何反应"></p>
</li>
<li><p>原来，SFX 使用是有限制的：程序在载入 OD 后，入口点必须位于代码段（.code）之外，才会生效；</p>
<p>打开内存窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv7xm4w2qj31e00u077c.jpg" alt="内存窗口"></p>
<p>发现当前程序的代码段起始位置为：00409000，大小为 1000，也就是说，当前程序代码段的范围是 00409000 ～ 00409FFF；</p>
<p>而程序载入 OD 后，EP（入口点）位于 00409BF0，处于代码段范围，所以 SFX 没有生效；</p>
</li>
<li><p>既然 UPX 加壳后入口点在代码段，那就切换加壳软件，使用 ASPACK；</p>
<p>安装 ASPACK 并打开，在打开文件选项卡下点击打开并选择原始程序，就会自动加壳：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv8e3edj4j30n80iat9g.jpg" alt="ASPACK"></p>
<p>ASPACK 同样不会生成新文件，所以，记得备份源程序；</p>
</li>
<li><p>首先，打开 OD 确认 SFX 以及异常选项卡设置 OK，然后将 ASPACK 加密后的程序导入 OD：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv8k4495oj31du0u0q6x.jpg" alt="ASPACK 加密后的程序导入 OD"></p>
<p>CM 运行起来了，然而，程序并非停留在 OEP 上，因为第 1 步的时候，已经确认了原始程序的 OEP 是：00401000；</p>
<p>看来 SFX 的<code>块方式跟踪</code>速度很快但是不够准确，不过，既然 CM 能够运行，也侧面说明了，ASPACK 加壳后，EP 位于代码段之外；</p>
</li>
<li><p>切换 SFX 选项为<code>字节方式跟踪</code>并删除 OD 操作日志（UDD 文件夹内），重新将 ASPACK 加密后的程序导入 OD：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv8u6b8v9j31dy0u0wi4.jpg" alt="程序已脱壳"></p>
<p>此时 EP 停留在 00401000 上，也就 OEP 上，说明程序已经脱壳了；</p>
</li>
<li><p>加壳方式多种多样，这种脱壳方式可用范围应该很小，毕竟换了加壳工具后就失效了，不过，很振奋人心；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>SFX</tag>
        <tag>UPX</tag>
      </tags>
  </entry>
  <entry>
    <title>Stolen-Code 与 Anti-Dump</title>
    <url>/posts/1563828353/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-7">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-3">PETools</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>区段导出工具为<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-9">Pupe</a>，来自互联网；</li>
<li>区段合并工具为<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-10">Peditor</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>此次使用 KiUserExceptionDispatcher 函数来寻找 OEP，学习一种新技能；</p>
</li>
<li><p>KiUserExceptionDispatcher 函数是用户态异常派发函数，所有异常都会经过该函数来派发，函数的第 2 个参数指向产生异常时的上下文；</p>
</li>
<li><p>将 CM 导入 OD 并运行后，在 log 窗口可以看到很多异常，重点关注最后一次异常：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5n13f0l8j21dz0u0gpn.jpg" alt="log"></p>
<p>异常法的原理就是：在异常前有 DLL 调用， 在异常后依然有 DLL 调用，但程序可以正常运行，那么异常前的 DLL 可能是壳调用的，而异常后的 DLL 则是程序运行调用的，所以，异常发生的位置是距离 OEP 最近的位置，此时外壳对代码段的解压操作可能已经完成，那么给代码段设置内存访问断点后，就可以很快到达 OEP；</p>
</li>
<li><p>重载程序，goto 到 KiUserExceptionDispatcher 函数行首，设置条件断点；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5ndk7vm1j20p00l8aan.jpg" alt="条件断点"></p>
<p>其中，表达式为<code>ESP + 14</code>，这是因为 KiUserExceptionDispatcher 函数的第 2 参数位于当前领空的 ESP + 14 处；</p>
<p>中断条件则是异常的地址为最后一次异常产生的地址，别忘了勾选按条件中断；</p>
</li>
<li><p>运行程序，程序中断后，给代码段设置内存访问断点并运行程序，程序到达 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5nkx8x4wj21e40u0420.jpg" alt="假 OEP"></p>
<p>当前为 C++ 程序，但入口却不是默认的 OEP，向上滚动代码，根据代码逻辑判断，004271B0 才是程序真正的入口点，而此处却是毫无逻辑的花指令；</p>
<p>C++ 程序的入口点特征：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">Microsoft Visual C++ <span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">00496EB8  |.  <span class="number">55</span>            <span class="keyword">PUSH</span> <span class="built_in">EBP</span></span><br><span class="line">00496EB9  |.  8BEC          <span class="keyword">MOV</span> <span class="built_in">EBP</span>,<span class="built_in">ESP</span></span><br><span class="line">00496EBB  |.  6A FF         <span class="keyword">PUSH</span> -<span class="number">1</span></span><br><span class="line">00496EBD  |.  <span class="number">68</span> <span class="number">40375600</span>   <span class="keyword">PUSH</span> Screensh<span class="number">.00563740</span></span><br><span class="line">00496EC2  |.  <span class="number">68</span> 8CC74900   <span class="keyword">PUSH</span> Screensh<span class="number">.</span>0049C78C</span><br><span class="line">00496EC7  |.  <span class="number">64</span>:A1 <span class="number">0000000</span>&gt;<span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">0</span>]</span><br><span class="line">00496ECD  |.  <span class="number">50</span>            <span class="keyword">PUSH</span> <span class="built_in">EAX</span></span><br><span class="line">00496ECE  |.  <span class="number">64</span>:<span class="number">8925</span> <span class="number">00000</span>&gt;<span class="keyword">MOV</span> <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">0</span>],<span class="built_in">ESP</span></span><br><span class="line">00496ED5  |.  83EC <span class="number">58</span>       <span class="keyword">SUB</span> <span class="built_in">ESP</span>,<span class="number">58</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>这里也是今天的重点之一<code>Stolen-Code</code>；</p>
<p><code>Stolen-Code</code>直译过来就是被盗的代码；</p>
<p>相同编程语言的程序在编译后 OEP 的风格相似，而某些壳在处理 OEP 的代码时，把这些固定的代码替换（花指令）或 NOP 掉，然后把它们放到壳代码的空间里面（而且还常伴随着花指令），使原程序的开始从壳空间开始，然后再 JMP 回程序空间；</p>
<p>如果脱壳后，这一部分 OEP 代码就会遗失，也就达到了反脱壳的目的，这就是 Stolen-Code 技术，或者更确切的说是 Stolen OEP Code 技术；</p>
<p>了解 Stolen-Code 技术后， 接下来就是找回丢失的 OEP 代码了，离 OEP 最近的壳代码就是最后一次异常产生的位置；</p>
</li>
<li><p>重载程序，在 KiUserExceptionDispatcher 函数的行首设置条件断点，程序中断后，在中断位置所在的区段设置访问断点（F2）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5ohuwtgzj21dw0u041k.jpg" alt="F2 断点"></p>
<p>在此处设置断点的目的是跟随到调用位置，也就是离 OEP 最近的位置，断点设置好后，运行程序；</p>
</li>
<li><p>程序中断后，查看代码逻辑，应该就是此处了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5oo84jrwj21dv0u0jv3.jpg" alt="花指令"></p>
<p>此处很多都是没有实际用途的花指令，为什么要用花指令呢？</p>
<p>因为花指令不会影响程序的正常运行，既然丢失的 OEP 代码夹杂其中，那就只能 F7 单步寻找了；</p>
</li>
<li><p>C++ 程序的 OEP 前两行代码为<code>PUSH EBP</code>和<code>MOV EBP, ESP</code>，这是生成栈帧的指令，目的是为了保持堆栈平衡，而之后的代码很可能因为程序逻辑的不同而不同，所以，前两行代码是关键：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5ozi135xj21dw0u0adh.jpg" alt="PUSH EBP"></p>
<p>功夫不负有心人，终于找到了<code>PUSH EBP</code>，那么后面的代码只要是有意义的就是 OEP 中的代码，保存这些代码的指令；</p>
</li>
<li><p>运行到此处时，意味着所有丢失的代码已经找到了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5p59hth5j21e80u0gp0.jpg" alt="跳转到 OEP"></p>
<p>因为这条指令把当前 OEP 的地址 PUSH 到堆栈，那后面肯定还有一个 RETN 用来跳转到当前 OEP；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5p7qc9qfj21e30u077n.jpg" alt="RETN"></p>
<p>此处 RETN 后就是跳转到 OEP；</p>
<p>记录丢失代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">003D6A4A    <span class="number">55</span>              <span class="keyword">PUSH</span> <span class="built_in">EBP</span></span><br><span class="line">003D6A6F    8BEC            <span class="keyword">MOV</span> <span class="built_in">EBP</span>,<span class="built_in">ESP</span></span><br><span class="line">003D6A93    6A FF           <span class="keyword">PUSH</span> -<span class="number">1</span></span><br><span class="line">003D6AB9    <span class="number">68</span> 600E4500     <span class="keyword">PUSH</span> 450E60</span><br><span class="line">003D6AE3    <span class="number">68</span> C8924200     <span class="keyword">PUSH</span> 4292C8</span><br><span class="line">003D6B0D    <span class="number">64</span>:A1 <span class="number">00000000</span>  <span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">0</span>]</span><br><span class="line">003D6B35    <span class="number">50</span>              <span class="keyword">PUSH</span> <span class="built_in">EAX</span></span><br><span class="line">003D6B59    <span class="number">64</span>:<span class="number">8925</span> <span class="number">0000000</span>&gt;<span class="keyword">MOV</span> <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">0</span>],<span class="built_in">ESP</span></span><br><span class="line">003D6B85    83C4 A8         <span class="keyword">ADD</span> <span class="built_in">ESP</span>,-<span class="number">58</span></span><br><span class="line">003D6BAC    <span class="number">53</span>              <span class="keyword">PUSH</span> <span class="built_in">EBX</span></span><br><span class="line">003D6BCF    <span class="number">56</span>              <span class="keyword">PUSH</span> <span class="built_in">ESI</span></span><br><span class="line">003D6BF6    <span class="number">57</span>              <span class="keyword">PUSH</span> <span class="built_in">EDI</span></span><br><span class="line">003D6C1B    <span class="number">8965</span> E8         <span class="keyword">MOV</span> <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">SS</span>:[<span class="built_in">EBP</span>-<span class="number">18</span>],<span class="built_in">ESP</span></span><br></pre></td></tr></table></figure></li>
<li><p>用找到的指令替换当前 OEP 之前的花指令：</p>
<p>找到的指令是：558BEC6AFF68600E450068C892420064A10000000050648925000083C4A85356578965E8；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5pdw5plpj21e70u0gp9.jpg" alt="替换"></p>
<p>选择起始行，按下<code>Ctrl + E</code>，取消<code>保持大小</code>选项，将指令粘贴到 16 进制编辑框，然后点击确定完成修改；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5po8vu9aj21e30u0gpw.jpg" alt="替换后"></p>
<p>替换前后对比；</p>
</li>
<li><p>使用 PETools 将内存数据 Dump 并保存为可执行文件；</p>
</li>
<li><p>定位到 IAT 之后发现，虽然 IAT 的数据没有被重定向，但还是有些异常：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5q5so30rj20t80nudgp.jpg" alt="IAT"></p>
<p>IAT 之间不是以 DWORD 的 0 分隔的，而是无效数据；</p>
<p>尝试使用 ImportREC 获取 IAT 数据，发现无效项会干扰正常获取：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5qdjj0uij21760nyq4q.jpg" alt="干扰"></p>
<p><code>Cut thunk(s)</code>无效选项后，获取正常，然后修复程序；</p>
</li>
<li><p>然而，修复后的程序却不能运行，导入 OD ：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5qh9hd6aj21e30u0n0w.jpg" alt="再次导入 OD"></p>
<p>运行程序后弹出错误弹窗；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5qmidqqtj21du0fit9k.jpg" alt="区段丢失"></p>
<p>打开内存映射窗口，和原程序对比后发现错误地址所在区段在 Dumped 的程序中不存在，这就是引起异常的原因，也是 Anti-Dump；</p>
</li>
<li><p>解决的方法很简单，将程序中缺失的区段补回来不就完了：拷贝原程序的对应区段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5rkamptpj20z60u078x.jpg" alt="拷贝原始区段"></p>
<p>使用 pupe.exe 将原程序的 00AC0000 区段提取出来；</p>
</li>
<li><p>将保存的区段合并到修复程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5rriixomj21kw0l2q4c.jpg" alt="添加"></p>
<p>使用 peditor.exe 将提取的区段合并到修复失败的程序中；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5rs8xg0yj20s60b6t8y.jpg" alt="添加完成"></p>
<p>还没有完，由于是直接拷贝原程序的区段，当前程序若要正确载入区段，需要修改此区段的 RVA；</p>
<p>区段的 RVA = 区段起始地址 - 基址 = 00AC0000 - 00400000 = 6C0000；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5s2xgqdkj20s60q4dgp.jpg" alt="修改 RVA"></p>
<p>右键菜单编辑节，修改区段 RVA 并保存；</p>
</li>
<li><p>由于修改了区段数据，所以还要重新构建 PE 头文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5tajaku0j20yo0fgq3j.jpg" alt="重建 PE"></p>
<p>将修复的程序拖入 LoadPE，重新构建 PE；</p>
</li>
<li><p>运行程序正常，导入 OD，跟随任意调用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5tdczvf6j21dz0u0dki.jpg" alt="正常"></p>
<p>一切正常，脱壳完成！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>Anti-Dump</tag>
        <tag>IAT</tag>
        <tag>Stolen-Code</tag>
        <tag>PELock</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 程序快速定位 OEP</title>
    <url>/posts/69889928/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-19">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="http://www.aspack.com/">ASPACK</a>：收费软件，可以试用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>使用 ASPACK 给 CM 加壳；</p>
</li>
<li><p>将加壳后的 CM 导入 OD，然后来到内存窗口，找到 MSVBVM60.dll 的代码段，设置内存访问断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwh95tsoij31a30u0ad4.jpg" alt="MSVBVM60"></p>
<p>VB 程序有个特点：入口处都是一个 PUSH 指令，然后一个 CALL 指令，并且 CALL 指令中的 JMP 指向 MSVBVM60/50；</p>
<p>所以这里的思路就是：当外壳程序执行完毕，跳转至 OEP 时，程序会调用 MSVBVM60/50，所以，只要给 MSVBVM60/50 设置断点，然后跟随到调用位置，就到达 OEP 了；</p>
</li>
<li><p>设置好断点并<code>F9</code>运行程序，程序会中断在 MSVBVM60/50 的行首：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwi48xrnrj31a60u0adj.jpg" alt="中断在 MSVBVM60/50 的行首"></p>
<p>此时在栈窗口跟随到调用位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwicoomz0j31a50u0wi6.jpg" alt="调用位置"></p>
<p>这里，通过上面的函数列表就已经可以确定是 OEP，VB 程序的 OEP 基本类似，都是这种结构；</p>
</li>
<li><p>删除代码分析后，更加确定这里就是 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwi9wuc1ij31a40u0djm.jpg" alt="删除代码分析后"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
        <category>VB 汇总</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>ASPack</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之 P-Code 寻找操作码</title>
    <url>/posts/3657232687/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li>VB 静态分析工具<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-8">exdec</a>来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-20">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><h5 id="方法一：手动寻找"><a href="#方法一：手动寻找" class="headerlink" title="方法一：手动寻找"></a>方法一：手动寻找</h5><ol>
<li><p>将<code>CrackMe</code>倒入<code>OD</code>，会停留在程序的入口点，向上滚动代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmu1cuo5wj31b40u0q6o.jpg" alt="程序入口"></p>
<p>会发现一个 API <code>MethCallEngine</code>是用来初始化<code>P-Code</code>的，不过<code>P-Code</code>的初始化和常见的程序相反，一般，程序在运行时，会初始化所有资源以供调用，而<code>P-Code</code>却是在调用时才会初始化；</p>
</li>
<li><p>在<code>MethCallEngine</code>上右键菜单选择跟随或者在<code>MethCallEngine</code>上按下<code>Enter</code>，进入函数内部：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmu8fdabdj31b30u0n0r.jpg" alt="函数内部"></p>
<p>双击行首或按下<code>F2</code>设置断点并做好备注；</p>
</li>
<li><p>接着运行程序，发现程序主窗体已经出现，但并没有中断在设置的断点位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmuif7y2nj31b50u0jv1.jpg" alt="没有中断在断点位置"></p>
<p>然后输入随机注册码，点击<code>Registrar</code>后，程序才会中断在断点位置，这也从侧面说明了<code>P-Code</code>是先调用，后初始化；</p>
</li>
<li><p>来到<code>内存窗口</code>，在代码段设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmuonz3vuj31b20u076z.jpg" alt="内存访问断点"></p>
<p>虽然<code>P-Code</code>使用的是操作码，但它依然会存储在代码段；</p>
</li>
<li><p>接下来就是寻找操作码了，操作码的格式是<code>MOVE AL, BYTE PTR DS:[ESI]</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmuyuyqyzj31b40u0jvu.jpg" alt="第1操作码"></p>
<p>多次中断后会停留在预期的指令上，而这条指令的作用就是获取操作码，数据窗口查看<code>ESI</code>会得到具体的操作码；</p>
</li>
</ol>
<h5 id="方法二：工具分析"><a href="#方法二：工具分析" class="headerlink" title="方法二：工具分析"></a>方法二：工具分析</h5><ol>
<li><p>使用<code>exdec</code>工具分析程序，会得到程序的静态分析结果：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmv9f05wgj31b20u0td9.jpg" alt="静态分析"></p>
<p>可以看到，分析的结果和手动寻找的结果一致，地址相同，操作码相同；</p>
</li>
<li><p>测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmvhn1zp8j31b60u0af0.jpg" alt="设置内存访问断点"></p>
<p>重载程序，在数据窗口跟随分析结果第 1 操作码的地址，然后在第 1 操作码上设置内存访问断点；</p>
</li>
<li><p>运行程序，输入注册码，点击 Registrar：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmvo4idw0j31b50u0435.jpg" alt="中断在操作码位置"></p>
<p>程序中断在第 1 操作码的位置；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
        <category>VB 汇总</category>
      </categories>
      <tags>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之 P-Code 替换操作码</title>
    <url>/posts/3307503664/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-22">CrackMe 和 opcodes.txt</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>运行程序，程序会先弹出一个 NAG 窗口，点击确定后弹出主窗体：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuyri1qyhj30sy0lcaau.jpg" alt="运行程序"></p>
</li>
<li><p>导入<code>OD</code>开始分析，首先按照常规思路，既然有弹窗，肯定会使用 API：<code>rtcMsgBox</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuyuvjmrpj31dv0u0tcb.jpg" alt="查找API"></p>
<p>查看 API 列表，找到<code>rtcMsgBox</code>设置断点，然后运行程序；</p>
</li>
<li><p>程序中断后，在栈窗口<code>反汇编窗口跟随</code>到返回位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuywuticyj31dv0u0q6f.jpg" alt="反汇编窗口跟随"></p>
<p>在调用位置设置断点，然后重载并运行程序；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv2fpugyyj31dx0u078s.jpg" alt="在调用位置设置断点"></p>
</li>
<li><p>调用指令是<code>CALL EAX</code>，当前 EAX 值为 401000，<code>Ctrl + G</code> 跳转到 401000，正是<code>rtcMsgBox</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuz7bgembj31dr0u00wd.jpg" alt="401000"></p>
<p>按下<code>-</code>减号键，回到断点位置，既然是调用函数，CALL 上面的指令就是它的参数，这种传参方式在 P-Code 中很常见，还没有完，继续；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuznpzrsjj31dv0u0n28.jpg" alt="CALL的参数"></p>
<p>CALL 的参数到底是什么呢？</p>
<p>根据上面的代码逻辑，获取一个操作码后无条件跳转了，所以，<code>JMP</code>以上的代码与 CALL 无关；</p>
<p>因此，CALL 的参数应该是<code>JMP</code>向下，直到<code>CALl</code>；</p>
<p>给参数起始位置设置断点，因为中间包含<code>JE</code>跳转，为了防止跳转，同时给<code>JE</code>也设置断点，重载并运行程序；</p>
</li>
<li><p>这里的戏就很精彩了，程序中断在参数位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuzxxlr7hj31dy0u0tcz.jpg" alt="程序中断在参数位置"></p>
<p>然后按下<code>Ctrl + A</code>分析程序，在信息窗口发现跳转至此处的位置太多，如果挨个儿去跟，那就相当精彩了；</p>
<p>同时，EAX 中有一个操作码<code>OA</code>，为啥它是操作码？因为根据 P-Code 的惯例，接下来既然要获取参数了，且代码没有执行，那 EAX 中存放的就是上一步的结果，而 P-Code 的逻辑就是先获取操作码，紧接着就是获取参数，那就说明，接下来获取的参数既是 CALL 的参数，也是<code>OA</code>操作码的参数，So，<code>OA</code>肯定是一个操作码；</p>
<p>数据窗口跟随 ESI，发现<code>OA</code>位于当前 ESI 之前，地址是：401AD2；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv0ahg84qj31e00u0n1p.jpg" alt="数据窗口跟随 ESI"></p>
<p>既然接下来要执行 CALL 也就是<code>rtcMsgBox</code>函数了，那么<code>OA</code>在 P-Code 中是否就是<code>rtcMsgBox</code>呢？</p>
</li>
<li><p>继续运行程序，直到将要获取下一个操作码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv0jiz60tj31dw0u0q6r.jpg" alt="将要获取下一个操作码"></p>
<p>标志性的获取操作码的语句，接下来要获取的操作码是<code>36</code>，同时也反向说明，在这行代码之前，<code>OA</code>操作码是一直有效的；</p>
<p>而且，<code>OA</code>的参数是两个：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv10zic33j31e00u0q8d.jpg" alt="OA 的参数是两个"></p>
<p>因为操作了两次 ESI，同时，位于<code>OA</code>和<code>36</code>之间的数据被分别放入了 ECX 和 EDI；</p>
</li>
<li><p>大胆的猜测一下，如果<code>OA</code>就是<code>rtcMsgBox</code>，那么替换它是否就能跳过弹窗呢？</p>
</li>
<li><p>重载程序，在数据窗口 goto 到<code>OA</code>，也就是 401AD2：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv0sw66o4j31dz0u0n0r.jpg" alt="goto 到 OA"></p>
</li>
<li><p>打开<code>opcode.txt</code>，发现<code>07</code>与<code>OA</code>参数数量和参数大小都相同，且<code>07</code>没有副作用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv20byaqvj312e0e20sz.jpg" alt="opcode.txt"></p>
<p>如上图所示：</p>
<ul>
<li><code>OA</code>表示调用指针（ptr）指向的函数，且没有返回值，4 字节大小，有 2 个参数，参数一 2 字节，参数二 2 字节（4 2 2 2）；</li>
<li><code>07</code>表示 PUSH 值到堆栈，4 字节大小，有 2 个参数，参数一 2 字节，参数二 2 字节（4 2 2 2）；</li>
</ul>
<p>这里不用 <code>0B</code>替换<code>OA</code>的原因是：CALL 的副作用要比 PUSH 大的多；</p>
<p>所以，替换<code>0A</code>为<code>07</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv18ioilnj31dz0u0wiv.jpg" alt="替换 OA"></p>
<p>需要注意的是：替换操作码时，两个操作码的参数数量和参数大小必须完全相同，且替换的操作码对程序的运行没有副作用；</p>
</li>
<li><p>然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv1e58hd6j31dz0u0n10.jpg" alt="然后运行程序"></p>
<p>没有出现 NAG 窗口，直接显示程序主窗体；</p>
</li>
<li><p>保存修改到可执行文件，运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv1hpnkpqj30wa0k23z2.jpg" alt="保存修改到可执行文件"></p>
<p>修改依然没有问题，完工！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
        <category>VB 汇总</category>
      </categories>
      <tags>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之优先创建窗体</title>
    <url>/posts/3326045461/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-18">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先运行软件，了解一下程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxg8pjn3fg30mw0i4qit.gif" alt="运行程序"></p>
<ul>
<li>运行程序后，首先出现一个倒计时 5 秒的窗体；</li>
<li>同时 Continue 按钮处于禁用状态；</li>
<li>倒计时结束后，Continue 按钮启用，并在点击后可进入主窗体；</li>
</ul>
</li>
<li><p>将<code>CrackMe</code>倒入<code>OD</code>，开始分析：</p>
<ul>
<li><p>这里的倒计时窗体可以算得上是<code>NAG</code>窗口了，很是烦人啊有木有；</p>
</li>
<li><p>如何跳过<code>烦人的窗口</code>直接进入主程序呢？</p>
<ol>
<li><p>倒计时结束后，点击 Continue ，程序跳转进入主程序；</p>
</li>
<li><p>程序的跳转肯定发生在<code>CODE</code>段；</p>
</li>
<li><p>在倒计时结束后，到<code>内存窗口</code>给<code>CODE</code>段设置内存访问断点，然后在程序界面点击 Continue：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxj7a5ioxj31a40u0tf3.jpg" alt="内存访问断点"></p>
</li>
<li><p>程序中断，可以看到接下来要执行 JMP，根据程序的逻辑可以确定，这个 JMP 就是跳转到主窗体的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxjcnfvr5j319s0u0gpl.jpg" alt="跳转到主窗体"></p>
<p>相邻的还有 3 个 JMP，给它们全部设置断点，看看它们分别要做的事情；</p>
</li>
<li><p>重载并运行程序，程序中断在第三个 JMP，根据程序逻辑，程序初始运行后，会先展示一个<code>NAG</code>窗口，<code>F9</code>运行程序，果然不出所料；</p>
</li>
<li><p>接着运行程序，程序中断在第四个 JMP，共计中断 5 次，不用说，这个是倒计时跳转，同时，最后一次中断后，Continue 按钮启用；</p>
</li>
<li><p>点击 Continue 按钮，程序中断在第一个 JMP 位置，四个跳转已知其三，第二个 JMP 肯定是 Exit，最后，分析结果如图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxjzjje22j319x0u0q60.jpg" alt="分析"></p>
</li>
<li><p>既然已经知道了第一个 JMP 是跳转至程序主窗体的，那能否让程序刚运行就跳转到主窗体，这样是不是就绕过了<code>NAG</code>窗口？值得一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxk4ry1mij30mu0meq6g.jpg" alt="NoNAG"></p>
<p>将修改保存到文件，保存方法不再赘述，然后运行程序，Perfect！</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>4C 法</p>
<blockquote>
<p>4C 法对于单纯的本地验证应该比较好用，但是基于网络验证可能就不是很好用了，尽管可以到达程序主窗口，但功能也许还是不可用；</p>
</blockquote>
<p>还是这个<code>CrackMe</code>，将<code>CrackMe</code>倒入<code>OD</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxlfn0d4cj319r0u0tbr.jpg" alt="第一行"></p>
<blockquote>
<p>VB 程序有个特点：入口处都是一个 PUSH 指令，然后一个 CALL 指令；</p>
</blockquote>
<p>发现第一行是一个 PUSH 指令，4C 法就是将 PUSH 的地址加上<code>4C</code>，然后在数据窗口中跟随这个地址；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxlkobm9sj31a80u0tcv.jpg" alt="加上 4C"></p>
<p><code>Ctrl + G</code>跟随地址后，发现这个地址中存储着另外一个地址，选择存储的地址，然后右键选择<code>数据窗口中跟随（DWORD）</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxlsfxheaj319s0u00xh.jpg" alt="跟随 4 字节地址"></p>
<p>跟踪地址来到数据窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxp8l5p0lj31a00u0goo.jpg" alt="结构类似"></p>
<p>这里可以看到两块类似的数据,每块 50(十六进制)个字节的长度,每块数据的第 24(十六进制)个字节处都有一个标志（第一个是 00，第二个是 01）；</p>
<p>该标志指定了代码块（也就是程序启动后要加载的窗体）出现的顺序，先加载 00，也就是我们要去掉的 NAG 窗口，再加载 01，也就是主窗口；</p>
<p>所以，为了去掉<code>烦人的窗口</code>，将此处的两个标志的值互换，即：00 改 01，01 改 00，这样的话 NAG 窗口就永远也没机会出现了，最后将修改保存到文件；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxphhj5cjj30ys0dm74w.jpg" alt="互换值"></p>
<p>接着，运行保存的文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxpknxv21j30nc0m2n0o.jpg" alt="reverse"></p>
<p>直接出现程序主窗体，NAG 窗口被去除；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
        <category>VB 汇总</category>
      </categories>
      <tags>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之分析 N-Code（一）</title>
    <url>/posts/1203909517/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-17">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先运行软件，了解一下程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwwx2zk5ij30cg0j474t.jpg" alt="运行程序"></p>
<p>O, No!</p>
<ul>
<li><p>首先是一个<code>NAG 窗口</code>:</p>
<blockquote>
<p><code>NAG 窗口</code>：软件未注册或软件的试用版经常会弹出一些提示窗口要求注册，这些窗口被称为 nag 窗口，也叫烦人的窗口；</p>
</blockquote>
</li>
<li><p>然后才是软件窗口，要求输入注册码；</p>
</li>
<li><p>输入随机字符点击 OK，一个奇怪的弹窗，应该是 No? Thanks?</p>
</li>
</ul>
</li>
<li><p>将<code>CrackMe</code>倒入<code>OD</code>，开始分析：</p>
<ul>
<li><p>首先，第一件事儿是去掉<code>烦人的窗口</code>：</p>
<p>既然是弹窗，那么它肯定调用了<code>MessageBox</code>这个 API，不过，VB 有专有的 API <code>rtcMsgBox</code>：调用一个消息框，类似于 Windows 里的 MessageBox/A/EXA，此之前一定有个 PUSH 命令将要在消息框中显示的数据压入椎栈；</p>
<ol>
<li><p>既然已经知道了它调用的 API，那还等什么，给<code>rtcMsgBox</code>设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwf5ajmbfj319x0u0ado.jpg" alt="设置断点"></p>
<p>按下<code>Ctrl + G</code>输入<code>rtcMsgBox</code>，然后点击确定，程序会跳转到<code>rtcMsgBox</code>函数的行首，然后双击该行设置断点，并做好备注；</p>
</li>
<li><p>设置好断点后，<code>F9</code>运行程序，程序会中断在断点位置，然后在<code>堆栈窗口</code>跟踪调用位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwfej14e2j31a10u0787.jpg" alt="反汇编窗口中跟随"></p>
</li>
<li><p>来到<code>反汇编窗口</code>，这个时候函数<code>rtcMsgBox</code>已经调用完成，既然找到了调用位置，那怎么能去掉<code>烦人的窗口</code>呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwrwzbi2mj31a40u0q74.jpg" alt="返回位置"></p>
<p>设置好断点，重载并运行程序后，程序中断在预先设置好的断点位置，而下面一行的<code>CALL</code>就是调用<code>rtcMsgBox</code>的位置，如果把这个调用<code>NOP</code>了，是不是就没有<code>NAG 窗口</code>了，听起来蛮靠谱，试一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmws2k2c0gj31a00u0adj.jpg" alt="NOP"></p>
</li>
<li><p><code>NOP</code>了调用<code>rtcMsgBox</code>的<code>CALL</code>后，继续运行程序，但并没有按照预期显示程序主窗口，而是程序结束了，这是怎么回事儿呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmws7fd2l7j319y0u0jus.jpg" alt="程序终止了"></p>
<p>按下<code>-</code>减号键，返回上层位置，把修改的内容保存下来试试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwszp7i1mj31c90u0ag0.jpg" alt="保存到文件"></p>
<p>双击运行保存的程序，没有任何反应，em ～～ 看来程序被玩坏了，此路不通；</p>
</li>
<li><p>重载并运行程序，重新来到<code>反汇编窗口</code>，既然把直接调用函数<code>NOP</code>了不行，那就只能继续运行程序，看看它的上一级调用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwtwz0lpqj319u0u0gq0.jpg" alt="上级调用"></p>
<p>来到上级调用的返回位置，上一行的<code>CALl</code>就是刚才整段代码的调用位置，如果把这个<code>CALl</code>干掉，那么弹窗也就没有了，试一试，但愿程序不被玩儿坏；</p>
<p>在这个<code>CALl</code>的参数的上一行设置断点，重载并运行程序；</p>
</li>
<li><p>程序中断在预定位置，选择下面<code>CALl</code>和它的参数用<code>NOP</code>填充：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwu4tmu4yj319x0u0789.jpg" alt="用NOP填充"></p>
</li>
<li><p>继续运行程序，啊哈，期待已久的程序主窗口终于出现了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwu6csc67j319y0u0adb.jpg" alt="程序主窗口"></p>
<p>主程序出现，说明这个方法可行；</p>
</li>
<li><p>为了后面找码方便，把修改后的程序另存为一个新的程序：终于要和<code>烦人的窗口</code>说拜拜了，至于保存的方法，上面已经说明，不再赘述；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwue6f08gj30fa0hyglz.jpg" alt="NoNAG"></p>
<p>运行修改的程序，嗯，没有<code>NAG 窗口</code>，直接出现程序主窗体，一切 OK；</p>
</li>
</ol>
</li>
<li><p>搞定<code>NAG 窗口</code>后，是时候寻找一下注册码了：</p>
<ol>
<li><p>把修改后的程序倒入<code>OD</code>，然后运行程序，主窗体出现：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwujt8bmmj31a10u0whn.jpg" alt="运行修改程序"></p>
</li>
<li><p>输入随机注册码，但不要点 OK，但不要点 OK，但不要点 OK，重要的事情说三遍：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwunevjelj31a90u0419.jpg" alt="内存访问断点"></p>
<p>接着到<code>内存窗口</code>，在<code>CODE 段</code>设置<code>内存访问断点</code>，然后到程序中点击 OK；</p>
</li>
<li><p>点击 OK 后，程序中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwuq1qlscj31a70u0dj1.jpg" alt="程序中断"></p>
<p>这里的代码看不大懂，不过没关系，也没有找到需要的信息；</p>
</li>
<li><p>继续运行程序，直到看到了随机输入的注册码和字符串比较函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwuupo64mj319x0u0wi4.jpg" alt="字符串比较"></p>
<p>随机输入的字符作为字符串比较函数的参数，那另一个参数毋庸置疑，肯定是真实的注册码；</p>
</li>
<li><p>不过遗憾的是，由于这个软件是西欧字符软件，好多字符无法正确显示，找到了真实的注册码也无法输入，复制也不行，因为系统字符集中没有某些字符：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwv3kqadtj319w0u0jxi.jpg" alt="字符集"></p>
</li>
<li><p>既然无法输入真实注册码，那就只能让任意字符成为注册码了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwvbq3c94j319r0u0wif.jpg" alt="比较不成立"></p>
<p>首先，字符串比较函数的返回结果非 0，说明两个参数不相等，继续向下分析；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmww36rsqtj319z0u0jwe.jpg" alt="向下分析"></p>
<p>把比较的结果从 EAX 拷贝到 EDI 中，然后进行了一系列的操作，然而，如果 EDI 为 0，则这些操作没有任何意义，至于中间夹杂的其他操作可以忽略了，因为没有涉及到 EDI：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmww36rsqtj319z0u0jwe.jpg" alt="操作 EDI"></p>
<p>这里有一个 JE 跳转，上一行代码是<code>TEST DI, DI</code>，如果 EDI 自身为 0，则<code>TEST DI, DI</code>影响 ZF 标志位，ZF 置 1，反之为 0，而恰恰 JE 根据 ZF 标志位跳转，可以看到，程序运行到了这里，ZF 依然为 0，则间接说明了输入的注册码不正确；</p>
<p>既然这个跳转根据比较的结果进行跳转，那就可以确定它是关键跳，如果将 JE 修改为 JMP，是否就能满足<code>让任意字符成为注册码</code>？值得一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwwqklr2hj319v0u0jv1.jpg" alt="修改为 JMP"></p>
<p>修改 JE 为 JMP 后，取消内存访问断点，然后<code>F9</code>运行程序，It’s OK，终于看到了成功弹窗，不过由于字符集的原因，部分字符无法显示；</p>
</li>
<li><p>保存修改到文件，然后输入任意字符：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwwuohw0dj30ca0i4mxh.jpg" alt="成功"></p>
<p>成功的弹窗是 Yes? Thanks?</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
        <category>VB 汇总</category>
      </categories>
      <tags>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之分析 N-Code（二）</title>
    <url>/posts/3794155287/</url>
    <content><![CDATA[<blockquote>
<p>之前分析过这个 CrackMe（参见：VB 调试之分析 N-Code（一）），需要借助修改版的 OD 才能去除 NAG 窗口，在阅读<a href="https://reversecore.com/">逆向工程核心原理</a>一书后，学到了一种新的技巧，记录下来；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-21">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<span id="more"></span>

<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>将<code>CrackMe</code>倒入<code>OD</code>，查找<code>rtcMsgBox</code>并设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpdqgghp6j31b80u0jun.jpg" alt="查找"><br><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpdsakoemj31b40u0jv4.jpg" alt="设置断点"></p>
</li>
<li><p>然后<code>F9</code>运行程序，程序会中断在调用位置，与直接给 API 设置的断点不同，这样设置的断点会中断在调用位置，而给 API 设置的断点会中断在<code>rtcMsgBox</code>函数的行首：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpdxeqg7cj31b20u0n0o.jpg" alt="调用位置"></p>
</li>
<li><p>向上滚动代码，找到函数栈帧，然后设置断点：</p>
<p>至于什么是栈帧？</p>
<p>ESP 始终指向栈的顶端，程序运行中，ESP 寄存器的值随时变化，访问栈中函数的局部变量、参数时，若以 ESP 的值为基准会十分困难，使 CPU 很难引用到准确的位置；</p>
<p>所以，调用函数时，先要把作为基准点（函数起始地址）的 ESP 值保存到 EBP，并维持在函数内部，这样，无论 ESP 如何变化，以 EBP 的值为基准总是能够安全的访问到相关函数的局部变量、参数、返回地址，这就是栈帧；</p>
<p>也就是说，ESP 寄存器承担着栈顶指针的作用，而 EBP 寄存器则负责行使栈帧指针的职能；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpedvtcsej31b40u0tcb.jpg" alt="函数栈帧"></p>
</li>
<li><p>取消其它断点，重载并运行程序，程序会在断点处中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpeifwm5kj31b40u078b.jpg" alt="断点处中断"></p>
<p>然后在<code>堆栈窗口</code>选择<code>反汇编窗口中跟随</code>到调用位置；</p>
</li>
<li><p>给调用位置和返回位置设置<code>F2</code>断点并取消其它断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpemqmyx6j31b40u0q6s.jpg" alt="设置两个断点"></p>
</li>
<li><p>重载并运行程序，程序中断在调用位置设置的断点处：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpepoqti8j31b40u078f.jpg" alt="调用位置栈顶指针"></p>
<p>记录调用位置栈顶指针的地址；</p>
</li>
<li><p><code>F9</code>运行程序，NAG 窗口弹出，点击确定，程序中断在函数的返回位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpeuabiakj31au0u0wil.jpg" alt="返回位置栈顶指针"></p>
<p>记录返回位置栈顶指针的地址；</p>
</li>
<li><p>用返回位置的栈顶指针也就是 ESP 的值减去调用位置 ESP 的值；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpey3glw9j30pk0go0tj.jpg" alt="ESP相减"></p>
<p>以图为例：<code>0012FA10 - 0012FA08 = 8(16 进制)</code>，是不是可以这么理解：在调用函数中使用了 8 个字节的栈内存；</p>
</li>
<li><p>Win32 API 使用的函数调用约定是 stdcall 方式，这种方式的栈内存由被调用者清理，在这里就是由被调用的函数清理，如果在函数的起始位置直接清理栈内存，函数就不会被执行，也就不会弹出 NAG 窗口了；</p>
<p>函数调用约定参见：寄存器小记</p>
</li>
<li><p>重载并运行程序，程序中断在调用位置，<code>F7</code>单步步入到函数内部：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpfnfbtjvj31b50u0wik.jpg" alt="再次中断"></p>
<p>然后来到了 VB 程序类似于交通枢纽的位置，继续<code>F7</code>，跳转到创建 NAG 窗口的函数内部；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpfqj3wzxj31b60u0juw.jpg" alt="交通枢纽"></p>
<p>创建 NAG 窗口的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpfuhpl8ij31b70u041w.jpg" alt="创建 NAG 窗口的函数"></p>
<p>咦，好眼熟啊，是的，这里就是设置程序第 1 个断点的函数，调用<code>rtcMsgBox</code>的函数；</p>
</li>
<li><p>之前的步骤终于派上用场了，根据计算，调用创建 NAG 窗口的函数会使用 8 个字节的栈内存，所以，修改函数的行首，清理栈内存：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpg1bxiquj31b40u0q6s.jpg" alt="清理栈内存"></p>
<p>然后运行程序，没有 NAG 窗口，直接弹出程序主窗体；</p>
</li>
<li><p>保存修改到可执行文件，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpg54qpa0j30f00eut95.jpg" alt="运行程序"></p>
</li>
<li><p>将修改后的 CrackMe 倒入<code>OD</code>，开始处理序列号的问题，然后发现，给<code>rtcMsgBox</code>设置断点后，程序并不会中断，怎么办？</p>
<p>既然程序在输入错误的序列号后会弹出错误弹窗，那么程序内部肯定验证了序列号，那就查找关于字符串比较的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpghdpk83j31b80u0adv.jpg" alt="vbastrcmp"></p>
<p>找到<code>__vbaStrCmp</code>并设置断点，然后<code>F9</code>运行程序；</p>
</li>
<li><p>程序中断在调用<code>__vbaStrCmp</code>的位置，然后，在 EAX 中发现了输入的随机序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpgllvlhaj31bk0u0787.jpg" alt="发现序列号"></p>
<p>既然 EAX 是第 2 参数，那么 ECX 中存放的就是第 1 参数，可能就是真正的序列号；</p>
</li>
<li><p>数据窗口中跟随 ECX 后发现，西欧文字系统无法显示，就是一堆乱码，既然真实注册码无法使用，那有没有可能让任意字符成为注册码，继续向下分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnphe6x02uj31ba0u0q7k.jpg" alt="返回非0"></p>
<p>首先，向下执行一行代码后，EAX 为非 0 值，这里使用的是<code>__vbaStrCmp</code>，所以非 0 说明不相等；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnphegy116j31bd0u0781.jpg" alt="操作EDI"></p>
<p>接着，把返回值拷贝到 EDI 中，进行了一系列操作后，来到了一个跳转，这就很可疑了；</p>
<p>这里对 EDI 进行的一系列操作，如果 EDI 为 0，则没有任何影响，最后的结果是跳转实现，但随机注册码和指定字符串比较，结果肯定不为 0，最终的结果是跳转失败；</p>
<p>按照这个逻辑来推断，这个跳转应该是关键跳转，如何证明呢？修改<code>JE</code>为<code>JMP</code>，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnphla0vxzj31b20u0jvy.jpg" alt="正确弹窗"></p>
<p>修改<code>JE</code>为<code>JMP</code>并运行程序后，弹出提示序列号正确的弹窗，至于为什么这是正确的弹窗，很简单，因为它和错误弹窗不一样；</p>
</li>
<li><p>保存修改到可执行程序，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnphohcvjij30si0cudgg.jpg" alt="成功了"></p>
<p>输入任意字符，点击 OK 后，弹出成功弹窗，结束！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
        <category>VB 汇总</category>
      </categories>
      <tags>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之初识 VB</title>
    <url>/posts/674877238/</url>
    <content><![CDATA[<blockquote>
<p>初识简单了解一下 VB，相信随着深入的学习，对它的了解会更多，理解会更深；</p>
</blockquote>
<h4 id="P-Code-Packed-Code-压缩代码"><a href="#P-Code-Packed-Code-压缩代码" class="headerlink" title="P-Code Packed Code 压缩代码"></a>P-Code Packed Code 压缩代码</h4><ul>
<li>4.0 以前</li>
<li>运行时，动态链接库（DLL）将翻译或解释执行程序中的指令；</li>
<li>解释器 MSVBVM50.DLL 和 MSVBVM60.DLL</li>
</ul>
<h4 id="N-Code-Native-Code-本机代码"><a href="#N-Code-Native-Code-本机代码" class="headerlink" title="N-Code Native Code 本机代码"></a>N-Code Native Code 本机代码</h4><ul>
<li>5.0 以后</li>
<li>改善 VB 的运行速度</li>
<li>但还是需要 MSVBVM60.DLL，因为许多函数本体放在 MSVBVM60.DLL 里面，需要不断地 CALL 其中的函数，不过，这时候的 MSVBVM60.DLL 就不承担解释执行的任务了，只是充当一般的 DLL；</li>
</ul>
<span id="more"></span>

<h4 id="编译器技术"><a href="#编译器技术" class="headerlink" title="编译器技术"></a>编译器技术</h4><ul>
<li>编译器的编译技术可以分为 native－compile（自然编译）与 pcode－compile（伪编译）两种；</li>
<li>自然编译是编译器将高级语言转换为汇编代码，并经链接生成 EXE 程序的过程；</li>
<li>伪编译是编译器将高级语言转换为某种编码后，将能解释、执行此编码的一段程序一同链接，生成 EXE 程序；</li>
<li>伪代码 p-code，最早应该叫做 Pascal-Code，其名称起源于一个 pascal 编译器使用的“中间代码”编译技术。现在一般作为 pseudo-code（伪代码），或 packed-code（压缩代码）简称，此项编译技术的出现，最终导致了“虚拟机”的出现。而微软在其编程工具 basic、c、vb 中都使用了类似的编译技术；</li>
<li>所谓伪代码，其基本工作原理是编译器先把执行程序编译为比 80X86 机器码紧凑得多的中间代码形式，然后在链接时把一个小工作引擎嵌入执行程序中，最后在运行时由此工作引擎把 P-Code 解释为本地机器码实际执行，所以叫做 packed-code；同时又由于此代码并不是最终的机器码形式，实际上是“变形的源代码”，所以也被称为 pseudo-code。依靠 P-code 编译技术，使得编程语言不依赖于机器或操作平台成为可能；</li>
</ul>
<h4 id="VB-的主要数据类型"><a href="#VB-的主要数据类型" class="headerlink" title="VB 的主要数据类型"></a>VB 的主要数据类型</h4><table>
<thead>
<tr>
<th align="center">在函数中的缩写形式</th>
<th align="center">数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">布尔型</td>
</tr>
<tr>
<td align="center">str</td>
<td align="center">字符串型</td>
</tr>
<tr>
<td align="center">i2</td>
<td align="center">双字节整型</td>
</tr>
<tr>
<td align="center">ui2</td>
<td align="center">无符号双字节整型</td>
</tr>
<tr>
<td align="center">i4</td>
<td align="center">长整型</td>
</tr>
<tr>
<td align="center">r4</td>
<td align="center">单精度浮点型</td>
</tr>
<tr>
<td align="center">r8</td>
<td align="center">双精度浮点型</td>
</tr>
<tr>
<td align="center">cy</td>
<td align="center">货币型</td>
</tr>
<tr>
<td align="center">var</td>
<td align="center">变体类型</td>
</tr>
<tr>
<td align="center">fp</td>
<td align="center">浮点型</td>
</tr>
<tr>
<td align="center">cmp</td>
<td align="center">比较</td>
</tr>
<tr>
<td align="center">comp</td>
<td align="center">比较</td>
</tr>
</tbody></table>
<h4 id="VB-常用-API-函数"><a href="#VB-常用-API-函数" class="headerlink" title="VB 常用 API 函数"></a>VB 常用 API 函数</h4><p>数据类型转换类函数:</p>
<table>
<thead>
<tr>
<th align="center">API 函数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">__vbaI2Str</td>
<td align="center">将一个字符串转化为整型</td>
</tr>
<tr>
<td align="center">__vbaI4Str</td>
<td align="center">将一个字符串转化为长整型</td>
</tr>
<tr>
<td align="center">__vbar4Str</td>
<td align="center">将一个字符串转化为单精度浮点型</td>
</tr>
<tr>
<td align="center">__vbar8Str</td>
<td align="center">将一个字符串转化为双精度浮点型</td>
</tr>
<tr>
<td align="center">VarCyFromStr</td>
<td align="center">将字符串转化为货币类型</td>
</tr>
<tr>
<td align="center">VarBstrFromI2</td>
<td align="center">将整型数据转化为字符串</td>
</tr>
</tbody></table>
<p>数据移动:</p>
<table>
<thead>
<tr>
<th align="center">API 函数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">__vbaStrCopy</td>
<td align="center">将一个字符串拷贝至指定内存单元中</td>
</tr>
<tr>
<td align="center">__vbaStrMove</td>
<td align="center">将一个字符串移动到指定内存单元中</td>
</tr>
<tr>
<td align="center">__vbaVarCopy</td>
<td align="center">将一个变量的值拷贝至指定内存单元中</td>
</tr>
<tr>
<td align="center">__vbaVarMove</td>
<td align="center">将一个变量的值移动到指定内存单元中</td>
</tr>
</tbody></table>
<p>数学运算:</p>
<table>
<thead>
<tr>
<th align="center">API 函数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">__vbavaradd</td>
<td align="center">两个变量值相加</td>
</tr>
<tr>
<td align="center">__vbavarsub</td>
<td align="center">第一个变量减去第二个变量</td>
</tr>
<tr>
<td align="center">__vbavarmul</td>
<td align="center">两个变量值相乘</td>
</tr>
<tr>
<td align="center">__vbavaridiv</td>
<td align="center">第一个变量除以第二个变量,得到一个整数商</td>
</tr>
<tr>
<td align="center">__vbavarxor</td>
<td align="center">两个变量值做异或</td>
</tr>
<tr>
<td align="center">__vbavardiv</td>
<td align="center">除</td>
</tr>
<tr>
<td align="center">__vbavarmod</td>
<td align="center">求余</td>
</tr>
<tr>
<td align="center">__vbavarneg</td>
<td align="center">取负</td>
</tr>
<tr>
<td align="center">__vbavarpow</td>
<td align="center">指数</td>
</tr>
</tbody></table>
<p>程序设计杂项:</p>
<table>
<thead>
<tr>
<th align="center">API 函数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">__vbavarfornext</td>
<td align="center">这是 VB 程序里的循环结构，For…Next…(Loop)</td>
</tr>
<tr>
<td align="center">__vbafreestr</td>
<td align="center">释放掉指定字符串所占的内存，也就是把指定内存单元中字符串抹掉</td>
</tr>
<tr>
<td align="center">__vbafreeobj</td>
<td align="center">释放 VB 的一个对象(一个窗口或者一个对话框)所占的内存，也就是把指定内存中窗口或者对话框对象抹掉</td>
</tr>
<tr>
<td align="center">__vbastrvarval</td>
<td align="center">获取字符串指定的子串</td>
</tr>
<tr>
<td align="center">multibytetowidechar</td>
<td align="center">将多字节字符串转化为宽字节字符串</td>
</tr>
<tr>
<td align="center">rtcMsgBox</td>
<td align="center">弹出一个消息框，类似于 WINDOWS API 中的 MessageBoxA/MessageBoxExA 函数</td>
</tr>
<tr>
<td align="center">__vbavarcat</td>
<td align="center">将两个变量值相连，如果是两个字符串，就直接连接在一起</td>
</tr>
<tr>
<td align="center">__vbafreevar</td>
<td align="center">释放变量所占的内存空间，也就是把指定内存中的变量值抹掉</td>
</tr>
<tr>
<td align="center">__vbaobjset</td>
<td align="center">给对象赋值或者实例化</td>
</tr>
<tr>
<td align="center">__vbaLenBstr</td>
<td align="center">获取一个字符串的长度，注意：VB 中一个汉字的长度也是 1 个字节</td>
</tr>
<tr>
<td align="center">rtcInputBox</td>
<td align="center">显示一个 VB 标准的输入窗口，类似于 WINDOWS API 函数 GetWindowTextA/GetDlgItemTextA</td>
</tr>
<tr>
<td align="center">__vbaNew</td>
<td align="center">显示一个对话框，类似于 WINDOWS API 函数 DialogBox</td>
</tr>
<tr>
<td align="center">__vbaNew2</td>
<td align="center">显示一个对话框，类似于 WINDOWS API 函数 DialogBoxParamA</td>
</tr>
<tr>
<td align="center">rtcTrimBstr</td>
<td align="center">将字符串左右两边的空格去掉</td>
</tr>
<tr>
<td align="center">__vbaEnd</td>
<td align="center">结束进程</td>
</tr>
<tr>
<td align="center">__vbaLenVar</td>
<td align="center">获取一个变量的大小</td>
</tr>
<tr>
<td align="center">rtcMidCharVar</td>
<td align="center">从字符串中间获取相应的字符，VB 中的 MID 函数，用法 MID(“字符串”,“开始的位置”,“取几个字符”)</td>
</tr>
<tr>
<td align="center">rtcLeftCharVar</td>
<td align="center">从字符串左边取相应字符，VB 中的用法：Left(“字符串”,”从左边开始取几个字符”)</td>
</tr>
<tr>
<td align="center">rtcRightCharVar</td>
<td align="center">从字符串右边取相应字符，VB 中的用法：Right(“字符串”,”从右边开始取几个字符”)</td>
</tr>
<tr>
<td align="center">rtcDir</td>
<td align="center">获取当前路径</td>
</tr>
<tr>
<td align="center">__vbaFileOpen</td>
<td align="center">打开文件</td>
</tr>
</tbody></table>
<p>比较函数:</p>
<table>
<thead>
<tr>
<th align="center">API 函数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">__vbastrcomp</td>
<td align="center">比较两个字符串，类似于 WINDOWS API 函数 lstrcmp</td>
</tr>
<tr>
<td align="center">__vbastrcmp</td>
<td align="center">比较两个字符串，类似于 WINDOWS API 函数 lstrcmp</td>
</tr>
<tr>
<td align="center">__vbaFpCmpCy</td>
<td align="center">浮点变量值与货币变量值进行比较</td>
</tr>
<tr>
<td align="center">__vbavartsteq</td>
<td align="center">比较两个变量值是否相等</td>
</tr>
<tr>
<td align="center">__vbavartstNe</td>
<td align="center">判断两个变量值是否不相等</td>
</tr>
<tr>
<td align="center">__vbavartstGe</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">__vbavartstGt</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">__vbavartstLe</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">__vbavartstLt</td>
<td align="center">小于</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Windows</category>
        <category>VB 汇总</category>
      </categories>
      <tags>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>修复 IAT 之初探</title>
    <url>/posts/452711586/</url>
    <content><![CDATA[<blockquote>
<p>之前尝试了手动修复 IAT，了解修复的原理后，本次记录使用工具修复的过程；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="https://upx.github.io/">UPX</a>，感谢 🙏 开源；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-3">PETools</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>使用 UPX 加密 CM，然后导入 OD；</p>
</li>
<li><p>使用栈平衡法定位并跳转至 OEP，接下来在操作过程中不能关闭 OD 且程序需停留在 OEP 位置；</p>
</li>
<li><p>打开 PETools，将内存数据 Dump 出来并保存至可执行文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzu6nvencj31500u0tbv.jpg" alt="PETools"></p>
<p>默认保存为 dumped.exe；</p>
</li>
<li><p>打开 ImportREC 选择 CM 进程：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzuc3dogbj30wm0omgmq.jpg" alt="选择 CM 进程"></p>
<p>选择后，日志窗口会提示关联模块获取完成：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzudwpewvj30wo0omwfh.jpg" alt="关联模块获取"></p>
<p>然后在下方填写 dumped.exe 程序 OEP 的 RVA，以及 IAT 的起始位置（RVA）和尺寸：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzuqyt15wj31e40u00yt.jpg" alt="计算 RVA"></p>
<p>根据 VA 和 RVA 的转换公式计算如下（注意都是 16 进制哦）：</p>
<p>OEP 的 RVA = 401000 - 400000 = 1000；</p>
<p>IAT 的 RVA = 403184 - 400000 = 3184；</p>
<p>IAT 的 Size = 40328C - 403184 = 108；</p>
<p>填写 ImportREC 的选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzux3fy14j310u0ou75d.jpg" alt="填写 ImportREC"></p>
<p>然后点击<code>Get Imports</code>，开始获取输入表的内容：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzv149j6vj30wi0oqgn3.jpg" alt="获取内容"></p>
<p>获取完成后，需要检查获取的数据是否有效，如果 valid 为 NO，需要手动检查是否为无用信息，否则需要修正后重新获取（当前不涉及重定向）；</p>
<p>接着点击<code>Fix Dump</code>选项，在弹出窗口选择 dumped.exe，用于修复；</p>
</li>
<li><p>修复后的程序可以正常运行，但导入 OD 后依然会提示入口点超出代码段范围：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzv6dfug9j313m06sjrl.jpg" alt="入口点超出代码段范围"></p>
<p>修改代码段的起始地址（RVA）即可：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzvbrofegj31dm0u0gp3.jpg" alt="修改代码段的起始地址"></p>
<p>然后选中修改并保存到可执行文件，完工！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>UPX</tag>
        <tag>IAT</tag>
      </tags>
  </entry>
  <entry>
    <title>修复 IAT 之剔除无用数据</title>
    <url>/posts/1928138386/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-3">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 OD 插件 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-1">OllyDump</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p>Import REConstructor（简称 ImportREC）是目前最好用的输入表重建工具，它可以从杂乱的 IAT 中重建一个输入表；</p>
<p>要运行 ImportREC，必须满足以下条件：</p>
<ul>
<li>目标文件已完全被 Dump 并保存为另外一个文件；</li>
<li>目标文件必须正在运行；</li>
<li>事先找到目标程序真正的 OEP 或知晓 IAT 的偏移量和大小；</li>
</ul>
<ol>
<li><p>将 CM 导入 OD，使用栈平衡法找到 OEP，并停留在 OEP（目标文件必须正在运行）；</p>
</li>
<li><p>使用 OllyDump 将内存数据 Dump 出来并保存至可执行文件（目标文件已完全被 Dump 并保存为另外一个文件）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0n79lxu4j31dt0u0jvk.jpg" alt="OllyDump"></p>
<p>在插件菜单选择 OllyDump 或右键菜单选择转存调试的进程都可以，然后确认 Dump 选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0n2xcja2j31e00u0djx.jpg" alt="Dump"></p>
<p>插件 Dump 数据方面没有问题，但重建 IAT 功能不够强大，因此，取消勾选重建输入表选项；</p>
</li>
<li><p>在 OD 中定位到 IAT，查看起始 RVA 以及结束 RVA，计算 Size：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0nfnw56mj310w0o8ta0.jpg" alt="Size"></p>
<p>在输入表中，一个 DLl 对应于一份 IAT，多个 IAT 之间一般以一个 DWORD 的 0 隔开；</p>
<p>此处 CM 的 IAT 之间被添加了无效信息；</p>
</li>
<li><p>用 ImportREC 打开 CM 进程，填写 OEP（RVA）以及 IAT 的起始地址（RVA）和大小，然后点击获取：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0no2nckij30we0oojsj.jpg" alt="ImportREC"></p>
<p>获取输入表后，可以看到有一组<code>valid：NO</code>的数据，这就是两个 IAT 之间的无效信息：</p>
<p>确认是无效信息后，在无效信息上右键菜单执行“Cut thunk(s)”命令：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0nzzqto3j31e10u0aeq.jpg" alt="Cut thunk(s)"></p>
<p>剔除无效信息后，数据还是不正确：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0o4b5w5kj31dy0u078u.jpg" alt="数据还是不正确"></p>
<p>因为 CM 中调用了 3 个 DLL，分别是 user32.dll、kernel32.dll 以及 ntdll.dll；</p>
<p>而 ImportREC 只找到了两个，看来这玩意儿也不好使啊；</p>
<p>NoNoNo，它找到了三个，但因为 ntdll 中的 API 混合在 kernel32 的 API 中，所以被替换了，看 log 窗口的提示信息；</p>
<p>此时如果直接修复 dump.exe，在当前环境（xp）下是可以运行的，但可能会在其它 OS 中遇到兼容性问题；</p>
<p>所以还需要修复 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0olk6qhmj31lk0qu0v8.jpg" alt="修复"></p>
<p>在获取的信息中，双击对应的 API，在弹出的函数编辑框中修改对应的 DLL 名称和 API 名称；</p>
<ul>
<li>查看 RVA 来获取对应的函数比较直观，如：00001200 和 00001210；</li>
<li>双击函数行打开函数编辑框；</li>
<li>在编辑框中首先选择 DLL 名称，然后可以在下面的输入框中搜索指定的函数名，接着选择函数，点击 OK 确认修改；</li>
<li>修改完成后，依然显示的是未修改的状态，但修复程序后，显示已修改；</li>
</ul>
<p>修改完成后，点击<code>Fix Dump</code>，选择需要修复的程序，完成修复：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0p1ijxbfj31e20u0ada.jpg" alt="完成修复"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>IAT</tag>
        <tag>ASPack</tag>
      </tags>
  </entry>
  <entry>
    <title>修复 IAT 重定向（一）</title>
    <url>/posts/228051751/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-4">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 OD 插件 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-1">OllyDump</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="输入表加密"><a href="#输入表加密" class="headerlink" title="输入表加密"></a>输入表加密</h4><p>在脱壳过程中，输入表修复是一个重点，修复关键是得到未加密的 IAT，对与 IAT 相关的位置设断，从而找到外壳处理 IAT 的代码，然后找对策；</p>
<p>加壳程序处理输入表有以下几种情况：</p>
<ol>
<li><p>完整地保留了输入表，外壳加载时未对 IAT 加密；</p>
<p>当外壳解压数据时，完整的输入表会在内存中出现；</p>
<p>外壳用显式装载 DLL 的方式获得各函数的地址，并将地址填充到 IAT 中；</p>
<p>脱壳时，可以在内存映像文件刚生成时抓取输入表，此时，外壳还没来得及破坏原始的输入表；</p>
<p>此类壳有 ASPack、PECompact 等；</p>
</li>
<li><p>完整地保留了原输入表，当外壳加载时对 IAT 进行加密处理</p>
<p>当外壳解压数据时，完整的输入表会在内存中出现；</p>
<p>外壳用显式装载 DLL 的方式获得各函数的地址，并对这些地址进行处理（即 Hook API）；</p>
<p>最后将 Hook API 的外壳代码的地址填充到 IAT 中；</p>
<p>由于 IAT 已经被加密，直接使用 ImportREC 是无法重建输入表的，但可以在外壳还没来得及加密 IAT 时抓取输入表，或者跳过对 IAT 进行加密的代码；</p>
<p>此类壳有 tElock 等；</p>
</li>
<li><p>加壳时破坏了原输入表，外壳装载时未对 IAT 进行加密处理；</p>
<p>外壳已经完全破坏原输入表，在外壳刚解压的映像文件中的是输入函数的字符串；</p>
<p>外壳用显式装载 DLL 的方式获得这些函数的地址，直接将函数地址填充到 IAT 中；</p>
<p>因为 IAT 未加密，所以在脱壳时可以用 ImportREC 根据 IAT 重建一个输入表；</p>
<p>此类壳有 UPX 等；</p>
</li>
<li><p>加壳时破坏了原输入表，装载外壳时对 IAT 进行加密处理；</p>
<p>如果外壳已经完全破坏了原输入表，外壳将用显式装载 DLL 的方式获取各函数地址，并对地址进行处理（即 Hook API），最后将 Hook API 的外壳代码填充到 IAT 中；</p>
<p>在脱壳时，不仅可以利用 ImportREC 的一些插件来对付这些加密的 IAT，也可以修改外壳处理输入函数地址的代码，使其生成的 IAT 不被加密，然后用 ImportREC 重建输入表；</p>
<p>此类壳有 ASProtect 等；</p>
</li>
</ol>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol start="0">
<li><p>本次 CM 为第 2 种情况， tElock 壳；</p>
</li>
<li><p>将 CM 导入 OD，可以使用<code>最后一次异常法</code>或<code>编译语言特点法</code>（GetVersion）来到达 OEP，<code>栈平衡法</code>和<code>内存访问法</code>无法到达 OEP，原因是有硬件断点和 CC 断点检测；</p>
</li>
<li><p>到达 OEP 后，定位 IAT，然后查看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go15dgjpqcj31du0u0q6n.jpg" alt="OEP"></p>
<p>可以看到 IAT 中间有大段的未知数据，但这些数据所在的区段是存在的，可能不是无效数据；</p>
<p>如果不是无效数据，既然 IAT 中有加密的函数，也有未加密的函数，那么外壳程序中一定会有判断和跳转来分别处理这些函数；</p>
</li>
<li><p>记录当前区段信息，然后重载程序进行比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go15jrtkd8j31e60u0jv6.jpg" alt="进行比较"></p>
<p>可以看到，程序载入 OD 后，在没有运行的情况下，其它区段是不存在的，也就是说，多出来的区段是由外壳生成的；</p>
<p>所以，IAT 中处于这些区段的未知数据应该不是无效信息，可能是被加密了（Hook API）；</p>
</li>
<li><p>再次来到 OEP，通过查看代码也可以确认这些数据不是无效信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go15tb6s9aj31e40u0dke.jpg" alt="确认"></p>
<p>可以看到，指令中有 CALL 指向了 IAT 中的未知数据，如果是无效信息，这是不成立的；</p>
<p>单步步入到 CALL，是否能获得有用信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go16406ucvj31dz0u0q6l.jpg" alt="单步步入"></p>
<p>也就是说，这个 CALL 其实是调用了 kernel32 中的 GetVersion 函数，而 460ADC 中 存储的未知信息就是 Hook API 的地址；</p>
</li>
<li><p>确认这些未知数据是否无效的终极大招是尝试一下：</p>
<p>使用 OllyDump 将内存中的数据 Dump 下来并保存到可执行文件；</p>
<p>然后使用 ImportREC 获取并剔除未知数据后修复程序，程序并不能运行，所以这些数据不是无效的，而是加密的；</p>
</li>
<li><p>既然 IAT 中有加密的函数也有未加密的函数，如果设置写入断点，能否获取到外壳处理 IAT 的关键代码呢？值得一试：</p>
<ul>
<li>以 IAT 表中第 1 个未加密的函数 ADVAPI32.RegCloseKey 为例，写入地址为 00460818，写入数据为 77DA6C27；</li>
<li>还需要一个加密的函数，以 kernel32.GetVersion 为例，这个是当前已知的加密函数，写入地址为 00460ADC，写入数据为 00A206F7；</li>
</ul>
<ol>
<li><p>重载程序后，在数据窗口 goto 到 00460818 位置，设置内存写入断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go16u4uce7j31e20u0dk9.jpg" alt="00460818"></p>
<p>程序会中断多次，但通过查看相关信息，都不是关键位置，直到中断在此处；</p>
<p>这里的指令执行后，会将 EAX 中的数据拷贝至 EDI，而 EAX 中的数据就是对应的 IAT 中的数据 77DA6C27，而 EDI 对应的则是 IAT 中的写入地址 00460818；</p>
<p>记录当前指令的地址，然后 F8 单步执行程序，来到起始位置，记录起始地址；</p>
</li>
<li><p>重载程序，在数据窗口 goto 到 00460ADC 位置，设置内存写入断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1755o8daj31dy0u0n1i.jpg" alt="00460ADC"></p>
<p>同样的流程后，程序来到了相似的位置且提示窗口和寄存器窗口都显示了相关信息，写入地址为 00460ADC，写入数据为 00A206F，也是 IAT 中对应的数据；</p>
<p>而且两次中断指令的位置很接近，应该在同一个函数逻辑中，F8 单步运行程序，来到起始位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go179hoeugj31dv0u0wi7.jpg" alt="起始地址"></p>
<p>对比两次的起始地址相同，确认此处为外壳加密 IAT 的关键代码；</p>
</li>
<li><p>分析代码后，确认此处为关键跳转，修改为 JMP，然后给代码段设置内存访问断点并取消其它断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go17na87jbj31e40u00x9.jpg" alt="关键跳转"></p>
<p>到达 OEP 后定位 IAT，然后查看数据：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go19ayfjaqj31ds0u0goz.jpg" alt="查看 IAT"></p>
<p>可以看到，断点之后的所有未知数据已经解密了，说明前面修改的跳转确实为关键跳转；</p>
</li>
</ol>
</li>
<li><p>重载程序，在反汇编窗口中跟随到关键代码的起始地址，发现 goto 到此处的指令与运行到此处的指令不一致，看来，外壳程序是边运行边解压；</p>
</li>
<li><p>接下来就是获取完整的原程序 IAT 了，由于不知道外壳程序会先解密哪个 IAT，所以给 IAT 的所有字节设置内存写入断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go19nbcutej31e40u0djq.jpg" alt="整个 IAT 设置内存写入断点"></p>
<p>第 1 次中断是访问 IAT 的起始地址，在 CPU 窗口 goto 到关键代码的起始地址，发现代码已经解压恢复了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go19qknla0j31du0u00xd.jpg" alt="解压恢复"></p>
<p>修改关键跳转为 JMP，取消所有断点并给代码段设置内存访问断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go19u06d49j31dy0u0whu.jpg" alt="全部恢复了"></p>
<p>到达 OEP 后查看 IAT 已经全部解密了；</p>
</li>
<li><p>使用 ImportREC 获取解密后的输入表，然后修复 dumped.exe：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go19whjav1j30wk0oq75m.jpg" alt="ImportREC"></p>
<p>全部获取到了，没有无效信息；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go19yinf6pj31dq0u0whv.jpg" alt="运行正常"></p>
<p>程序正常运行，且导入 OD 后查看 IAT 也正常，脱壳完成；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>IAT</tag>
        <tag>tElock</tag>
      </tags>
  </entry>
  <entry>
    <title>修复 IAT 重定向（二）</title>
    <url>/posts/3434170335/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-6">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-3">PETools</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>将 CM 导入 OD，使用<code>内存访问定位法</code>到达 OEP；</p>
</li>
<li><p>到达 OEP 后跟随任意 CALL 定位 IAT，发现 IAT 中有部分未知数据：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go23yjs5xnj31ds0u0aed.jpg" alt="加密了"></p>
<p>通过跟随部分地址后确定不是无效数据，而是被部分 IAT 被重定向了；</p>
</li>
<li><p>记录 OEP 的 RVA，IAT 起始地址 RVA 和结束地址 RVA，计算 Size：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go245belssj31e70u0gq6.jpg" alt="记录 RVA"></p>
<p>OEP 的 RVA 为 271B0；<br>IAT 的起始 RVA 为：60818；<br>IAT 的结束 RVA 为：60F28；<br>IAT 的 Size = 60F28 - 60818 = 710；</p>
</li>
<li><p>使用 PETools 将内存数据 Dump 并保存为可执行文件；</p>
</li>
<li><p>重载程序，给 IAT 的起始地址 00460818 设置内存写入断点，运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go24d39nuyj31dq0u0gq1.jpg" alt="元数据写入"></p>
<p>程序中断后，可以看到当前写入 IAT 起始地址的数据与到达 OEP 后 IAT 中的数据不一致；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go24l458usj31dw0u0qai.jpg" alt="执行 1 行"></p>
<p>执行当前指令后，查看相关数据，发现当前写入的是函数字符串指针，而到达 OEP 后却是重定向数据，说明外壳在加载过程中对 IAT 进行了处理；</p>
</li>
<li><p>继续向下执行指令：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go24sy4g8ej31e20u0gqa.jpg" alt="加密了"></p>
<p>执行当前指令后，00460818 中存放的函数字符串指针被替换为 Hook API 数据，所以当前位置是关键代码；</p>
</li>
<li><p>找到关键代码后，为了不让外壳处理 IAT，需要跳过，上面的跳转是关键跳转：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go24wacrjwj31dt0u0tch.jpg" alt="关键跳转"></p>
<p>多个跳转嵌套，弯弯绕，如果只是为了不让外壳加密程序，是否可以修改当前指令为无用指令（花指令）呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go252malcjj31dy0u0wiu.jpg" alt="修改关键指令"></p>
<p>既然要重定向部分 IAT，加密操作肯定是循环，So，单步执行代码重新来到关键位置，修改指令；</p>
</li>
<li><p>修改完成后，取消内存断点，并且给代码段设置断点（为了到达 OEP），然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go25cgldhcj31du0u0jwg.jpg" alt="错误弹窗"></p>
<p>运行程序后产生一个异常，同时，查看 IAT，发现断点之后的同一个 DLL 中的数据没有被加密，而其它 DLL 中却还有加密数据，那么 IAT 起始地址应该不是外壳写入的第 1 个地址；</p>
<p><code>Shift + F9</code>忽略异常后，程序终止运行，应该是外壳有检测机制，检测是否修改了代码，且检测机制位于外壳处理IAT之后，因为之前没有修改过代码；</p>
</li>
<li><p>重载程序，给 IAT 所有内存地址设置内存写入断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go25gk56cuj31e20u0adn.jpg" alt="设置内存写入断点"></p>
<p>然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go25kyfvsjj31dt0u0n1n.jpg" alt="460E8C"></p>
<p>程序中断后，通过查看提示信息发现，00460E8C 才是外壳写入的第 1 个地址；</p>
</li>
<li><p>找到并修改关键指令：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go25mhjlrbj31e00u078c.jpg" alt="找到并修改关键指令"></p>
<p>取消 IAT 的内存写入断点并给代码段设置内存访问断点，然后运行程序；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go25qqeq6wj31e40u0n1k.jpg" alt="还是弹窗"></p>
<p>依然有异常弹窗，不过查看 IAT 已经全部正常了，那还等什么？</p>
</li>
<li><p>使用 ImportREC 获取输入表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go25t9lt7hj30wk0oqabe.jpg" alt="ImportREC"></p>
<p>获取的输入全部有效，然后修复程序；</p>
</li>
<li><p>程序可以运行，将程序导入 OD，检查 IAT：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go269k3fw5j31dz0u0jv9.jpg" alt="检查 IAT"></p>
<p>IAT 正常，脱壳完成！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>IAT</tag>
        <tag>Yodas Crypter</tag>
      </tags>
  </entry>
  <entry>
    <title>内存访问定位 OEP</title>
    <url>/posts/3449356463/</url>
    <content><![CDATA[<blockquote>
<p>OEP：当外壳保护的程序运行时，会先执行外壳程序，外壳程序负责在内存中把原程序解压、还原，并把控制权还给解压后的真正程序，再跳到原来程序的入口点，这个解压后真正程序的入口点称为 OEP（Original Entry Point，原始入口点）；</p>
<p>EP：与 OEP 对应的是 EP（Entry Point，入口点），无壳程序的 EP 与 OEP 相同，加壳程序的 EP 是壳的入口点，而不是原程序的入口点；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-1">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><h4 id="使用改版-OD-到达-OEP"><a href="#使用改版-OD-到达-OEP" class="headerlink" title="使用改版 OD 到达 OEP"></a>使用改版 OD 到达 OEP</h4><ol>
<li><p>此方法来自<a href="http://xuepojie.com/">SharkHeng</a>；</p>
</li>
<li><p>将 CM 导入 OD 后，会弹出警告，提示入口点超出代码段范围，这是因为当前 EP 指向外壳部分，而不是代码段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw2w2pc78j31cg06u0sz.jpg" alt="英文版"></p>
<p>再来个中文版（感谢汉化 OD 的大佬）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw2w4uhjmj312w06sdg1.jpg" alt="中文版"></p>
<p>虽然弹窗可以在 OD 设置中关闭，但弹窗也是一件好事儿，弹出这种窗口就是提示我们程序加壳了；</p>
</li>
<li><p>既然提示 EP 不在代码段，那就来到内存窗口，查看各区段范围：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw37zkq86j31a50u0aeh.jpg" alt="各区段范围"></p>
<p>可以看到，当前 EP 为 00413000，而代码段的范围是：00401000 ～ 00404FFF，确实不在这个范围，所以才会有一开始的弹窗；</p>
</li>
<li><p>在代码段（.text）设置内存访问断点，然后<code>F9</code>运行程序：</p>
<p>加壳程序在运行时，会将原程序解压、还原，控制权交还，然后原程序执行，此时，就会触发<code>内存执行断点</code>，从而产生中断；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw3gh6rdoj314w0iuq3l.jpg" alt="产生中断"></p>
<p>中断位置的代码看起来像是数据，不过很有规律，按下<code>Ctrl + A</code>，分析程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw3k3n4ftj31a00u0ad9.jpg" alt="分析程序"></p>
<p>分析之后的代码就正常了，开始位置是生成栈帧的指令，表示函数要开始执行了，而且，当前 EIP 也处于代码段；</p>
</li>
</ol>
<h4 id="使用原版-OD-到达-OEP"><a href="#使用原版-OD-到达-OEP" class="headerlink" title="使用原版 OD 到达 OEP"></a>使用原版 OD 到达 OEP</h4><ol>
<li><p>此方法来自<a href="https://bbs.pediy.com/forum-99.htm">加密解密</a>第 16 章：16.2.2；</p>
</li>
<li><p>将 CM 导入原版 OD，打开内存窗口，在代码段（.text）以及相邻的只读数据段（.rdata）设置<code>F2</code>断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw3usmmfwj31dv0u0771.jpg" alt="设置`F2`断点"></p>
<p>.rdata 设置的断点不是必须的，也可以在其它区段设置断点（外壳所在区段除外）；</p>
<p>此处设置断点的意义是：加壳程序运行时，会依次解压各区段，所以，对后面的其它区段设置断点，如果程序在 .text 中断后再次中断，说明代码段已解压完毕；</p>
</li>
<li><p>运行程序，首先中断在 .text：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw464c4ryj31dw0u00x9.jpg" alt="中断在 .text"></p>
<p>此时中断说明将要对代码段进行操作了；</p>
</li>
<li><p>再次运行程序，程序中断在 .rdata：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw48ao7ibj31dx0u0td5.jpg" alt="中断在 .rdata"></p>
<p>通过查看内存窗口知道，代码段的范围是：00401000 ～ 00404FFF；</p>
<p>而当前将要访问的位置是：00405000，不在代码段范围内，也就说明对代码段的操作结束了；</p>
</li>
<li><p>再次来到内存窗口，对代码段设置<code>F2</code>断点，然后运行程序：</p>
<p>这里设置断点的意义是：既然外壳对代码段的解压、还原已经结束了，如果再次访问代码段的话，就是程序执行的时候；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw4d6kf2lj31dw0u041w.jpg" alt="程序中断在 OEP"></p>
<p>中断位置与方法一一致；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>基址重定位</title>
    <url>/posts/4077178284/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li>PE 查看工具为<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-2">LoadPE</a>，来自互联网；</li>
<li><code>WinHex</code>来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<span id="more"></span>

<h4 id="基址重定位的概念"><a href="#基址重定位的概念" class="headerlink" title="基址重定位的概念"></a>基址重定位的概念</h4><blockquote>
<p>基址重定位是指 PE 文件无法加载到 ImageBase 所指的位置，而是被加载到其它地址时所发生的一系列的处理行为；</p>
</blockquote>
<p>当链接器生成 PE 文件时，会假设这个文件在执行时会被装载到默认的基地址处，即 ImageBase 所指的地址处；</p>
<p>如果载入时将 ImageBase 默认的值作为基地址写入，则不需要重定位；</p>
<p>如果载入时 PE 文件被装载到虚拟内存的另一个地址中，此时，链接器登记的地址就是错误的，这时就需要用重定位表来调整；</p>
<p>在 PE 文件中，重地位表往往单独作为一块，用<code>.reloc</code>表示；</p>
<p>对 EXE 文件来说，每个文件总是使用独立的虚拟地址空间，且创建好线程后，EXE 文件会首先加载到内存，所以 EXE 总是能够按照基址载入，这意味着 EXE 文件无需考虑重定位的问题（不需要重定位信息）；</p>
<p>对 DLL 文件来说，因为多个 DLL 文件使用宿主 EXE 文件的地址空间，不能保证载入地址没有被其它 DLL 使用，所以 DLL 文件中必须包含重定位信息；</p>
<p>但是，Windows Vista 之后的版本引入了 ASLR 安全机制，每次运行 EXE 文件都会被加载到随机地址，这样大大增强了系统安全性；</p>
<p>ASLR 机制也适用于 DLL/SYS 文件，对于各 OS 的主要系统 DLL，根据不同版本会分别赋予不同的 ImageBase 地址；</p>
<h5 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h5><p>ASLR（Address Space Layout Randomization，地址空间布局随机化）是一种针对缓冲区溢出的安全保护技术，微软从 Windows Vista 开始采用该技术；</p>
<p>在以前的 OS 中，根据 OS 版本的不同，特定 DLL 总是会加载到固定地址，所以大部分安全漏洞（一般为内存缓冲区溢出）只出现在特定 OS、特定模块、特定版本中，漏洞利用代码（exploit code）会在特定内存地址中以硬编码形式编入，因此，微软采用 ASLR 技术来增加恶意用户编写漏洞利用代码的难度，从而降低利用 OS 安全漏洞破坏系统的风险；</p>
<p>借助 ASLR 技术，PE 文件每次加载到内存中的起始地址都会随机变化，并且每次运行程序时相应进程的栈以及堆的起始地址也会随机变化，也就是说，每次 EXE 文件运行时加载到进程内存的实际地址都不同，最初加载 DLL 文件时装载到内存中的实际地址也是不同的；</p>
<p>但是，并不是所有可执行文件都会自动应用 ASLR 技术，要应用 ASLR 技术，必须满足两个条件：</p>
<ul>
<li>OS 的内核版本必须为 6 以上，即系统版本不低于 Windows Vista（Kernel Version 6）；</li>
<li>使用的编程工具要支持 /DYNAMICBASE 选项；</li>
</ul>
<p>应用 ASLR 技术的 PE 文件会增加 1 个名为<code>.reloc</code>的节区，它是编译时由编译器生成并保留在可执行文件中的，PE 文件被加载到内存时，该节区被用作重定位的参考，它不是 EXE 文件运行时的必须部分，可以从 PE 文件中删除，但是，由于 DLL 文件总是需要重定位，所以在 DLL 文件中不可将其删除；</p>
<p>应用 ASLR 技术的 PE 文件，其 IMAGE_FILE_HEADER（映像文件头）结构中的 Characteristics 字段将缺少 IMAGE_FILE_RELOCS_STRIPPED 标志（特征值为：0001），但 NumberOfSections 字段会增加 1；</p>
<p>应用 ASLR 技术的 PE 文件，其 IMAGE_OPTIONAL_HEADER（可选映像头）结构中的 DllCharacteristics 字段会设置 IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE（特征值为：0040）标志；</p>
<p>若要删除 ASLR 功能，只需将 DllCharacteristics 字段设置的 IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE（特征值为：0040）标志置 0 即可；</p>
<h5 id="基址重定位的处理"><a href="#基址重定位的处理" class="headerlink" title="基址重定位的处理"></a>基址重定位的处理</h5><p>PE 格式不参考外部 DLL 或模块中的其它区块，而是把文件中所有可能需要修正的地址放在一个数组中；</p>
<p>如果 PE 文件不在首选的地址载入，那么文件中的每个定位都需要被修正；</p>
<p>对加载器来说，它不需要知道关于地址使用的任何细节，只要知道有一系列的数据需要以某种一致的方式来修正就可以了；</p>
<h4 id="基址重定位表"><a href="#基址重定位表" class="headerlink" title="基址重定位表"></a>基址重定位表</h4><p>基址重定位表（Base Relocation Table）位于一个<code>.reloc</code>区块内，基址重定位表地址位于 PE 头的 DataDirectory 数组的第 6 个元素（索引为 5），即 IMAGE_DIRECTORY_ENTRY_BASERELOC(IMAGE_NT_HEADERS/IMAGE_OPTIONAL_HEADER/IMAGE_DATA_DIRECTORY[5])条目；</p>
<p>基址重定位数据采用类似按页分割的方法组织，是由许多重定位块串接而成的；</p>
<p>每个块存放 4KB（1000）的重定位信息，每个重定位数据块的大小必须以 DWORD（4 字节）对齐；</p>
<p>基址重定位表是 IMAGE_BASE_RELOCATION 结构体数组；</p>
<p>IMAGE_BASE_RELOCATION 结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IMAGE_BASE_RELOCATION STRUCT</span><br><span class="line">    VirtualAddress      DWORD   ?   ;重定位数据的开始 RVA 地址</span><br><span class="line">    SizeOfBlock         DWORD   ?   ;重定位数据块的尺寸</span><br><span class="line">    TypeOffset          WORD    ?   ;重定位项数组</span><br><span class="line">IMAGE_BASE_RELOCATION ENDS</span><br></pre></td></tr></table></figure>

<ul>
<li>VirtualAddress：双字，这组重定位数据的起始 RVA 地址，各重定位项的地址加上这个值才是该重定位项的完整 RVA 地址；</li>
<li>SizeOfBlock：双字，当前重定位结构的大小，因为 VirtualAddress 和 SizeOfBlock 都是固定的 4 字节，所以这个值减去 8（字节）就是 TypeOffset 数组的大小；</li>
<li>TypeOffset：重定位项数组，数组每项大小为 2 字节，共 16 位，分为高 4 位和低 12 位；<br>高 4 位代表重定位类型，低 12 位是重定位地址，它与 VirtualAddress 相加就是指向 PE 映像中需要修改的地址数据的指针；</li>
</ul>
<p>常见的重定位类型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">winnt.h 中的预定义值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">IMAGE_REL_BASED_ABSOLUTE</td>
<td align="center">没有具体含义，只是为了让每个段 4 字节对齐</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">IMAGE_REL_BASED_HIGHLOW</td>
<td align="center">重定位指向的整个地址都需要修正，实际上大部分情况下都是这样的</td>
</tr>
<tr>
<td align="center">10（A）</td>
<td align="center">IMAGE_REL_BASED_DIR64</td>
<td align="center">出现在 64 位 PE 文件中，对指向的整个地址进行修正</td>
</tr>
</tbody></table>
<p>在一组重定位结束的地方会出现类型是 IMAGE_REL_BASED_ABSOLUTE 的重定位，这些重定位什么都不做，只是用于填充，以便下一个 IMAGE_BASE_RELOCATION 结构按 4 字节分界线对齐；<br>对于 PE 文件来说，所有的基址重定位类型都是 IMAGE_REL_BASED_HIGHLOW；<br>对于 64 位的 PE+ 文件来说，重定位类型似乎总是 IMAGE_REL_BASED_DIR64；<br>尽管 64 位的 PE+ 文件页大小是 8KB，但基址重定位仍是 4KB 的块；</p>
<h4 id="删除-reloc节区"><a href="#删除-reloc节区" class="headerlink" title="删除.reloc节区"></a>删除<code>.reloc</code>节区</h4><ol>
<li><p>使用 WinHex 打开程序，定位到节区头：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goo7uawuehj318t0u0abr.jpg" alt="WinHex"></p>
<p>节区头从文件偏移 270 处开始，到 297 处结束，节区大小为 1000，磁盘偏移为 C000；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goo81feiycj31dg0u0q5x.jpg" alt="用 00 填充"></p>
<p>选中节区头的全部数据，用 00 覆盖填充；</p>
</li>
<li><p>在 WinHex 中定位到节区起始偏移 C000，然后选中节区所有数据：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goo947rcyvj31d60u00um.jpg" alt="选中节区所有数据"></p>
<p>删除<code>.reloc</code>节区：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goo98jz4lhj31dr0u0jv3.jpg" alt="删除`.reloc`节区"></p>
<p>这样<code>.reloc</code>节区就被物理删除了，同时 PE 文件的体积也会变小；</p>
</li>
<li><p>由于删除了一个节区， IMAGE_FILE_HEADER 结构中表示节区数目的 NumberOfSections 字段就需要修正：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goo9h5ch0pj31a40u0adc.jpg" alt="NumberOfSections"></p>
</li>
<li><p>删除<code>.reloc</code>节区后，整个映像体积随之减少了相应的大小，IMAGE_OPTIONAL_HEADER 结构中的 SizeOfImage 字段同样需要修正：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goo9oawnrij31i80u041b.jpg" alt="SizeOfImage"></p>
</li>
<li><p>保存所有修改后，将程序导入 OD，观察内存映射窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goo9w7wknqj31f70u0gp6.jpg" alt="内存映射窗口"></p>
<p>同时，使用 LoadPE 查看程序的区段信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gooa0nt21uj30te0pqdgs.jpg" alt="LoadPE"></p>
<p><code>.reloc</code>区段已经被剔除了；</p>
</li>
</ol>
<p>年龄：30<br>性别：男<br>婚姻现状：未婚<br>婚姻困惑的十个问题：</p>
<ol>
<li>坚持最初的自己值不值得，妥协包容值不值得；</li>
<li>某些事情缺乏认同感；</li>
<li>每一个空闲的时刻都必须要在一起；</li>
<li>琐碎小事之间的争吵；</li>
<li>财务管理的问题；</li>
<li>一边是抱怨的爱人，一边是刁难的父母；</li>
<li>责任都是你的，因为我是女生；</li>
<li>和父母边界不清晰，什么都要听他们的；</li>
<li>子女教育问题；</li>
<li>什么都是别人家的好，没有对比就没有伤害；</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>文章资料</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>壳常用函数定位 OEP</title>
    <url>/posts/1066637783/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-2">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><h5 id="GetProcAddress"><a href="#GetProcAddress" class="headerlink" title="GetProcAddress"></a>GetProcAddress</h5><ol>
<li><p>将程序导入 OD，goto 到 GetProcAddress 函数的行首，设置 F2 断点，然后运行程序；</p>
</li>
<li><p>程序中断在函数的行首，使用<code>shift + F4</code>设置条件记录断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx8nzo52ej319x0u041z.jpg" alt="设置条件记录断点"></p>
<p>表达式的值填写<code>[esp]</code>，表示获取 ESP 中的数据，同时勾选记录表达式的值以及函数参数选项；</p>
</li>
<li><p>清空 log 窗口，然后运行程序，条件记录断点会在 log 窗口记录每次调用 GetProcAddress 函数的调用地址及参数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx8ws8qugj31aa0u0acs.jpg" alt="记录每次调用"></p>
<p>通过查看内存窗口得知，外壳程序对 GetProcAddress 的最后一次调用位于：0047009A：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx939o7ifj31a80u0gou.jpg" alt="外壳程序的最后一次调用"></p>
</li>
<li><p>重载程序，编辑条件记录断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9ag1b3uj31a00u00vx.jpg" alt="编辑条件记录断点"></p>
<p>勾选<code>按条件中断</code>选项，同时将条件设置为<code>[ESP] == 0047009A</code>，表示当 ESP 的值为 0047009A 时中断；</p>
</li>
<li><p>运行程序后，程序中断在条件记录断点位置，来到内存窗口，给代码段设置内存执行断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9euqak5j31ok0e2jrz.jpg" alt="内存执行断点"></p>
</li>
<li><p>多次运行程序后，程序到达 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9k811k6j31a50u0tby.jpg" alt="程序到达 OEP"></p>
<p>这里需要运行太多次了，所以这种方法因程序而异，灵活使用；</p>
<p>其实，设置了内存执行断点后，就可以将条件访问断点取消了，取消之后就和异常法大同小异了，好处是可以绕过部分反调试；</p>
</li>
</ol>
<h4 id="ExitThread"><a href="#ExitThread" class="headerlink" title="ExitThread"></a>ExitThread</h4><p>因为本例中有终止线程的动作，且位于代码段之外，可以使用 ExitThread；</p>
<ol>
<li><p>将程序导入 OD，<code>F9</code>运行程序后，打开日志窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9vj0yquj30sa0eoaaj.jpg" alt="打开日志窗口"></p>
<p>可以看到，在一堆异常中，有一个线程结束日志，位于最后一次异常之前；</p>
</li>
<li><p>打开 OD 调试设置菜单，事件选项卡，选中<code>中断于线程结束</code>选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9z0mfyhj30q20lgdgc.jpg" alt="中断于线程结束"></p>
</li>
<li><p>重载并运行程序，程序中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnxa1y4w6uj319v0u0tcr.jpg" alt="提示信息"></p>
<p>看提示信息可以得知，中断原因是某个线程结束了；</p>
</li>
<li><p>在内存窗口，给代码段设置内存执行断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9k811k6j31a50u0tby.jpg" alt="程序中断在 OEP"></p>
<p>程序到达 OEP；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>Crunch</tag>
      </tags>
  </entry>
  <entry>
    <title>壳的加载过程</title>
    <url>/posts/1754370069/</url>
    <content><![CDATA[<blockquote>
<p>记录<a href="https://bbs.pediy.com/forum-99.htm">加密解密</a>一书中对<code>壳的加载过程</code>的描述，第 16 章：16.1；</p>
<p>眼过千遍，不如手过一遍；</p>
</blockquote>
<span id="more"></span>

<h4 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a>壳的加载过程</h4><p>加壳软件通过修改原程序执行文件的组织结构，从而使壳比原程序代码更早获得控制权，且不影响原程序的正常运行，以下是壳的常见加载过程:</p>
<ol>
<li><p>保存入口参数</p>
<p>加壳程序在初始化时会保存各寄存器的值，待外壳执行完毕，再恢复各寄存器的内容，最后跳到原程序执行，通常使用 PUSHAD/PUSHFD、POPAD/POPFD 指令来保存与恢复现场；</p>
</li>
<li><p>获取壳本身需要使用的 API 地址</p>
<p>在一般情况下，外壳的输入表中只有 GetProcAddress、GetModuleHandle 和 LoadLibrary 这 3 个 API 函数，甚至只有 Kernel32.dll 及 GetProcAddress；</p>
<p>如果需要使用其它 API 函数，可以通过函数 LoadLibraryA（W）或 LoadLibraryExA（W）将 DLL 文件映像映射到调用进程的地址空间中，函数返回的 HINSTANCE 值用于标识文件映像所映射的虚拟内存地址；</p>
<p>LoadLibrary 函数原型：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HINSTANCE LoadLibrary(</span><br><span class="line">    LPCTSTR lpLibFileName    // DLL 文件名地址</span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>返回值：成功则返回模块的句柄，失败返回 NULL；</p>
<p>如果 DLL 文件已经被映射到调用进程的地址空间中，可以调用 GetModuleHandleA（W）函数获取 DLL 模块的句柄；</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HMODULE GetModuleHandle(</span><br><span class="line">    LPCTSTR lpModuleName    // DLL 文件名地址</span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>返回值：成功则返回模块的句柄，失败返回 NULL；</p>
<p>一旦 DLL 模块被加载，线程就可以调用 GetProcAddress 函数获取输入函数的地址了；</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">    HMODULE hModule,        // DLl 模块句柄</span><br><span class="line">    LPCSTR  lpProcName      // 函数名</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>参数 hModule 是 DLL 模块的句柄，是调用 LoadLibrary（Ex） 或 GetModuleHandle 函数的返回值；</p>
<p>参数 lpProcName 是函数名或函数序数值，如果此参数是序数值，则必须使用低位字；高位必须为零；</p>
<p>返回值：成功则返回函数地址，失败返回 NULL；</p>
<p>在外壳中使用的其他函数都是由这 3 个函数调用的；</p>
<p>有些壳为了提高强度，连系统提供的 GetProcAddress 函数都不使用，而是自己实现一个相同功能的函数来代替 GetProcAddress，从而增加函数调用的隐蔽性；</p>
</li>
<li><p>解密原程序各区块的数据</p>
<p>出于保护原程序代码和数据的目的，壳一般会加密原程序文件的各个区段；</p>
<p>在程序执行时，外壳将解密这些区段数据，从而使程序能够正常运行；</p>
<p>壳一般是按区块加密的，所以解密时也按区块解密，并把解密的区块数据按照区块的定义放入内存中合适的位置；</p>
</li>
<li><p>IAT 的初始化</p>
<p>IAT 的填写本来应该由 PE 装载器实现，但由于在加壳时构造了一个自建输入表，并让 PE 文件头数据目录表中的输入表指针指向自建输入表，PE 装载器会对自建输入表进行填写；</p>
<p>程序的原始输入表会被外壳变形后存储，IAT 的填写会由外壳程序实现；</p>
<p>外壳程序要做的就是将这个变形输入表的结构从头到尾扫描一遍，重新获取每个 DLL 引入的所有函数的地址，并将其填写在 IAT 中；</p>
</li>
<li><p>重定位项的处理</p>
<p>文件执行时将被映射到指定内存地址中，这个初始内存地址称为基址，当然，这只是程序文件中声明的，当程序运行时，操作系统一定会满足其要求吗？</p>
<p>对 EXE 文件来说，操作系统会尽量满足其要求，如：程序声明的基址是 400000，操作系统提供的基址也是 400000，在这种情况下就不需要基址重定位了；</p>
<p>由于不需要对 EXE 文件进行重定位，加壳软件会删除原程序文件中用于保存重定位信息的区块，使加壳后的程序更小巧；</p>
<p>对 DLL 的动态链接库文件来说，操作系统无法保证 DLL 每次运行时都提供相同的基址，所以重定位就很重要了；</p>
<p>此时，壳中也要有用于重定位的代码，否则原程序将无法正常运行；</p>
<p>所以，加壳的 DLL 比加壳的 EXE 在修正时多了一个重定位表；</p>
</li>
<li><p>Hook API<br>在程序文件中，输入表的作用是让 Windows 操作系统在程序运行时将 API 的实际地址提供给程序使用，在程序的第 1 行代码执行前，Windows 操作系统就完成了这项工作；</p>
<p>壳大都在修改原程序的输入表后，自己模仿 Windows 操作系统的工作流程，向输入表中填充相关的数据，在填充过程中，外壳可以填充 Hook API 代码的地址，从而间接获得程序的控制权；</p>
</li>
<li><p>跳转到程序原始入口点（OEP）</p>
<p>从这个时候起，壳就把控制权还给原程序了，一般的壳在这里会有一条明显的分界线；</p>
<p>现在越来越多的加密壳先将 OEP 代码段搬到外壳的地址空间里，再将这段代码清除（这种技术称为“Stolen Bytes”），这样，OEP 与外壳之间那条明显的分界线就消失了，脱壳的难度也增加了；</p>
</li>
</ol>
<h4 id="脱壳机"><a href="#脱壳机" class="headerlink" title="脱壳机"></a>脱壳机</h4><p>针对特定的壳开发出来的脱壳软件称为“脱壳机”；</p>
<p>脱壳就是将加壳后的程序恢复到原来的状态，脱壳成功的标志是文件能正常运行；</p>
<p>由于脱壳时可能没有将壳本身的代码去除，脱壳后程序的体积通常会比原程序的体积大；</p>
<p>脱壳机一般分为专用脱壳机和通用脱壳机；</p>
<p>专用脱壳机是针对某种壳专门编写的，只能脱特定的壳，虽然使用范围小，但效果好；</p>
<p>通用脱壳机具有通用性，可以脱多种不同类型的壳（主要是压缩壳）；</p>
<p>在分析一个软件前，可以使用 PEiD 确定壳的种类，再选择合适的脱壳机；</p>
<h4 id="手动脱壳"><a href="#手动脱壳" class="headerlink" title="手动脱壳"></a>手动脱壳</h4><p>对一些加密壳或修改的壳，没有脱壳机，因此必须要分析外壳并手动脱壳；</p>
<p>手动脱壳过程一般分为 3 步：</p>
<ol>
<li>查找真正的程序入口点（OEP）；</li>
<li>抓取内存映像文件；</li>
<li>重建 PE 文件；</li>
</ol>
<p>当程序执行时，外壳代码首先获得控制权，模拟 Windows 加载器，将原程序恢复到内存中，这时，内存中的数据就是加壳前的映像文件了，适时将其抓取并修改，即可还原到加壳前的状态；</p>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>文章资料</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>壳基础</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器小记</title>
    <url>/posts/592731679/</url>
    <content><![CDATA[<h3 id="基本程序运行寄存器"><a href="#基本程序运行寄存器" class="headerlink" title="基本程序运行寄存器"></a>基本程序运行寄存器</h3><ul>
<li>通用寄存器：32 位，8 个</li>
<li>段寄存器：16 位，6 个</li>
<li>程序状态与控制寄存器：32 位，1 个</li>
<li>指令指针寄存器：32 位，1 个</li>
</ul>
<p>在寄存器名称缩略语之前添加字母 E（Extended），表示该寄存器在 16 位 CPU 时就已经存在，并且其大小在 IA-32 下由原 16 位扩展为 32 位；</p>
<span id="more"></span>

<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器是一种通用型的寄存器，用于传送和暂存数据，也可以参与算术逻辑运算，并保存运算结果；</p>
<p>IA-32 中每个通用寄存器的大小都是 32 位，即 4 个字节，主要用来保存常量与地址等，由特定汇编指令来操作特定寄存器；</p>
<h4 id="通用寄存器拆分"><a href="#通用寄存器拆分" class="headerlink" title="通用寄存器拆分"></a>通用寄存器拆分</h4><p>为了实现对低 16 位的兼容，各寄存器又可以分为高、低几个独立寄存器；</p>
<p>以 EAX 为例（不涉及大、小端序），只为直观：</p>
<ul>
<li>EAX = 12345678 （0 ～ 31）32 位</li>
<li>&nbsp;&nbsp;AX = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5678 （0 ～ 15）EAX 的低 16 位</li>
<li>&nbsp;&nbsp;AH = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;56&nbsp;&nbsp;&nbsp; （8 ～ 15）AX 的高 8 位</li>
<li>&nbsp;&nbsp;AL = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;78 （0 ～ 7）AX 的低 8 位</li>
<li>以上拆分方式适用于 EAX / EBX / ECX / EDX</li>
<li>EBP / ESP / ESI /EDI 只能拆分为 16 位，即 BP / SP / SI / DI</li>
</ul>
<h4 id="通用寄存器含义"><a href="#通用寄存器含义" class="headerlink" title="通用寄存器含义"></a>通用寄存器含义</h4><ul>
<li><p>EAX：（针对操作数和结果数据的）累加器</p>
</li>
<li><p>EBX：（DS 段中的数据指针）基址寄存器</p>
</li>
<li><p>ECX：（字符串和循环操作的）计数器</p>
</li>
<li><p>EDX：（I/O 指针）数据寄存器</p>
<p>以上 4 个寄存器主要用于算数运算指令中，常常用来保存常量与变量的值；<br>某些汇编指令（MUL、DIV、LODS 等）直接用来操作特定寄存器，执行这些命令后，仅改变特定寄存器中的值；<br>EAX 一般用在函数返回值中，所有 Win32 API 函数都会先把返回值保存到 EAX 再返回，如果处理结果的大小超过 EAX 寄存器的容量，其高 32 位将会放到 EDX 寄存器中；</p>
</li>
<li><p>EBP：（SS 段中栈内数据指针）扩展基址指针寄存器</p>
</li>
<li><p>ESP：（SS 段中栈指针）栈指针寄存器</p>
</li>
<li><p>ESI：（字符串操作源指针）源变址寄存器</p>
</li>
<li><p>EDI：（字符串操作目标指针）目的变址寄存器</p>
<p>以上 4 个寄存器主要用于保存内存地址的指针；<br>ESP 指示栈区域的栈顶地址，某些指令（PUSH、POP、CALL、RET）可以直接操作 ESP；<br>EBP 表示栈区域的基地址，函数被调用时保存 ESP 的值，函数返回时再把值返回 ESP，保证栈不会崩溃，这被称为栈帧技术；<br>ESI 和 EDI 与特定指令（LODS、STOS、REP、MOVS 等）一起使用，主要用于内存复制；</p>
</li>
</ul>
<h4 id="大端序与小端序"><a href="#大端序与小端序" class="headerlink" title="大端序与小端序"></a>大端序与小端序</h4><p>计算机领域中，字节序是多字节数据在计算机内存中存储或网络传输时各字节的存储顺序，主要分为两大类：小端序（Little endian）和大端序（Big endian）；</p>
<table>
<thead>
<tr>
<th align="center">TYPE</th>
<th align="center">Name</th>
<th align="center">SIZE</th>
<th align="center">大端序类型</th>
<th align="center">小端序类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BYTE</td>
<td align="center">b</td>
<td align="center">1</td>
<td align="center">[12]</td>
<td align="center">[12]</td>
</tr>
<tr>
<td align="center">WORD</td>
<td align="center">w</td>
<td align="center">2</td>
<td align="center">[12][34]</td>
<td align="center">[34][12]</td>
</tr>
<tr>
<td align="center">DWORD</td>
<td align="center">dw</td>
<td align="center">4</td>
<td align="center">[12][34][56][78]</td>
<td align="center">[78][56][34][12]</td>
</tr>
<tr>
<td align="center">char []</td>
<td align="center">str</td>
<td align="center">4</td>
<td align="center">[73][74][72][00]</td>
<td align="center">[73][74][72][00]</td>
</tr>
</tbody></table>
<ul>
<li>数据类型为字节型（BYTE）时，其长度为 1 个字节，无论采用大端序还是小端序，字节顺序都一样；</li>
<li>数据长度为 2 个字节以上（含 2 个字节）时，采用不同字节序保存数据时，形成的存储顺序是不同的；</li>
<li>采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位，这是一种最直观的字节存储顺序；</li>
<li>采用小端序存储数据时，内存地址高位存储数据的高位，内存地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒转；</li>
<li>字符串被保存在字符数组中；</li>
<li>字符数组在内存中是连续的，所以，无论采用大端序还是小端序，存储顺序都相同；</li>
<li>字符串最后以 NULL 结尾；</li>
<li>Intel x86 CPU 采用小端序存储数据；</li>
<li>采用大端序保存多字节数据非常直观，常用于 RISC 系列的 CPU 中；</li>
<li>网络协议中通常也采用大端序方式传输数据；</li>
</ul>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>IA-32 的保护模式中，段是一种内存保护技术，它把内存划分为多个区段，并为每个区段赋予起始地址、范围、访问权限等，以保护内存；<br>此外，它还同分页技术一起用于将虚拟内存变更为实际物理内存；<br>段内存记录在 SDT（段描述符表）中，而段寄存器就持有这些 SDT 的索引；<br>段寄存器总共由 6 种寄存器组成，分别是 CS、SS、DS、ES、FS、GS，每个寄存器大小为 16 位，即 2 个字节；；<br>另外，每个段寄存器指向的段描述符与虚拟内存结合，形成一个线性地址，借助分页技术，线性地址最终被转换为实际的物理地址；<br>不使用分页技术的操作系统中，线性地址直接变为物理地址；</p>
<h4 id="段寄存器含义"><a href="#段寄存器含义" class="headerlink" title="段寄存器含义"></a>段寄存器含义</h4><ul>
<li><p>CS：Code Segment，代码段寄存器；</p>
</li>
<li><p>SS：Stack Segment，栈段寄存器；</p>
</li>
<li><p>DS：Data Segment，数据段寄存器；</p>
</li>
<li><p>ES：Extra（Data）Segment，附加（数据）段寄存器；</p>
</li>
<li><p>FS：Data Segment，数据段寄存器；</p>
</li>
<li><p>GS：Data Segment，数据段寄存器；</p>
<p>CS 寄存器用于存放应用程序代码所在段的段基址；<br>SS 寄存器用于存放栈段的段基址；<br>DS 寄存器用于存放数据段的段基址；<br>ES、FS、GS 寄存器用来存放程序使用的附加数据段的段基址；</p>
</li>
<li><p><code>FS 寄存器</code>从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 位存放的是起始位置的地址；</p>
</li>
<li><p>任意时刻，CS:IP 指向 CPU 将要读取指令的地址，代码段的段地址存放在 CS 中，偏移地址存放在 IP 中；</p>
</li>
<li><p>任意时刻，SS:SP 指向栈顶元素，栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中；</p>
</li>
<li><p>通常，在读写内存单元时，DS 用来存放要访问数据段的段地址；</p>
</li>
</ul>
<h3 id="程序状态与控制寄存器"><a href="#程序状态与控制寄存器" class="headerlink" title="程序状态与控制寄存器"></a>程序状态与控制寄存器</h3><p>IA-32 中，标志寄存器的名称为 EFLAGS，其大小为 4 个字节（32 位），由原来的 16 位 FLAGS 寄存器扩展而来；<br>EFLAGS 寄存器的每位都有意义，每位的值为 1 或为 0，代表 ON/OFF 或 TRUE/FALSE；<br>其中有些位由系统直接设定，有些位则根据程序命令的执行结果设置；</p>
<h4 id="标志位寄存器"><a href="#标志位寄存器" class="headerlink" title="标志位寄存器"></a>标志位寄存器</h4><ul>
<li><p>ZF 是<code>0 标志符</code>.</p>
<ul>
<li>当前指令的运算结果为 0，则 ZF 为 1；</li>
</ul>
</li>
<li><p>OF 是<code>溢出标志位</code>;</p>
<ul>
<li>有符号整数溢出时，OF 为 1；</li>
<li>MSB（最高有效位）改变时，OF 为 1；</li>
<li>当指令改变了符号位且返回错误值的时候，OF 为 1，表示溢出成立；</li>
<li>运算结果超出机器能够表示的范围称为溢出；</li>
</ul>
</li>
<li><p>CF 是<code>进位标志符</code>；</p>
<ul>
<li>无符号整数溢出时，CF 为 1；</li>
<li>当指令的无符号运算结果超过最大值时，CF 为 1；</li>
<li>最高位产生进位或借位；</li>
</ul>
</li>
<li><p>PF 是 <code>奇偶标志位</code>；</p>
<ul>
<li>当指令的<code>返回值的二进制</code>表现形式中<code>1</code>的个数为偶数个时，PF 为 1；</li>
<li>运算结果的最低 16 位中含 1 的个数为偶数；</li>
<li>如：11，101，110，1001，1010，1100，1111</li>
</ul>
</li>
<li><p>SF 是<code>符号位标志符</code>;</p>
<ul>
<li>当指令的运算结果为负数时，SF 为 1；</li>
<li>SF 与运算结果的最高位相同；</li>
</ul>
</li>
<li><p>AF 是<code>辅助进位标志符</code>；</p>
<ul>
<li>当指令的运算结果的低 4 位向高 4 位有进位或借位时，AF 为 1；</li>
</ul>
</li>
<li><p>TF 是<code>跟踪标志符</code>；</p>
<ul>
<li>用于调试单步操作；</li>
<li>若 TF 为 1，则每条指令执行结束后，产生中断；</li>
</ul>
</li>
<li><p>DF 是<code>方向标志符</code>；</p>
<ul>
<li>用来控制串处理指令的处理方向；</li>
<li>若 DF 为 1，则串处理中地址自动递减，否则自动自增；</li>
<li>若 DF 为 1，每次操作后使 SI 和 DI 递减，DF 为 0 时则自增；</li>
<li>CLD 指令可以将 DF 位置 0；</li>
<li>STD 指令可以将 DF 位置 1；</li>
</ul>
</li>
<li><p>IF 是<code>中断标志符</code>；</p>
<ul>
<li>用来控制 CPU 是否响应可屏蔽中断；</li>
<li>若 IF 为 1 则允许中断，否则禁止中断；</li>
</ul>
</li>
</ul>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><ul>
<li><p>EIP：指令指针寄存器；</p>
<p>指令指针寄存器保存着 CPU 要执行的指令地址，其大小为 32 位（4 个字节），由原 16 位 IP 寄存器扩展而来；<br>程序运行时，CPU 会读取 EIP 中一条指令的地址，传送指令到指令缓冲区后，EIP 寄存器的值自动增加，增加的大小即是读取指令的字节大小，这样，CPU 每次执行完一条指令，就会通过 EIP 寄存器读取并执行下一条指令；<br>与通用寄存器不同，不能直接修改 EIP 的值，只能通过其它指令间接修改，这些特定指令包括 JMP、JCC、CALL、RET；<br>还可以通过中断或异常来修改 EIP 的值；</p>
</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是定义在进程中的一段内存空间，向下（低地址方向）扩展，且其大小被记录在 PE 头中，也就是说，进程运行时确定栈内存的大小；</p>
<p>栈通常用于存储局部变量、传递函数参数、保存函数返回地址等；</p>
<p>栈内存在进程中的作用：</p>
<ul>
<li>暂时保存函数内的局部变量；</li>
<li>调用函数时传递参数；</li>
<li>保存函数返回后的地址；</li>
</ul>
<p>栈是一种数据结构，它按照 FILO（First In Last Out，先进后出）的原则存储数据；</p>
<ul>
<li>一个进程中，栈顶指针（ESP）初始状态指向栈底端；</li>
<li>执行 PUSH 压栈命令时，栈顶指针就会向上移动到栈顶端；</li>
<li>执行 POP 弹栈命令时，若栈为空，则栈顶指针重新移动到栈底端；</li>
<li>栈是一种由高地址向低地址扩展的数据结构；</li>
<li>栈是由下向上扩展的，即，栈是逆序扩展的；</li>
</ul>
<p>向栈压入数据时，栈指针减小，向低地址移动；从栈中弹出数据时，栈指针增加，向高地址移动；</p>
<h4 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h4><p>函数调用约定（Calling Convention）：是对函数调用时如何传递参数的一种约定；</p>
<ul>
<li>调用函数前，要先把参数压入栈，然后再传递给函数；</li>
<li>栈内存是固定的，ESP 用来指示栈的当前位置，若 ESP 指向栈底，则无法再使用该栈；</li>
<li>函数调用后如何处理 ESP 就是函数调用约定要解决的问题；</li>
</ul>
<p>主要的函数调用约定：</p>
<ul>
<li><p>cdecl：是主要在 C 语言中使用的方式，调用者负责处理栈；</p>
<p>如：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> <span class="number">00401000</span>       <span class="comment">; 调用函数</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">ESP</span>, <span class="number">8</span>          <span class="comment">; 清理栈</span></span><br></pre></td></tr></table></figure>

<p>调用函数后，使用<code>ADD ESP, 8</code>命令整理栈；</p>
<p>调用者直接清理其压入栈的函数参数，这样的方式即是<code>cdecl</code>；</p>
<p><code>cdecl</code>方式的好处是，它可以像 C 语言的 printf()函数一样，向被调用函数传递长度可变的参数，这种长度可变的参数在其它调用约定中很难实现；</p>
</li>
<li><p>stdcall：常用于 Win32 API，该方式由被调用者清理栈；<br>若想在 C 语言中使用，只要使用 _stdcall 关键字即可；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> stdio.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调试：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">00401000</span> <span class="keyword">PUSH</span> <span class="built_in">EBP</span>                       <span class="comment">; add() 函数</span></span><br><span class="line"><span class="number">00401001</span> <span class="keyword">MOV</span> <span class="built_in">EBP</span>, <span class="built_in">ESP</span>                   <span class="comment">; 函数栈帧</span></span><br><span class="line"><span class="number">00401003</span> <span class="keyword">MOV</span> <span class="built_in">EAX</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">SS</span>:[<span class="built_in">EBP</span>+<span class="number">8</span>]  <span class="comment">; 参数 2 拷贝到 EAX</span></span><br><span class="line"><span class="number">00401006</span> <span class="keyword">ADD</span> <span class="built_in">EAX</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">SS</span>:[<span class="built_in">EBP</span>+C]  <span class="comment">; 参数 1 加上参数 2，结果保存在 EAX</span></span><br><span class="line"><span class="number">00401009</span> <span class="keyword">POP</span> <span class="built_in">EBP</span>                        <span class="comment">; 恢复函数执行前的 EBP</span></span><br><span class="line">0040100A <span class="keyword">RETN</span> <span class="number">8</span>                         <span class="comment">; 恢复函数执行前的 ESP</span></span><br><span class="line"><span class="number">0040100D</span> <span class="keyword">INT3</span></span><br><span class="line">0040100E <span class="keyword">INT3</span></span><br><span class="line">0040100F <span class="keyword">INT3</span></span><br><span class="line"><span class="number">00401010</span> <span class="keyword">PUSH</span> <span class="built_in">EBP</span>                       <span class="comment">; main() 函数</span></span><br><span class="line"><span class="number">00401011</span> <span class="keyword">MOV</span> <span class="built_in">EBP</span>, <span class="built_in">ESP</span>                   <span class="comment">; 函数栈帧</span></span><br><span class="line"><span class="number">00401013</span> <span class="keyword">PUSH</span> <span class="number">2</span>                         <span class="comment">; 参数 2 压栈</span></span><br><span class="line"><span class="number">00401015</span> <span class="keyword">PUSH</span> <span class="number">1</span>                         <span class="comment">; 参数 1 压栈</span></span><br><span class="line"><span class="number">00401017</span> <span class="keyword">CALL</span> <span class="number">00401000</span>                  <span class="comment">; 调用 add() 函数</span></span><br><span class="line">0040101C <span class="keyword">POP</span> <span class="built_in">EBP</span>                        <span class="comment">; 恢复函数执行前的 EBP</span></span><br><span class="line"><span class="number">0040101D</span> <span class="keyword">RETN</span></span><br></pre></td></tr></table></figure>

<p>栈的清理工作由 add() 函数最后的<code>RETN 8</code>命令来执行；<br><code>RETN 8</code>命令的含义为<code>RETN + POP 8 字节</code>，即返回后使 ESP 增加指定大小；<br>像这样在被调用者内部清理栈的方式即为 stdcall 方式；<br>stdcall 方式的好处是相对于每次调用函数都要使用<code>ADD ESP, xxx</code> 的 cdecl 方式代码尺寸小；<br>Win32 API 是使用 C 语言编写的，但使用的是 stdcall 方式，这是为了获得更好的兼容性，使 C 语言以外的其它语言也能直接调用 API；</p>
</li>
<li><p>fastcall<br>fastcall 方式与 stdcall 方式基本类似，但该方式通常会使用寄存器而非栈内存，去传递那些需要传递给函数的部分参数（前 2 个）；<br>如：函数有 4 个参数，则前 2 个参数分别使用 ECX 和 EDX 寄存器传递；<br>fastcall 相对于 stdcall 速度快，毕竟 CPU 访问寄存器要比内存快得多，但需要额外的系统开销来管理 ECX 和 EDX 寄存器；</p>
</li>
<li><p>不管采用哪种方式，通过栈来传递参数的基本概念是一样的；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>文章资料</category>
        <category>汇编知识</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的汇编指令</title>
    <url>/posts/1025109479/</url>
    <content><![CDATA[<h3 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h3><h4 id="NOP"><a href="#NOP" class="headerlink" title="NOP"></a>NOP</h4><ul>
<li><code>NOP</code>：No Operation，不执行任何动作的指令，只消耗 CPU 时钟；</li>
<li>NOP 的机器码是<code>90</code>；</li>
<li>NOP 是空指令，就是没有操作，无操作；</li>
<li>使用 <code>NOP</code> 来填充指令执行后多出来的字节，而不是用<code>00</code>来填充；</li>
</ul>
<span id="more"></span>

<h4 id="PUSH-压入堆栈"><a href="#PUSH-压入堆栈" class="headerlink" title="PUSH 压入堆栈"></a>PUSH 压入堆栈</h4><p>PUSH 的用法：</p>
<ul>
<li><code>PUSH 0x1 / 0xF</code>：把十六进制数字压入堆栈顶部；</li>
<li><code>PUSH EAX / EBX</code>：把指定寄存器中的数据压入堆栈顶部；</li>
<li><code>PUSH [00401000]</code>：把指定内存地址中的数据压入堆栈顶部；</li>
</ul>
<h4 id="POP-弹出堆栈"><a href="#POP-弹出堆栈" class="headerlink" title="POP 弹出堆栈"></a>POP 弹出堆栈</h4><p>POP 的用法：</p>
<ul>
<li><code>POP EAX / EBX</code>：将堆栈顶部的内容弹出并放入指定的寄存器；</li>
</ul>
<h4 id="PUSHAD"><a href="#PUSHAD" class="headerlink" title="PUSHAD"></a>PUSHAD</h4><ul>
<li>通用寄存器指：EAX / ECX / EDX / EBX / ESP / EBP / ESI / EDI；</li>
<li>PUSHAD 保护现场 / 备份现场，将通用寄存器的数据自上而下依次压入堆栈，最后一个寄存器的数据处于堆栈顶部；</li>
<li>PUSHAD 是 32 位操作；</li>
<li><code>PUSHAD</code> 相当于是<code>PUSH EAX, PUSH ECX, PUSH EDX, PUSH EBX, PUSH ESP, PUSH EBP, PUSH ESI, PUSH EDI</code>八条命令的合集；</li>
</ul>
<h4 id="POPAD"><a href="#POPAD" class="headerlink" title="POPAD"></a>POPAD</h4><ul>
<li>通用寄存器指：EAX / ECX / EDX / EBX / ESP / EBP / ESI / EDI；</li>
<li>POPAD 还原现场，将堆栈顶部的数据依次弹出并自下而上依次填充到通用寄存器；</li>
<li>POPAD 是 32 位操作；</li>
<li><code>POPAD</code> 相当于是<code>POP EDI, POP ESI, POP EBP, POP ESP, POP EBX, POP EDX, POP ECX, POP EAX</code>八条命令的合集；</li>
</ul>
<h4 id="PUSHA"><a href="#PUSHA" class="headerlink" title="PUSHA"></a>PUSHA</h4><ul>
<li>PUSHA 和 PUSHAD 功能相同，用于备份现场；</li>
<li>PUSHA 是 16 位操作；</li>
<li><code>PUSHA</code> 相当于是<code>PUSH AX, PUSH CX, PUSH DX, PUSH BX, PUSH SP, PUSH BP, PUSH SI, PUSH DI</code>八条命令的合集；</li>
</ul>
<h4 id="POPA"><a href="#POPA" class="headerlink" title="POPA"></a>POPA</h4><ul>
<li>POPA 和 POPAD 功能相同，用于还原现场；</li>
<li>POPA 是 16 位操作；</li>
<li><code>POPA</code> 相当于是<code>POP DI, POP SI, POP BP, POP SP, POP BX, POP DX, POP CX, POP AX</code>八条命令的合集；</li>
</ul>
<h4 id="PUSHF"><a href="#PUSHF" class="headerlink" title="PUSHF"></a>PUSHF</h4><ul>
<li>将标志寄存器的值压栈；</li>
</ul>
<h4 id="POPF"><a href="#POPF" class="headerlink" title="POPF"></a>POPF</h4><ul>
<li>从栈中弹出数据，送入标志寄存器；</li>
</ul>
<h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h4><ul>
<li>MOV 本意为<code>move，移动</code>，但功能相当于复制/赋值；</li>
<li><code>MOV EAX, ECX</code>：两个操作数的长度必须相同；</li>
<li><code>MOV EAX, ECX</code>：复制<code>ECX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，4 字节操作；</li>
<li><code>MOV AX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>AX（第一个参数）</code>，2 字节操作；</li>
<li><code>MOV AL, CL</code>：复制<code>CL（第二个参数）</code>的数据到<code>AL（第一个参数）</code>，1 字节操作；</li>
<li><code>MOV [00402000], EAX</code>：复制<code>EAX（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，4 字节操作；</li>
<li><code>MOV [00402000], AX</code>：复制<code>AX（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，2 字节操作；</li>
<li><code>MOV [00402000], AH</code>：复制<code>AH（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，1 字节操作；</li>
</ul>
<h4 id="MOVSX"><a href="#MOVSX" class="headerlink" title="MOVSX"></a>MOVSX</h4><ul>
<li><code>MOVSX EAX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，如果<code>EAX（第一个参数）</code>的长度比<code>CX（第二个参数）</code>长，剩余的长度用<code>CX（第二个参数）</code>的符号位填充；</li>
<li>正数用 0 填充，负数用 F 填充；</li>
</ul>
<h4 id="MOVZX"><a href="#MOVZX" class="headerlink" title="MOVZX"></a>MOVZX</h4><ul>
<li><code>MOVZX EAX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，如果<code>EAX（第一个参数）</code>的长度比<code>CX（第二个参数）</code>长，剩余的长度用 0 填充；</li>
<li>带 0 扩展传送命令；</li>
</ul>
<h4 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h4><ul>
<li>LEA：复制<code>第二个参数的内存地址</code> 或 <code>第二个参数运算后的内存地址</code>到<code>第一个参数</code>；</li>
<li><code>LEA EAX, [00401000]</code>：第一个参数必须是通用寄存器，第二个参数必须是内存地址；</li>
<li><code>LEA EAX, [ECX + 16]</code>：第一个参数必须是通用寄存器，第二个参数必须是内存地址；</li>
<li>LEA 是取地址指令，仅操作地址，如：<code>LEA EAX, DWORD PTR DS:[ECX+38]</code>这里虽然有括号，但不会获取 ECX+38 指向内存的值，只计算 ECX+38 的值；</li>
</ul>
<h4 id="XCHG-互换-交换"><a href="#XCHG-互换-交换" class="headerlink" title="XCHG 互换 / 交换"></a>XCHG 互换 / 交换</h4><ul>
<li><code>XCHG EAX, ECX</code>：第一个参数可以是通用寄存器或内存地址，第二个参数必须是通用寄存器；</li>
<li><code>XCHG [00401000], ECX</code>：第一个参数可以是通用寄存器或内存地址，第二个参数必须是通用寄存器；</li>
</ul>
<h4 id="SHR-二进制右移"><a href="#SHR-二进制右移" class="headerlink" title="SHR 二进制右移"></a>SHR 二进制右移</h4><ol>
<li>将一个寄存器或内存单元中的数据向右位移；</li>
<li>将最后移出的一位写入 CF 中；</li>
<li>最高位用 0 补充；</li>
<li>如果移动位数大于 1 时，必须将要移动的位数放在 CL 中；</li>
</ol>
<h4 id="SHL-二进制左移"><a href="#SHL-二进制左移" class="headerlink" title="SHL 二进制左移"></a>SHL 二进制左移</h4><ol>
<li>将一个寄存器或内存单元中的数据向左移位；</li>
<li>将最后移出的一位写入 CF 中；</li>
<li>最低位用 0 补充；</li>
<li>如果移动位数大于 1 时，必须将要移动的位数放在 CL 中；</li>
</ol>
<h4 id="CLD"><a href="#CLD" class="headerlink" title="CLD"></a>CLD</h4><ul>
<li>用来操作方向标志位 DF，CLD 使 DF 复位，即让 DF = 00；</li>
</ul>
<h4 id="STD"><a href="#STD" class="headerlink" title="STD"></a>STD</h4><ul>
<li>用来操作方向标志位 DF，STD 使 DF 置位，即让 DF = 01；</li>
</ul>
<h3 id="数学指令"><a href="#数学指令" class="headerlink" title="数学指令"></a>数学指令</h3><h4 id="ADD-SUB-加法-减法"><a href="#ADD-SUB-加法-减法" class="headerlink" title="ADD / SUB | 加法 / 减法"></a>ADD / SUB | 加法 / 减法</h4><ul>
<li><code>ADD / SUB</code>的返回结果放在第一个参数中；</li>
</ul>
<h4 id="ADC-带进位的加法"><a href="#ADC-带进位的加法" class="headerlink" title="ADC 带进位的加法"></a>ADC 带进位的加法</h4><ul>
<li><code>ADC EAX, ECX</code> = <code>EAX + ECX + 0 | 1</code>：两个参数累加并且加上<code>进位标识符CF</code>的值为最终结果；</li>
</ul>
<h4 id="SBB-带进位的减法"><a href="#SBB-带进位的减法" class="headerlink" title="SBB 带进位的减法"></a>SBB 带进位的减法</h4><ul>
<li><code>SBB EAX, ECX</code> = <code>EAX - ECX - 0 | 1</code>：两个参数相减并且减去<code>进位标识符CF</code>的值为最终结果；</li>
</ul>
<h4 id="INC-DEC-自增-自减"><a href="#INC-DEC-自增-自减" class="headerlink" title="INC / DEC | 自增 / 自减"></a>INC / DEC | 自增 / 自减</h4><ul>
<li><code>INC EAX</code>：每执行一次该指令，参数的值自增 1；</li>
<li><code>DEC EAX</code>：每执行一次该指令，参数的值自减 1；</li>
<li>可以操作寄存器，也可以操作内存单元；</li>
</ul>
<h4 id="MUL-无符号乘法"><a href="#MUL-无符号乘法" class="headerlink" title="MUL 无符号乘法"></a>MUL 无符号乘法</h4><ul>
<li>无符号乘法只有一个操作数，另一个操作数默认为 EAX（AX | AL）；</li>
<li><code>MUL ECX</code>：<code>MUL CL | CX | ECX</code>默认和 <code>AL | AX | EAX</code>做乘法运算，运算结果分别存放到<br><code>AH:AL | DX:AX | EDX:EAX</code>中，其中<code>AH | DX | EDX</code>存放高位，<code>AL | AX | EAX</code>存放低位；</li>
</ul>
<h4 id="DIV-无符号除法"><a href="#DIV-无符号除法" class="headerlink" title="DIV 无符号除法"></a>DIV 无符号除法</h4><ul>
<li><code>DIV CL</code>：默认的被除数为<code>EAX</code>，如果 <code>CL（除数）</code>是 8 位，那么<code>商</code>放在<code>AL</code>中，<code>余数</code>放在<code>AH</code>中；</li>
<li><code>DIV CX</code>：默认的被除数为<code>EAX</code>，如果 <code>CX（除数）</code>是 16 位，那么<code>商</code>放在<code>AX</code>中，<code>余数</code>放在<code>DX</code>中；</li>
<li><code>DIV ECX</code>：默认的被除数为<code>EAX</code>，如果 <code>ECX（除数）</code>是 32 位，那么<code>商</code>放在<code>EAX</code>中，<code>余数</code>放在<code>EDX</code>中；</li>
</ul>
<h4 id="IMUL-有符号乘法"><a href="#IMUL-有符号乘法" class="headerlink" title="IMUL 有符号乘法"></a>IMUL 有符号乘法</h4><ul>
<li>立即数：自然数；</li>
<li>单操作数：<code>IMUL CL | CX | ECX</code>默认和 <code>AL | AX | EAX</code>做乘法运算，运算结果分别存放到<br><code>AH:AL | DX:AX | EDX:EAX</code>中，其中<code>AH | DX | EDX</code>存放高位，<code>AL | AX | EAX</code>存放低位；</li>
<li>双操作数：<code>IMUL AX, CX</code>：第一个参数必须是通用寄存器，第二个参数可以是通用寄存器、内存地址或立即数，运算结果存放到第一个参数中；</li>
<li>三操作数：<code>IMUL AX, CX, 0x2</code>：第一个参数必须是通用寄存器，第二个参数可以是通用寄存器或内存地址，第三个参数必须是立即数，将第二个参数和第三个参数的运算结果存放到第一个参数中；</li>
</ul>
<h4 id="IDIV-有符号除法"><a href="#IDIV-有符号除法" class="headerlink" title="IDIV 有符号除法"></a>IDIV 有符号除法</h4><ul>
<li><code>IDIV CL</code>：默认的被除数为<code>EAX</code>，如果 <code>CL（除数）</code>是 8 位，那么<code>商</code>放在<code>AL</code>中，<code>余数</code>放在<code>AH</code>中；</li>
<li><code>IDIV CX</code>：默认的被除数为<code>EAX</code>，如果 <code>CX（除数）</code>是 16 位，那么<code>商</code>放在<code>AX</code>中，<code>余数</code>放在<code>DX</code>中；</li>
<li><code>IDIV ECX</code>：默认的被除数为<code>EAX</code>，如果 <code>ECX（除数）</code>是 32 位，那么<code>商</code>放在<code>EAX</code>中，<code>余数</code>放在<code>EDX</code>中；</li>
<li>双操作数和三操作数的做法与 IMUL 类似；</li>
</ul>
<h4 id="XADD-先交换后相加"><a href="#XADD-先交换后相加" class="headerlink" title="XADD 先交换后相加"></a>XADD 先交换后相加</h4><ul>
<li><code>XADD EAX, ECX</code>：先交换两个参数的值，然后进行加法运算，运算结果保存在第一个参数中；</li>
<li>这个指令其实是 XCHG 和 ADD 两个简单指令的组合；</li>
</ul>
<h4 id="NEG-取反"><a href="#NEG-取反" class="headerlink" title="NEG 取反"></a>NEG 取反</h4><ul>
<li><code>NEG EAX</code>：操作数符号取反；</li>
</ul>
<h3 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h3><h4 id="AND-OR-XOR-NOT"><a href="#AND-OR-XOR-NOT" class="headerlink" title="AND / OR / XOR / NOT"></a>AND / OR / XOR / NOT</h4><ul>
<li>全部以二进制形式进行比较（操作）；</li>
<li><code>AND EAX, ECX</code>：双 1 为 1，否则为 0；</li>
<li><code>OR EAX, ECX</code>：逢 1 为 1，否则为 0；</li>
<li><code>XOR EAX, ECX</code>：不同为 1，相同为 0；</li>
<li><code>NOT EAX</code>：二进制取反（按位取反）；</li>
</ul>
<h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h4><ul>
<li><code>CMP EAX, ECX</code>：两个参数相减进行比较，如果运算结果为 0，则 <code>ZF（0 标志位）</code>为 1；</li>
<li>通用寄存器、内存地址和立即数之间可以相互比较；</li>
<li>相当于 SUB 指令，但相减的结果不保存，只影响 0 标志位，当两个参数相等时，0 标志位置 1；</li>
</ul>
<h4 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h4><ul>
<li><code>TEST EAX, EAX</code>：判断 EAX 自身是否为 0；</li>
<li>如果运算结果为 0，且 ZF（0 标志位）为 1，则说明 EAX 自身为 0；</li>
<li>与<code>AND</code>相同，仅改变标志位而不改变操作数的值，若 2 个操作数中的一个为 0，则运算结果为 0，ZF 置 1；</li>
</ul>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h4 id="JMP-无条件跳转"><a href="#JMP-无条件跳转" class="headerlink" title="JMP 无条件跳转"></a>JMP 无条件跳转</h4><ul>
<li><code>JMP 00401018</code>：无条件跳转；</li>
</ul>
<h4 id="JE-JZ"><a href="#JE-JZ" class="headerlink" title="JE / JZ"></a>JE / JZ</h4><ul>
<li><code>ZF（0 标志位）</code>为 1 则跳转；</li>
<li>结果为 0 则跳转；</li>
</ul>
<h4 id="JNE-JNZ"><a href="#JNE-JNZ" class="headerlink" title="JNE / JNZ"></a>JNE / JNZ</h4><ul>
<li><code>ZF（0 标志位）</code>为 0 则跳转；</li>
<li>结果不为 0 则跳转；</li>
<li>与<code>JE / JZ</code>相反；</li>
</ul>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><ul>
<li><code>SF（符号位标志位）</code>为 1 则跳转；</li>
<li>结果为负则跳转；</li>
</ul>
<h4 id="JNS"><a href="#JNS" class="headerlink" title="JNS"></a>JNS</h4><ul>
<li><code>SF（符号位标志位）</code>为 0 则跳转；</li>
<li>结果不为负则跳转；</li>
<li>与<code>JS</code>相反；</li>
</ul>
<h4 id="JP-JPE"><a href="#JP-JPE" class="headerlink" title="JP / JPE"></a>JP / JPE</h4><ul>
<li><code>PF（奇偶标志位）</code>为 1 则跳转；</li>
<li>结果中 1 的个数为偶数则跳转；</li>
</ul>
<h4 id="JNP-JNPE-JPO"><a href="#JNP-JNPE-JPO" class="headerlink" title="JNP / JNPE / JPO"></a>JNP / JNPE / JPO</h4><ul>
<li><code>PF（奇偶标志位）</code>为 0 则跳转；</li>
<li>结果中 1 的个数为奇数则跳转；</li>
<li>与<code>JP / JPE</code>相反；</li>
</ul>
<h4 id="JO"><a href="#JO" class="headerlink" title="JO"></a>JO</h4><ul>
<li><code>OF（溢出标志位）</code>为 1 则跳转；</li>
<li>结果溢出则跳转；</li>
</ul>
<h4 id="JNO"><a href="#JNO" class="headerlink" title="JNO"></a>JNO</h4><ul>
<li><code>OF（溢出标志位）</code>为 0 则跳转；</li>
<li>结果没有溢出则跳转；</li>
<li>与<code>JO</code>相反；</li>
</ul>
<h4 id="JB-JNAE"><a href="#JB-JNAE" class="headerlink" title="JB /JNAE"></a>JB /JNAE</h4><ul>
<li><code>CF（进位 / 借位 标志位）</code>为 1 则跳转；</li>
<li>小于则跳转（无符号数）；</li>
<li>JB 不关注符号位，只关注无符号位的运算；</li>
</ul>
<h4 id="JNB-JAE"><a href="#JNB-JAE" class="headerlink" title="JNB / JAE"></a>JNB / JAE</h4><ul>
<li><code>CF（进位 / 借位 标志位）</code>为 0 则跳转；</li>
<li>大于等于则跳转（无符号数）；</li>
<li>与<code>JB</code>相反；</li>
</ul>
<h4 id="JBE-JNA"><a href="#JBE-JNA" class="headerlink" title="JBE / JNA"></a>JBE / JNA</h4><ul>
<li><code>OF（溢出标志位）为 1</code>或<code>ZF（0 标志位）为 1</code>则跳转；</li>
<li>小于等于则跳转（无符号数）；</li>
</ul>
<h4 id="JNBE-JA"><a href="#JNBE-JA" class="headerlink" title="JNBE / JA"></a>JNBE / JA</h4><ul>
<li><code>OF（溢出标志位）为 0</code>并且<code>ZF（0 标志位）为 0</code>则跳转（都为 0）；</li>
<li>大于则跳转（无符号数）；</li>
<li>与<code>JBE</code>相反；</li>
</ul>
<h4 id="JL-JNGE"><a href="#JL-JNGE" class="headerlink" title="JL / JNGE"></a>JL / JNGE</h4><ul>
<li>小于则跳转（有符号数）；</li>
<li>与 JB 不同的是，JL 关注有符号位的运算；</li>
<li>JL 会忽略<code>CF（进位 / 借位 标志位）</code>的变化；</li>
</ul>
<h4 id="JNL-JGE"><a href="#JNL-JGE" class="headerlink" title="JNL / JGE"></a>JNL / JGE</h4><ul>
<li>大于等于则跳转（有符号数）；</li>
<li>与<code>JL</code>相反；</li>
</ul>
<h4 id="JLE-JNG"><a href="#JLE-JNG" class="headerlink" title="JLE / JNG"></a>JLE / JNG</h4><ul>
<li>小于等于则跳转（有符号数）；</li>
</ul>
<h4 id="JNLE-JG"><a href="#JNLE-JG" class="headerlink" title="JNLE / JG"></a>JNLE / JG</h4><ul>
<li>大于则跳转（有符号数）；</li>
</ul>
<h3 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h3><p>转移指令就是可以控制 CPU 执行内存中某处代码的指令，也称为跳转指令；</p>
<h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  s:</span>  <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>LOOP 相当于</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; XOR CX, CX</span></span><br><span class="line"><span class="comment">; MOV CX, 6</span></span><br><span class="line"><span class="keyword">DEC</span> <span class="built_in">CX</span></span><br><span class="line"><span class="keyword">TEST</span> <span class="built_in">CX</span>, <span class="built_in">CX</span>   <span class="comment">; CMP CX, 0</span></span><br><span class="line"><span class="keyword">JNZ</span> [<span class="keyword">DEC</span> <span class="built_in">CX</span> 所在的地址]</span><br></pre></td></tr></table></figure></li>
<li><p>与以上指令不同的是：LOOP 执行时第一次循环计数器不会自减；</p>
</li>
<li><p>约定俗成：使用 CX 作为计数器；</p>
</li>
</ul>
<h4 id="CALL-RETN"><a href="#CALL-RETN" class="headerlink" title="CALL / RETN"></a>CALL / RETN</h4><ul>
<li><p>CALL 可以理解为 CALLBACK；</p>
</li>
<li><p>CALL 会执行一个子程序，可以理解为执行了一个函数；</p>
</li>
<li><p>CALL 指令会进行两步操作，首先将当前 IP 或 CS 和 IP 压栈，然后转移；</p>
</li>
<li><p>RET 在 CALL 所执行的子程序中时，会返回该 CALL 所在的主程序，并继续向下执行；</p>
</li>
<li><p>RET 与其他指令单独使用时，和 JMP 的功能相同；</p>
</li>
<li><p>RET 指令用栈中的数据，修改 IP 的内容，从而实现近转移；</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POP</span> <span class="built_in">IP</span></span><br></pre></td></tr></table></figure></li>
<li><p>RETF 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移；</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POP</span> <span class="built_in">IP</span></span><br><span class="line"><span class="keyword">POP</span> <span class="built_in">CS</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>直接寻址：指令后面直接写出此次运算使用的地址，称为直接寻址；</li>
<li>间接寻址：只有执行到某一行指令才能知道此次运算使用的地址，称为间接寻址；</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>文章资料</category>
        <category>汇编知识</category>
      </categories>
      <tags>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理初探</title>
    <url>/posts/996855490/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-16">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>内存访问异常总结下来就一句话：在没有权限的地方做了没权限的事儿；</p>
</li>
<li><p>将任意<code>CrackMe</code>倒入<code>OD</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonfurw1oj31ff0u0gwo.jpg" alt="倒入OD"></p>
<ul>
<li><p>当前处于代码段，只有只读权限，如果要写入内容会怎么样？</p>
<p>修改第一行代码，把<code>EAX</code>的内容写入指定地址；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloniemvqrj31ff0u0gxc.jpg" alt="修改代码"></p>
<p>然后执行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonkvl23pj31ff0u0wq7.jpg" alt="访问违规"></p>
<p>可以看到，根本无法执行代码；</p>
</li>
<li><p>那每个代码段的权限如何查看呢？</p>
<ol>
<li><p>方法一：</p>
<p>打开<code>内存窗口</code>，找到<code>PE 头文件</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonoefqwhj31ff0u048w.jpg" alt="内存窗口"></p>
<p>然后双击<code>PE 头文件</code>所在行，打开<code>数据窗口</code>，找到 PE 头偏移量<code>Offset to PE signature</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonqf357jj31ff0u0k1l.jpg" alt="偏移量"></p>
<p>既然偏移量是 100， 那地址就是<code>00400100</code>，往下翻找到这个地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonx75sh8j31ff0u0499.jpg" alt="找到地址"></p>
<p>在这里，发现了代码段和数据段的地址信息，偏移量分别是 1000 和 2000，那地址就分别是<code>00401000</code>和<code>00402000</code>喽，如何确定呢？重载程序就知道了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glop9kcs3qj31ff0u049x.jpg" alt="起始位置"></p>
<p>至于它们的权限，继续往下翻：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloo34nk41j31ff0u0n80.jpg" alt="权限"></p>
<p>在这里可以清楚的看到，CODE 段只有只读权限，而 DATA 段有读写权限；</p>
</li>
<li><p>方法二：</p>
<p>在<code>数据窗口</code>按下<code>Ctrl + G</code>，转到<code>00400000</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glooawpu9qj31ff0u0alk.jpg" alt="转到表达式"></p>
<p>然后在<code>数据窗口</code>右键<code>指定 &gt; PE 头文件</code>，就可以定位到<code>PE 头文件</code>了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloofb56bhj31ff0u0qe1.jpg" alt="定位"></p>
<p>其他操作和方法一一致；</p>
</li>
</ol>
</li>
<li><p>测试一下修改代码段权限，写入内容：</p>
<p>在<code>数据窗口</code>选择代码段权限行，右键选择<code>修改整数</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glooklxgtpj31ff0u0dq1.jpg" alt="修改整数"></p>
<p>然后修改权限：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloonxmrfcj31ff0u0qeh.jpg" alt="修改成功"></p>
<p>修改后可以看到，CODE 段有写的权限了，然后将修改保存到新的可执行文件；</p>
<p>接着，将保存的新文件倒入<code>OD</code>并修改第一行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glop0ua22cj31ff0u0wqa.jpg" alt="打开新文件"></p>
<p>运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glop2jpw4zj31ff0u013f.jpg" alt="运行程序"></p>
<p>可以看到，<code>EAX</code>的内容成功写入到以指定地址为开始的位置；</p>
</li>
</ul>
</li>
<li><p>最后，来说说一个小的知识点<code>除零异常</code>；</p>
<p>刚上学开始学习加减乘除的时候，老师就告诉我们 0 不能作为除数，而在程序设计中，当遇上正整数除以零程序会中止：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glov7g67kij31ff0u013c.jpg" alt="调试语句"></p>
<p>在这里，由于<code>EAX</code>自身为 0，为了区分被除数和除数，让<code>EAX</code>加上一个随机的立即数以区分，这里以 123 为例，接着通过<code>xor</code>让准备作为除数的<code>ECX</code>置 0，最后用<code>EAX</code>除以<code>ECX</code>，接下来，看一下运算的结果：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glovdctagcj31ff0u049u.jpg" alt="除零异常"></p>
<p>可以看到，执行<code>DIV ECX</code>后，也就是除以 0 后，这里产生了一个异常，这个异常就叫作除零异常；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理流程小记</title>
    <url>/posts/192684570/</url>
    <content><![CDATA[<h4 id="异常处理流程图"><a href="#异常处理流程图" class="headerlink" title="异常处理流程图"></a>异常处理流程图</h4><hr>
<p><strong><em>懒得折腾了，更新就挂，看图最靠谱；</em></strong></p>
<hr>
<p><del>已经写好<code>Mermaid</code>的语法，准备输出流程图了，发现<code>Hexo</code>的<code>mermaid</code>插件已是多年前的产物，不兼容最新的版本，无奈只能用<a href="https://app.diagrams.net/">draw.io</a>画了张图；</del></p>
<p><del>最稳妥的方案是根据官方文档定义 mermaid 语法块，而不是使用 markdown 语法，例如：</del></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">graph TD</span><br><span class="line">  A[test] --&gt;|Get money| B(Go shopping)</span><br><span class="line">  B --&gt; C&#123;Let me think&#125;</span><br><span class="line">  C --&gt;|One| D[Laptop]</span><br><span class="line">  C --&gt;|Two| E[iPhone]</span><br><span class="line">  C --&gt;|Three| F[fa:fa-car Car]</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>

<!-- htmlmin:ignore -->

<pre class="mermaid">

graph TD
A[&quot;系统发现产生了一个异常&quot;] --&gt; B{&quot;程序是否正在被调试&quot;}
B --&gt; |&quot;是，程序正在被调试&quot;| C{&quot;权限转给调试器，并判断调试器是否忽略了异常&quot;}
C --&gt; |&quot;是，忽略了&quot;| D{&quot;程序是否安装 SEH&quot;}
D --&gt; |&quot;是，安装了&quot;| E{&quot;SEH 是否解决异常&quot;}
E --&gt; |&quot;是，解决了&quot;| F[&quot;程序可以继续正常运行&quot;]
B --&gt; |&quot;否，程序没有被调试&quot;| D
C --&gt; |&quot;否，未忽略，但未能解决异常&quot;| G[&quot;系统默认异常处理流程&quot;]
D --&gt; |&quot;否，未安装&quot;| G
E --&gt; |&quot;否，未解决&quot;| G
</pre>

<!-- htmlmin:ignore -->

<p>图片镇楼：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glprz3752lj31ay0u0tcd.jpg" alt="图片镇楼"></p>
<span id="more"></span>

<p>总结一下上图，共有 7 种流程：</p>
<p>1.<code>系统发现异常</code> -&gt; <code>是否调试状态</code> -&gt; <code>是</code> -&gt; <code>交给调试器处理</code> -&gt; <code>调试器是否忽略异常</code> -&gt; <code>是</code> -&gt; <code>检查是否安装 SEH</code> -&gt; <code>已安装</code> -&gt; <code>是否解决异常</code> -&gt; <code>已解决</code> -&gt; <code>程序继续运行</code>；</p>
<p>2.<code>系统发现异常</code> -&gt; <code>是否调试状态</code> -&gt; <code>是</code> -&gt; <code>交给调试器处理</code> -&gt; <code>调试器是否忽略异常</code> -&gt; <code>是</code> -&gt; <code>检查是否安装 SEH</code> -&gt; <code>已安装</code> -&gt; <code>是否解决异常</code> -&gt; <code>未解决</code> -&gt; <code>系统默认异常处理流程</code>；</p>
<p>3.<code>系统发现异常</code> -&gt; <code>是否调试状态</code> -&gt; <code>是</code> -&gt; <code>交给调试器处理</code> -&gt; <code>调试器是否忽略异常</code> -&gt; <code>是</code> -&gt; <code>检查是否安装 SEH</code> -&gt; <code>未安装</code> -&gt; <code>系统默认异常处理流程</code>；</p>
<p>4.<code>系统发现异常</code> -&gt; <code>是否调试状态</code> -&gt; <code>是</code> -&gt; <code>交给调试器处理</code> -&gt; <code>调试器是否忽略异常</code> -&gt; <code>否</code> -&gt; <code>是否解决异常</code> -&gt; <code>否</code> -&gt; <code>系统默认异常处理流程</code>；</p>
<p>5.<code>系统发现异常</code> -&gt; <code>是否调试状态</code> -&gt; <code>否</code> -&gt; <code>检查是否安装 SEH</code> -&gt; <code>已安装</code> -&gt; <code>是否解决异常</code> -&gt; <code>已解决</code> -&gt; <code>程序继续运行</code>；</p>
<p>6.<code>系统发现异常</code> -&gt; <code>是否调试状态</code> -&gt; <code>否</code> -&gt; <code>检查是否安装 SEH</code> -&gt; <code>已安装</code> -&gt; <code>是否解决异常</code> -&gt; <code>未解决</code> -&gt; <code>系统默认异常处理流程</code>；</p>
<p>7.<code>系统发现异常</code> -&gt; <code>是否调试状态</code> -&gt; <code>否</code> -&gt; <code>检查是否安装 SEH</code> -&gt; <code>未安装</code> -&gt; <code>系统默认异常处理流程</code>；</p>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>文章资料</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>最后一次异常法定位 OEP</title>
    <url>/posts/2614075303/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-2">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>拿到 CM 后，第 1 想法就是栈平衡，将 CM 导入原版 OD：</p>
<p>首先弹出警告弹窗，说明程序有壳（这不是废话嘛）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwou1dw2sj31eb0u0n0j.jpg" alt="将 CM 导入原版 OD"></p>
<p>然后到达 EP 位置，行首却不是 PUSHAD/PUSHFD，这就让人很尴尬了，不过又想到了栈平衡的第 2 种方法；</p>
</li>
<li><p>大胆的猜测一下，如果 OEP 行首是压栈指令，那么压栈的地址就是：0012FFC0:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwp0hlhrej31eg0u0aez.jpg" alt="压栈的地址"></p>
<p>所以，给 0012FFC0 设置硬件写入断点，然后运行程序；</p>
</li>
<li><p>程序会中断两次，第 2 次才会到达 OEP，因为第 2 中断时才处于代码段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwp87zzrwj31e70u043k.jpg" alt="OEP"></p>
</li>
<li><p>然后又尝试了设置访问断点来到达 OEP，两种方法皆是可行的，不过这 3 种方法并不是今天的重点；</p>
</li>
<li><p>将程序导入改版 OD，<code>F9</code>运行程序，待程序主窗体出现后，打开日志窗口（请不要关闭程序主窗体）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwpf8lzy7j31a80u0diy.jpg" alt="一大堆异常"></p>
<p>来到日志窗口后，发现程序运行期间，有一大堆异常，但程序却正常运行了，很是奇怪；</p>
</li>
<li><p>程序可以正常运行，是因为 OD 的调试选项忽略了所有异常，如果不忽略异常，程序会在每一次异常时暂停，而在最后一次异常后，程序正常运行了；</p>
<p>如果在最后一次异常时（也可以说是程序运行前）给代码段设置内存访问断点，是否可以到达 OEP 呢？</p>
</li>
<li><p>首先设置 OD 调试选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwpwb6stlj31ab0u077r.jpg" alt="不忽略异常"></p>
<p>在日志窗口可以看到，最后一次异常是 INT3，所以取消忽略 INT3 异常，同时取消忽略异常范围选项，因为从 00000000 ～ FFFFFFFF 就忽略了所有异常；</p>
</li>
<li><p>然后运行程序，在几次中断后，就来到了最后一次异常所在位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwq3u0p0fj31a50u00wx.jpg" alt="最后一次异常"></p>
</li>
<li><p>来到内存窗口，给代码段设置<code>内存执行断点</code>，然后按下<code>Shift + F9</code>忽略异常并运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwq6yj16mj31a50u077g.jpg" alt="OEP"></p>
<p>程序到达 OEP，Perfect！</p>
</li>
<li><p>既然有那么多方法，问什么要用这么复杂的方法呢？</p>
<p>是因为，加壳不仅可以隐藏 OEP，还可以反调试，而为了绕过反调试，在执行部分代码后，再设置断点相对会更安全，这是一种好的思路；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>栈平衡原理定位 OEP</title>
    <url>/posts/810738268/</url>
    <content><![CDATA[<blockquote>
<p>加壳软件必须保证外壳初始化的现场环境（各寄存器的值）与原程序的现场环境是相同的；</p>
<p>加壳后的程序在初始化时保存各寄存器的值，待外壳执行完毕再恢复各寄存器的内容，最后跳转到原程序执行；</p>
<p>通常，加壳后的程序在开始时使用 PUSHAD/PUSHFD 来保护现场，外壳执行完毕后，使用 POPAD/POPFD 恢复现场；</p>
<p>也就是说，加壳软件必须遵守栈平衡原理；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="https://upx.github.io/">UPX</a>，感谢 🙏 开源；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ol>
<li><p>首先，使用 UPX 压缩 CM；</p>
</li>
<li><p>将加壳后的 CM 导入 OD 后，查看 EP 以及 ESP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw6ny7gdpj31dy0u0n1f.jpg" alt="查看 EP 以及 ESP"></p>
<p>EP 处使用 PUSHAD 备份当前各通用寄存器的值，然后将会在外壳执行完毕后再使用 POPAD 恢复各寄存器的值，以保证程序到达 OEP 时，寄存器的内容保持不变；</p>
<p>此时 ESP 的值为：0012FFC4；</p>
</li>
<li><p><code>F7</code>单步执行程序，也就是执行<code>PUSHAD</code>指令后，8 个通用寄存器的内容压入栈：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw6w8i7qej31dw0u0n1f.jpg" alt="通用寄存器的内容压入栈"></p>
</li>
<li><p>加壳程序必须遵守栈平衡原理，所以在执行完毕后，一定会访问栈以恢复各寄存器的内容，所以给处于栈中的任意寄存器内容设置硬件访问断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw766d18oj31e00u0wjp.jpg" alt="硬件访问断点"></p>
<p>这里以 EAX 寄存器的内容为例，使用<code>HR 12FFC0</code>，设置硬件访问断点；</p>
<p>设置完毕后，可以在调试菜单，硬件断点选项下看到已经设置的硬件断点；</p>
</li>
<li><p>运行程序后， 程序中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw7dshoraj31du0u0wje.jpg" alt="程序中断"></p>
<p>中断位置的 POPAD 访问了保存在栈中的寄存器内容，触发了断点；</p>
<p>同时，各寄存器已经恢复到 EP 时的状态，ESP 重新指向 0012FFC4，说明栈中保存的内容被丢弃了，使用后释放，这就是堆栈平衡；</p>
</li>
<li><p><code>F7</code>单步执行程序，程序跳转到 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw7lk3f4oj31du0u0q6p.jpg" alt="OEP"></p>
<p>此时各寄存器的内容以及 ESP 的值与程序处于 EP 时保持一致；</p>
</li>
<li><p>可以把整个外壳理解为一个函数或子程序，在执行过程中会遵守栈平衡原理，所以当外壳执行完毕跳转到 OEP 时，ESP 的值保持不变；</p>
</li>
</ol>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><ol>
<li><p>大多数程序 OEP 的第 1 行指令都是压栈指令（PUSH）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw7w7ivrjj31e30u0teo.jpg" alt="都是压栈指令（PUSH）"></p>
</li>
<li><p>向栈压入数据时，栈指针减小，向低地址移动；从栈中弹出数据时，栈指针增加，向高地址移动；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw832cqgjj31ds0u0wiq.jpg" alt="向栈压入数据时"></p>
<p>以当前 CM 为例，执行<code>PUSH 0</code>后，ESP 由 0012FFC4 指向 0012FFC0，地址减小了，这是程序到达 OEP 后执行的第 1 条指令；</p>
</li>
<li><p>反向思考一下，如果给 0012FFC0 设置写入断点，是不是就可以到达 OEP？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw8bcwefcj31du0u079d.jpg" alt="设置硬件写入断点"></p>
<p>将程序载入 OD 后，程序停留在 EP 位置，此时的 ESP 为 0012FFC4，根据栈平衡原理，外壳执行完毕后，ESP 保持不变，所以，OEP 的第 1 条 PUSH 指令，会将内容写入 0012FFC0（向栈压入数据时，栈指针减小，向低地址移动）；</p>
<p>确定写入地址后设置硬件写入断点<code>HW 0012FFC0</code>；</p>
</li>
<li><p>运行程序后，程序中断在代码段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw8jjzzdlj31dy0u0q7q.jpg" alt="程序中断在代码段"></p>
<p>可以看到，由于<code>PUSH 0</code>指令向 0012FFC0 写入内容，从而触发了硬件写入断点，导致中断，而这里就是 OEP；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>UPX</tag>
      </tags>
  </entry>
  <entry>
    <title>硬编码寻找序列号（一）</title>
    <url>/posts/2293324257/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-1">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<span id="more"></span>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy1j9yekwj30oc065t9q.jpg" alt="分析"></p>
<p>就是它了，选中它并右键<code>在输入函数上切换断点</code>，然后去<code>断点窗口（B 窗口）</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后运行程序，“随便输入”一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序停在了设置断点的<code>API</code>的行首，在堆栈窗口可以看到<code>API</code>的各种参数，而参数<code>Buffer</code>里存放着函数返回的数据，选中<code>Buffer</code>右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy267st5oj30t00drq4u.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下<code>Ctrl + F9</code>或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现<code>Buffer</code>对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下<code>F7 或 F8</code>，返回到调用<code>API</code>的程序，发现接下来将要执行的代码很可疑：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy2kqa9a0j30sz0dt0uo.jpg" alt="程序"></p>
<p>一个比较，一个跳转，并且文字显示和序列号有关；</p>
</li>
<li><p>分析一下这几行可疑的代码：</p>
<ul>
<li><p><code>MOV EDX,CrackMe.00403008</code>将<code>00403008</code>这个地址拷贝到<code>EDX</code>，执行一下这行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy2xlpyn3j308805374d.jpg" alt="EDX"></p>
<p>在<code>EDX</code>存放的地址中发现一串可疑字符串，选中<code>EDX</code>右键<code>数据窗口中跟随</code>，原来可疑字符串只是前面几位，而后面那几个字符是我们输入的字符；</p>
</li>
<li><p><code>MOV EBX,DWORD PTR DS:[403010]</code>将<code>00403010</code>这个地址中的数据的前四个字节拷贝到<code>EBX</code>，执行一下这行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy3ehrs27j30as0ay3zf.jpg" alt="EBX"></p>
<p>既然<code>EBX</code>中存放的是数据，而数据又看不懂，怎么知道是什么呢？<code>OD</code>很强大，选择那行代码并右键<code>数据窗口中跟随，然后选择内存地址</code>或者在数据窗口选中那行代码的数据并选择<code>数据窗口中跟随地址</code>就可以看到<code>EBX</code>中存放的内容了，原来是我们输入的“序列号”；</p>
</li>
<li><p><code>CMP EBX,DWORD PTR DS:[403008]</code>这行代码就没什么好说的了，减法比较是否相等，还使用了一个障眼法，<code>EDX</code>放地址，<code>EBX</code>放数据，在这里再取出<code>EDX</code>的数据进行比较；</p>
</li>
<li><p><code>JE SHORT CrackMe.00401087</code>这行也没啥说的，<code>JE</code>根据<code>ZF 标志位</code>进行跳转，而如果上一步的计算结果为<code>0</code>，则<code>ZF</code>为<code>1</code>，<code>JE</code>跳转成立，也就是说，如果<code>EDX</code>和<code>EBX</code>中的数据相同，那么序列号就是对的，<code>JE</code>跳转并向下执行，最后弹出<code>正确！</code>，反之则不跳转向下执行，弹出<code>序列号错误！</code>，看来第一步中发现的可疑字符串就是真正的序列号了；</p>
</li>
<li><p>如果想要输入啥都能通过验证，那么可以将<code>JE</code>改为<code>JMP</code>无条件跳转，保存修改到文件就获得了一个新的程序；</p>
</li>
<li><p>但我们的目的是找出真正的序列号，所以嘛，复制那串字符去试一下，果然，一切如我们所料！</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>硬编码寻找序列号（三）</title>
    <url>/posts/4122547819/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-3">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<span id="more"></span>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><h5 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h5><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
<ul>
<li><p>这个 CrackMe 不一般，有两个部分，两个按钮，那就分两部分分析喽（这句话绕不绕）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeer5jilj309a0740su.jpg" alt="CrackMe"></p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyek762n6j30k20cgq4j.jpg" alt="第一部分"></p>
<p>很好的开始，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeq2lafej311s0kx415.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，多么令人兴奋的内容，这么简单吗，会不会有诈？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeumc7cqj30m60bbmyl.jpg" alt="第一部分找到了"></p>
</li>
<li><p>那就分析一下，看看到底是啥：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyf5uv9tsj30nc0b1gms.jpg" alt="第一部分结束"></p>
<p>看来第一部分很简单，逻辑简单粗暴，只要不对直接弹出错误；<br>第一部分到此结束。<br>既然第一部分这么简单，那难点肯定在第二部分，去看看！</p>
</li>
</ul>
</li>
</ol>
<h5 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h5><ul>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，还是那个可疑的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfexxb79j30kc0cmabo.jpg" alt="第二部分"></p>
<p>很好的开始，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfhdwjazj311o0l076u.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，哦豁，好像没啥有用的内容，等等，下面还有个<code>GetWindowTextA</code>，对对，我们输入了用户名和密码，那就得获取两次，而第一次获取的是密码，那就<code>F9</code>再运行程序；</p>
</li>
<li><p>是的，又获取了一次，而这次获取的是用户名，执行到用户代码，果然是下面这个<code>GetWindowTextA</code>，那下面就是比较的代码了呗，毕竟它位于获取和弹窗之间；</p>
</li>
<li><p>那就分析一下它的流程：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfxtvb0yj30ng0ecq43.jpg" alt="开始"></p>
<ul>
<li><p>第一行<code>TEST EAX, EAX</code>不迷茫，<code>TEST EAX, EAX</code>表示检查<code>EAX</code>自身是否为 0，而第二行的<code>JE SHORT 硬编码寻.0040167E</code>指向了一个<code>MessageBoxA</code>，那就说明<code>EAX</code>很重要，既然弹窗提示的是<code>必须输入用户名才可以</code>，那它不是用户名的长度是什么，况且<code>EAX</code>里的数据刚好和用户名长度相同；</p>
</li>
<li><p>接下来，它对用户名做了一系列的运算，并把运算的结果放到了指定的内存中，暂时还不知道它想干嘛：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyh5fsj3gj30ox082753.jpg" alt="用户名"></p>
</li>
<li><p>同样的，又对输入的假序列号进行了一系列运算，并把运算结果放到了指定的内存中，不过相对于用户名，序列号的处理比较简单，只是进行了除法运算，并存储了余数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyh8v4k4vj30oz05faah.jpg" alt="假码"></p>
</li>
<li><p>直到序列号运算完毕，一个<code>JMP</code>跳下来，分析之后，终于知道了它要干什么：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyhc0gpmtj30oy08ddgr.jpg" alt="比较"></p>
<p>原来，它上面进行的一系列运算，是为这一步的比较做准备；</p>
</li>
<li><p>至此，终于分析出了结果：这里没有硬编码，而是软编码，序列号是根据用户名计算出来的</p>
</li>
<li><p>至于计算的规则：</p>
<ul>
<li><p>用户名的运算规则：用户名的下标从零开始，每个字节依次和<code>A</code>进行除法运算，然后用余数和下标异或之后的值加 2；</p>
</li>
<li><p>序列号的运算规则：序列号的每个字节和<code>A</code>进行除法运算，然后用余数和用户名运算的结果进行比较；</p>
</li>
<li><p>序列号的算法：任意数字和<code>A</code>进行乘法运算，并加上用户名每个字符运算的结果就是这个用户名对应的序列号，运算的结果必须可以转为<code>ASCII</code>码中的数字；</p>
</li>
<li><p>例如：</p>
<ul>
<li><p>用户名： yang</p>
</li>
<li><p>运算的结果：03 08 04 02</p>
</li>
<li><p>序列号算法：<code>5 * A + 3 = 35</code> <code>4 * A + 8 = 30</code> <code>5 * A + 4 = 36</code> <code>5 * A + 2 = 34</code></p>
</li>
<li><p>转成 ASCII：5064</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyhyvwfqlj30d2074aaa.jpg" alt="成功"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>硬编码</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>硬编码寻找序列号（二）</title>
    <url>/posts/3097998650/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-2">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy5o1g2gpj30g90bwjsq.jpg" alt="函数"></p>
<p>很好的开始，在<code>GetDlgItemTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy5y9rif4j30sr0fsq51.jpg" alt="运行"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，哇，密密麻麻全是汇编语句，往下翻了翻，也没发现什么关键字、有用的信息，接着<code>F9</code>运行，直接弹出了错误信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy69uwm08j303z03z0sn.jpg" alt="弹窗"></p>
</li>
<li><p>看来此路不通啊，但是“程序给我们关上了一扇门，同时又开了一扇窗”，没错，就是它，弹窗，在最开始的函数列表中也有它的身影<code>MessageBoxA</code>，那就从它入手试试；</p>
</li>
<li><p>禁用<code>GetDlgItemTextA</code>并设置<code>MessageBoxA</code>断点，重新运行程序，输入并运行程序后，拦截到了即将要弹出的信息，信息显示在堆栈窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy6hpjnooj30ug0i0wgm.jpg" alt="错误"></p>
<p>如果程序继续运行，将弹出<code>错误！</code>弹窗；</p>
</li>
<li><p>堆栈窗口的顶部显示的是调用信息，包括调用地址、返回地址等</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy6m2r60qj30cw05q0t2.jpg" alt="堆栈"></p>
</li>
<li><p>堆栈顶端，也就是当前<code>ESP</code>指向的堆栈中则是调用地址，也就是说这个地址调用了<code>MessageBoxA</code>这个<code>API</code>，根据程序的流程：程序经过比较之后，发现序列号不对，所以调用<code>MessageBoxA</code>并弹出错误窗口。<br>按照这个逻辑，如果跟随调用地址，是不是就能找到程序进行比较的代码？那还等什么，右键堆栈顶端的地址（堆栈中被标注黑色背景的地址就是堆栈顶端）选择<code>反汇编窗口中跟随</code>，就来到了调用<code>MessageBoxA</code>的程序，查看上面的代码，发现了一些端倪：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy7fm1cz5j30ue0j8jur.jpg" alt="调用"></p>
<p>上面有一个<code>JNZ</code>跳转进来，从而调用了<code>MessageBoxA</code>，所以弹出了错误弹窗，而<code>JNZ</code>的下面还有一个<code>MessageBoxA</code>，那可以猜测，如果不跳转继续向下执行，很有可能弹出的就是注册成功的弹窗，<code>JNZ</code>根据<code>ZF 标志位</code>进行跳转，如果修改<code>ZF 标志位</code>为<code>1</code>，就可以验证一下猜测是否正确，如何修改呢，继续往上翻代码，嘿嘿，发现一个有用的东西<code>GetDlgItemTextA</code>，在调用地址双击数据窗口设置<code>CC断点</code>，重载程序</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy84b4uhoj30uc0j7acn.jpg" alt="重载"></p>
</li>
<li><p>输入并运行程序后，在最后设置断点的地方停了下来，那下面就是要执行的代码了，分析一下看能不能找到隐藏的序列号：</p>
<ul>
<li><p>才分析了几行代码，有一种上了恶当的感觉，感觉它在转移某些内容，就暂且将它转移的内容称为“可疑字符串”：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy8q1uc0zj30p50740ts.jpg" alt="序列号"></p>
</li>
<li><p>不管了，继续分析，依然没有收获：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy90t76crj30om05zjrs.jpg" alt="没有收获"></p>
</li>
<li><p>直到分析了一个轮回，终于有了收获，程序会用我们输入的序列号的每一个字节的机器码减 14 后，和指定的机器码进行比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy9zbazz5j30p10ac75f.jpg" alt="循环"></p>
</li>
<li><p>而我们利用<code>MessageBoxA</code>断点，分析的<code>JNZ</code>的跳转条件是：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyb22if59j30p10hewgy.jpg" alt="JNZ"></p>
</li>
<li><p>如何让条件成立呢？恰恰在我们没有分析到的代码，因为我们输入的序列号是错误的，所以正确的代码根本不会执行，更谈不上分析了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybg7od2pj30p20acjsn.jpg" alt="正确"></p>
<p>在这里，如果是正确的序列号，那么每次比较完成后，<code>EBP - 10</code>和<code>EBP - 34</code>作为两个计数器，它们会正确的同时自增，在最后的比较长度时也就会相等了；</p>
</li>
</ul>
</li>
<li><p>所以，正确的序列号是什么呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybxcwm3ej30p00abjtb.jpg" alt="序列号"></p>
<ul>
<li>在比较的位置设置断点，获取每次比较时给定的字符的机器码，然后加上 14，最后转为 ASCII 码，就是正确的序列号；</li>
<li>获取到的给定字符的机器码：<code>1D 1E 1F 44 61 51 3C 5B 36 55 51</code>；</li>
<li>字符的机器码加 14 之后的值：<code>31 32 33 58 75 65 50 6F 4A 69 65</code>；</li>
<li>转换为 ASCII 码后的值：123XuePoJie；</li>
</ul>
</li>
<li><p>最后，完整的分析图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyciwo9jqj30y80u0tf0.jpg" alt="完整图"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>硬编码寻找序列号（五）</title>
    <url>/posts/755681865/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-5">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<span id="more"></span>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻还真不少，善用搜索，<code>GetDlgItemTextA</code>没找到，那就试试<code>GetWindowTextA</code>，还真有，就它了，在<code>GetWindowTextA</code>上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p><code>F9</code>运行程序，然鹅，输入内容并点击验证按钮后，程序并没有暂停；</p>
</li>
<li><p>界面有按钮，试试消息断点，还是没用，又尝试<code>硬件断点</code>以及<code>内存断点</code>均无效；</p>
</li>
<li><p>使用一个特殊的<code>API：TranslateMessage</code>，没错，它的功能就是字面的意思<code>翻译虚拟按键消息为字符消息</code>，很好很强大；</p>
</li>
<li><p>在<code>API</code>列表页面搜索，还真有，设置断点，然后在<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，还没有完，在断点上右键<code>断点&gt;&gt;条件记录</code>或者<code>Shift + F4</code>（也就是<code>条件记录断点</code>，毕竟<code>API断点</code>的本质就是<code>CC断点</code>），修改条件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjea06qzj311u0nfad3.jpg" alt="TranslateMessage"></p>
</li>
<li><p>然后运行程序，输入并点击验证，程序在<code>TranslateMessage</code>函数的行首暂停下来，然后<code>Ctrl + F9</code>或者点击菜单栏的调试选项并选择<code>执行到返回</code>，然后<code>F8</code>单步执行到程序领空；</p>
</li>
<li><p>然后在<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，搜索输入的序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjv4k2qij311w0ngn0d.jpg" alt="查找"></p>
<p>找到最接近<code>输入的序列号</code>的内容，设置<code>内存访问断点</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjz6z1umj311m0n7tc9.jpg" alt="内存访问断点"></p>
</li>
<li><p>运行程序，程序暂停在了读取序列号的地方，开始分析：<br>好聪明的“程序”，开始转移数据了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizk98xwaej313w0ncdis.jpg" alt="转移数据"></p>
</li>
<li><p>既然它都挪窝儿了，咱也别闲着了：在<code>EDI</code>上右键选择<code>数据窗口中跟随</code>,果然，输入的序列号在这里了，选择序列号的数据右键<code>断点&gt;&gt;删除内存访问断点</code>删除第一次设置的<code>内存访问断点</code>，也可以理解为设置在<code>ESI</code>上的<code>内存访问断点</code>，既然数据都转移了，断点也就没意义了，所以要重新设置在<code>EDI</code>上，再次选择序列号的数据右键<code>断点&gt;&gt;内存访问</code>，这样就实时掌握了输入的序列号的动向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizko5erudj31450o7gpl.jpg" alt="EDI"></p>
</li>
<li><p>继续运行程序，终于来到来最关键的地方：比较</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizlfw3ua4j313q0s4dky.jpg" alt="比较"></p>
<p>分析完毕，逻辑简单粗暴：</p>
<ul>
<li>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>最后，恢复寄存器的内容并<code>RETN</code>，直接弹出错误的弹窗；</li>
</ul>
</li>
<li><p>分析的时候已经发现了正确的序列号，也就是可疑字符串，试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizm3afyiyj30am0btacd.jpg" alt="完工"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>硬编码寻找序列号（六）</title>
    <url>/posts/1208254864/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件：<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-3">中文搜索引擎</a>和<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-4">ApiBreak</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-6">CrackMe</a>【歪坑牌 CM2.2】来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
<ul>
<li><p>这个软件的操作有点不同寻常，填写内容之后会提示注册成功，并且通过重启来验证是否正确：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ctzk1nmj30vq089dh5.jpg" alt="流程"></p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻还真不少，搜索一下，<code>GetDlgItemTextA</code>没找到，那就试试<code>GetWindowTextA</code>，还真有，在<code>GetWindowTextA</code>上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p><code>F9</code>运行程序，输入并点击登录之后，还是熟悉的弹窗，点击弹窗的确定按钮之后，嘿，又回到了解放前，这让我很困惑，难道它是在弹窗之后运行吗？毫无头绪；</p>
</li>
<li><p><code>TranslateMessage</code>呢？没有 Buffer，无从下手；</p>
</li>
<li><p>给<code>MessageBox</code>设置断点？皮，它都重启了，断点有什么*用，逆推呢？设置断点跟随之后发现没有什么有价值的内容；</p>
</li>
<li><p>试一试<code>内存断点</code>，暂停的地方不重要而且在断点位置无限循环，根本连登录按钮都点不了，既然都没有登录肯定没有验证，断点的地方当然不重要了；</p>
</li>
<li><p>试试<code>消息断点</code>，暂停了，但没有 Buffer，无从下手；</p>
</li>
<li><p>试试<code>中文搜索引擎</code>：</p>
<ul>
<li><p><code>中文搜索引擎</code>不只是找关键字的，还可以找到其它有用的信息，而恰恰这才是重点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0e6c5pycj312m0ksmzu.jpg" alt="关注点"></p>
</li>
<li><p>如果看到<code>software</code>说明这个程序使用了注册表，而关键信息可能就存储在注册表中：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ear0vunj31220kyjsu.jpg" alt="注册表"></p>
</li>
<li><p>既然它将输入的内容存储在注册表中，那么验证的时候一定会去注册表取回内容，所以这个节点才是关键的环节，重载程序，删除之前设置的无用断点，接下来就是重点了；</p>
</li>
<li><p>至于如何设置断点呢，那就要使用今天的主角儿了<code>ApiBreak</code>，点击菜单栏的插件选项并选择<code>ApiBreak &gt;&gt; API断点</code>，然后选择<code>注册表</code>以及<code>RegQueryValueExA</code>选项之后，点击确定;(翻译一下<code>RegQueryValueExA</code>：<code>Reg</code>是注册表，<code>Query</code>是查询，<code>Value</code>是值，<code>ExA</code>是 16 进制，连起来应该是<code>设置查询注册表16进制值的断点</code>，不知道对不对)</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0eovwbz4j312m0kv77d.jpg" alt="设置断点"></p>
<p>当然，也可以直接使用系统 API<code>RegQueryValueExA 或 RegQueryValueExW</code>来设置断点，这个插件就是简化了操作步骤，不用我们去寻找系统 API；</p>
</li>
<li><p>设置好断点之后，运行程序，程序会中断多次，应该是查询了很多次，但我们的关注点只是两个：<code>用户名</code>和<code>密码</code>，那就继续运行程序，直到在堆栈窗口看到需要的信息：</p>
<p><code>用户名</code>出现了两次，第一次<code>Buffer</code>中没有地址，第二次<code>Buffer</code>中才有地址，第二次才是我们关注的重点， 在<code>Buffer</code>上右键<code>数据窗口中跟随</code>，然后<code>Ctrl + F9</code>执行到返回，果然，它获取了我们输入的用户名：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0f4rlxcbj312j0kttc1.jpg" alt="用户名"></p>
<p>同样的情况也会出现在<code>密码</code>身上，继续运行程序，获取密码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0fbu0phrj312i0kvgp0.jpg" alt="密码"></p>
</li>
<li><p>既然它已经获取了用户名和密码，那就上正菜吧：<br>获取密码后，在<code>Buffer</code>上右键<code>数据窗口中跟随</code>，然后<code>Ctrl + F9</code>执行到返回，果然，它获取了我们输入的密码，在<code>数据窗口</code>选中密码数据右键<code>断点 &gt;&gt; 内存访问</code>设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0fkgngw7j312k0kqdi4.jpg" alt="内存访问断点"></p>
</li>
<li><p>然后继续运行程序，程序中断了，但看了看代码发现这里不是重点，而且继续运行还会中断，数一数，中断的次数刚好是密码的长度，并且每运行一次，<code>ESI寄存器</code>中存储的密码都会向后移动一位；</p>
</li>
<li><p>继续运行程序，程序再次中断，重点来了，开始分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1rveiykej312e0rfwj6.jpg" alt="分析完毕"></p>
<p>分析完毕，逻辑似曾相识的感觉，没错，和<code>逆向分析之硬编码寻找序列号（五）</code>中的逻辑一模一样：</p>
<ul>
<li>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>最后，恢复寄存器的内容并<code>RETN</code>，然后弹窗，最后回到解放前；</li>
</ul>
</li>
</ul>
</li>
<li><p>分析完了，那真正的密码是什么呢？当然就是“可疑字符串”：一串看起来杂乱无章的字符，那密码的计算规则又是什么呢？</p>
<p><code>RETN</code>返回的地方永远是调用它的位置的下一行，那如果跟着<code>RETN</code>是不是就能找到调用它的地方，结果是肯定的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0laiieabj312h0rfadz.jpg" alt="调用"></p>
<p>如果<code>JNZ</code>是返回的位置，那上面一行的<code>CALL</code>就是调用的地方，如何证明呢？很简单，<code>JNZ</code>根据<code>ZF 标志位</code>跳转，如果跳转肯定就注册失败了，那不跳转是不是就成功了？试一试，将<code>ZF 标志位</code>置 1，然后运行程序，正如所料，注册成功：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0lezrrqtj30bi067t8s.jpg" alt="注册成功"></p>
<p>这就说明，这个<code>CALL</code>很重要，给<code>CALL</code>的位置设置断点，重载程序，程序在<code>CALL</code>的位置暂停，既然<code>CALL</code>内部是判断，那上面很可能就是获取并处理了，既然正确的密码是一串杂乱无章的字符，那么它应该需要一个<code>CALL</code>去处理，所以，大胆的猜测一下，上面那个<code>CALL</code>可能就是处理程序，给上面那个<code>CALL</code>也设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0lu3l9iuj312g0rfq7j.jpg" alt="处理"></p>
<p>再次重载程序，程序中断，<code>F8</code>向下执行，查看中间那两行代码干了什么，很有可能就是判断<code>CALL</code>（也就是函数）的参数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0m4afip8j312g0rh78w.jpg" alt="参数"></p>
<ul>
<li>两行代码执行后，<code>EAX</code>的数据在<code>寄存器窗口</code>看的很清楚，就是我们输入的假码；</li>
<li>而<code>EDX</code>的数据是什么呢？选中<code>EDX</code>右键<code>数据窗口中跟随</code>，数据一目了然，正是比较时用的可疑字符串；</li>
<li>这也就证明了，上面那个<code>CALL</code>就是处理数据用的；</li>
<li>而密码的规则：在好多个<code>CALL</code>之间跳来跳去分析之后，发现是一串固定的字符串加上用户名的 16 进制表示；</li>
<li>如：<code>yang</code>转换成 16 进制是<code>79616E67</code>，那么密码就是<code>€队蠹易仿耄79616E67</code>；</li>
</ul>
</li>
<li><p>测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0mxfxvr3j30v508p758.jpg" alt="测试"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>硬编码寻找序列号（四）</title>
    <url>/posts/1116999438/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件：<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-3">中文搜索引擎</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-4">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><p>事实证明：不能“以貌取人”。</p>
<p>刚打开软件的时候，心里还想着，这么简陋？分分钟就逆向完毕了，结果，“啪啪啪”实力打脸，针扎的疼。</p>
<ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻，呀呵，看着简陋，用的<code>API</code>还真不少，那就搜索吧，没有<code>GetDlgItemTextA</code>？那就拿<code>GetWindowTextA</code>下手吧：在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>居然没有断下来，也没有弹窗，这让我很尴尬：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8frx378j305905zglj.jpg" alt="尴尬"></p>
</li>
<li><p>嗯，界面有按钮，那就试试消息断点，熟练的设置好<code>消息断点</code>，运行程序，输入，点击按钮，还是没有断下来；</p>
</li>
<li><p>不怕，还有<code>内存断点</code>、<code>硬件断点</code>，挨个试了一遍之后，没有一个成功的，灰心丧气呀，怎么像刺猬 🦔 一样无从下手？</p>
</li>
<li><p>等等，看了看程序的界面，猛的想起了大佬说的一个工具：</p>
<p><code>中文搜索引擎</code>：这玩意儿可以参考，但不要过分依赖，友好的开发者可能只是关闭你的程序不让你调试，至于不友好的，知道为啥要用虚拟机吗？</p>
</li>
<li><p>重载程序，在<code>反汇编窗口</code>右键选择<code>中文搜索引擎</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8ldzoguj311o0njq5w.jpg" alt="中文搜索引擎"></p>
<p>然后<code>Ctrl + F</code>搜索熟悉的字眼儿<code>Wrong Code DUDE</code>，果然有，双击来到<code>反汇编窗口</code>，嘿嘿，这里看起来很重要嘛：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8xso4qtj30m90by402.jpg" alt="关键"></p>
<ul>
<li>一个失败的字样；</li>
<li>一个成功的字样；</li>
<li>紧挨着上面有一个跳转：可以猜测，如果跳转的话，可能就显示成功了；</li>
<li>跳转上面是一个<code>CALL</code>，那它很可能是比较的<code>CALL</code>；</li>
<li>至于更上面的代码，那肯定是获取用的呗，瞎猜的；</li>
</ul>
</li>
<li><p>既然找到了可疑的代码，那就双击<code>CALL</code>给它下一个<code>CC断点</code>，然后运行程序，输入序列号点击验证后，程序暂停在了<code>CALL</code>的位置，那就<code>F7</code>进<code>CALL</code>看看，验证一下猜测；</p>
</li>
<li><p>刚一进<code>CALL</code>，就在寄存器窗口发现了熟悉的字样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz99kl1svj311n0nlgoq.jpg" alt="call"></p>
<p>既然把“序列号”都传进来了，那应该就是比较了，开始分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizaftudazj30xb0u0n15.jpg" alt="分析"></p>
</li>
<li><p>分析完成，比较的部分是常规方法，就是中断程序有点麻烦！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>编译语言特点定位 OEP</title>
    <url>/posts/4132012963/</url>
    <content><![CDATA[<blockquote>
<p>各类语言编译的文件入口点都有自己的特点；</p>
<p>使用同一种编译器编译的程序，其入口代码都很类似，都有一段启动代码，编译器在编译程序时会自动与程序连接；</p>
<p>在完成必需的初始化工作后，调用 WinMain 函数，该函数执行完毕，启动代码将再次获得控制权，进行初始化清除工作；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="https://upx.github.io/">UPX</a>，感谢 🙏 开源；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>将 CM 导入 OD，此时未加壳，EP 即是 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnxboon3q2j31ek0u00we.jpg" alt="EP 即是 OEP"></p>
<p>可以看到， 第 1 个调用的函数是<code>GetModuleHandleA</code>；</p>
</li>
<li><p>使用 UPX 加密 CM，然后导入 OD：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnxbruvqiuj31e40u0420.jpg" alt="使用 UPX 加密 CM"></p>
<p>在 EP 处使用<code>Ctrl + G</code>跳转至 GetModuleHandleA 函数的行首，然后设置 F2 断点；</p>
</li>
<li><p>运行程序后，程序中断在断点位置，goto 到栈顶指针指向的位置，就到达了 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnxbwwuu6uj31e60u00xa.jpg" alt="到达了 OEP"></p>
</li>
<li><p>如果对常见语言的入口代码比较熟悉，就可以很容易的完成脱壳修复或定位 OEP 等工作，这就需要大量积累了；</p>
</li>
<li><p>由于采用默认的启动代码对软件进行加壳保护不是很有利，一些开发人员会对启动源代码进行修改，这时程序的入口点与默认的就完全不同了；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>UPX</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳小练习（一）</title>
    <url>/posts/2471182341/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-2">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-3">PETools</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>将 CM 导入 OD，使用内存访问法定位 OEP（这种方式设置的断点是一次性的）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0wlp01l2j31dz0u0diq.jpg" alt="F2 断点"></p>
<p>原理是：加壳程序运行时，会依次解压各区段，所以，访问后会中断；</p>
</li>
<li><p>运行程序后，程序中断两次：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0woppgmtj31e00u0jv3.jpg" alt="第一次重点"></p>
<p>中断后查看提示信息，程序访问了代码段，所以触发了断点，再次运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0wqml26dj31e30u0djj.jpg" alt="第二次中断"></p>
<p>程序再次中断，程序访问了第 2 个设置断点的区段，此时说明代码段已经解压完成了；</p>
</li>
<li><p>再次来到内存窗口，给代码段设置 F2 断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0wve0v2wj31e60u041p.jpg" alt="再次设置断点"></p>
<p>原理是：既然代码段已经解压完毕了，如果再次访问，就是原程序运行的时候；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0x0nx0ndj31e00u0q7e.jpg" alt="到达 OEP"></p>
<p>从模块中删除分析后，就可以看到程序的本来面目了；</p>
</li>
<li><p>然后打开 PETools，选择当前 CM 进程，右键菜单选择完整转存并保存到可执行文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0x64np0kj314y0u0adf.jpg" alt="PETools"></p>
</li>
<li><p>回到 OD，定位到 IAT，查看 IAT 起始位置（RVA）及结束位置（RVA），计算 Size：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0x9gmecfj31dt0u0q6v.jpg" alt="定位到 IAT"></p>
<p>通过 GetVersion 函数的地址，定位到 IAT；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xenogn6j31e10u0jvs.jpg" alt="计算 RVA"></p>
<p>通过计算得知：</p>
<ul>
<li>OEP 的 RVA 为：271B0；</li>
<li>IAT 的 起始地址 RVA 为：60818；</li>
<li>IAT 的 Size 为：60F28 - 60818 = 710（Hex）；</li>
</ul>
</li>
<li><p>打开 ImportREC 填写相关选项并获取：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xk307itj30wi0oqt9p.jpg" alt="填写选项"></p>
<p>获取完成后，检查获取的数据：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xlkacwwj30wi0oo3zu.jpg" alt="检查"></p>
<p>手动或通过显示无效选项检查获取数据是否有效；</p>
<p>确认无误后点击修复转存按钮，选择转存的程序，就完成修复了；</p>
</li>
<li><p>将修复后的程序导入 OD，查看 log 窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xswrszgj31dy0u0ju8.jpg" alt="log"></p>
<p>没有异常，说明程序正常运行；</p>
<p>然后定位到 IAT，随便选择一个函数，右键菜单查看可执行文件，到达函数 IMAGE_THUNK_DATA 结构体；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xuvyplsj31e50u00wl.jpg" alt="查看可执行程序"></p>
<p>这里存放的是函数名字符串的 RVA，<code>Ctrl + G</code>跳转到 VA 查看函数名字符串；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0y4g6n1sj31dy0u0wlb.jpg" alt="确认 IAT"></p>
<p>确认函数名和 IAT 显示的函数名一致，脱壳完成；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>IAT</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳小练习（二）</title>
    <url>/posts/2304111146/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-5">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-3">PETools</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>将 CM 导入 OD，在尝试了<code>内存访问法</code>和<code>栈平衡法</code>都不能到达 OEP 后，使用 SPOD（Special OD，个人称呼）配合<code>常用函数法</code>最终到达 OEP；</p>
</li>
<li><p>将 CM 导入 SPOD，goto 到 GetProcAddress 函数的行首，设置条件记录断点，记录调用 GetProcAddress 函数的地址及参数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1ysq1mtyj31a90u0goz.jpg" alt="条件记录断点"></p>
<p>清空 log，然后运行程序；</p>
</li>
<li><p>打开 log 窗口，对比各区段偏移后，发现外壳最后一次调用 GetProcAddress 函数的地址为 00478095：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1yw9u35dj31a50u0acu.jpg" alt="最后一次调用"></p>
<p>重载程序，修改条件记录断点为条件断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1z1co1n6j31a40u0tbn.jpg" alt="条件断点"></p>
<p>然后运行程序；</p>
</li>
<li><p>程序中断后，给代码段设置内存执行断点，取消其它断点，运行程序；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1z3ur4g5j31a10u0goy.jpg" alt="删除模块分析"></p>
<p>删除模块分析后，确认程序到达 OEP；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1zat8x4kj319z0u0dl7.jpg" alt="IAT"></p>
<p>跟随任意 CALL，确认有调用输入函数后，继续跟随即可定位 IAT，此处为间接调用；</p>
</li>
<li><p>查看 IAT 的起始地址和结束地址，计算 Size；</p>
<p>OEP 的 RVA 为：40300；<br>IAT 的起始地址 RVA 为：430F0；<br>IAT 的结束地址 RVA 为：43674；<br>IAT 的 Size = 43674 - 430F0 = 584；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1zjm7x68j31a60u0tcs.jpg" alt="计算 RVA"></p>
</li>
<li><p>使用 PETools 将内存数据 Dump 并保存为可执行文件；</p>
</li>
<li><p>打开 ImportREC，填写相关选项，然后获取输入表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1znp815mj30wk0osdh9.jpg" alt="ImportREC"></p>
<p>检查没有无效信息，修复程序；</p>
</li>
<li><p>程序可以运行，将程序导入 OD，检查 IAT：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go1zynliujj31a40u0422.jpg" alt="检查 IAT"></p>
<p>检查任意函数的名称字符串：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go200xh5ztj31a10u079p.jpg" alt="函数的名称字符串"></p>
<p>都没有问题，脱壳完成！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>IAT</tag>
        <tag>FSG</tag>
      </tags>
  </entry>
  <entry>
    <title>软编码寻找序列号（一）</title>
    <url>/posts/4167455493/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0t1wtpivj308z0anmxb.jpg" alt="开始"></p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，用的<code>API</code>不多，一眼就看到了<code>GetDlgItemTextA</code>，在<code>GetDlgItemTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，输入用户名和注册码，点击确定；</p>
</li>
<li><p>程序断下来了，在堆栈窗口选择<code>Buffer</code>右键<code>数据窗口中跟随</code>，没有数据，因为断点在行首，<code>Ctrl + F9</code>或者点击菜单栏调试选项，选择<code>执行到返回</code>，再去数据窗口中看看，有数据了，是我们输入的用户名；</p>
</li>
<li><p>再次运行程序，程序再次中断，不出意外应该是获取注册码，在堆栈窗口选择<code>Buffer</code>右键<code>数据窗口中跟随</code>，没有数据，<code>Ctrl + F9</code>或者点击菜单栏调试选项，选择<code>执行到返回</code>，再去数据窗口中看看，有数据了，是我们输入的注册码；</p>
</li>
<li><p>能获取到数据就是一个好的开始，<code>F7 或 F8</code>单步执行到程序领空，熟悉的字样映入眼帘：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tc5u51bj312e0t3q6p.jpg" alt="程序领空"><br>既有我们输入的内容，也有提示字样，应该就是这里了，那就开始分析；</p>
</li>
<li><p>前面的代码是堆栈平衡和清除弹窗的代码，进<code>CALL</code>之后，直接<code>ALT + F9</code>或者点击菜单栏调试选项，选择<code>执行到用户代码</code>；</p>
</li>
<li><p>需要分析的代码来了：刚分析了两行，发现了几行特别的代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tni2rn6j30oy03hmxm.jpg" alt="发现"></p>
<p>这几行代码，一个<code>push</code>然后紧跟着一个<code>CALL</code>，而且 push 的是我们输入的内容，这里应该就是关键了；</p>
</li>
<li><p><code>F7</code>进第 1 个<code>CALL</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tswn8jfj30ox01owee.jpg" alt="用户名call"></p>
<ul>
<li><p>刚进来第 1 行代码有困惑的吗？你咋知道是用户名放入<code>ESI 寄存器</code>？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tvmwgxqj312j0satc7.jpg" alt="第一行"></p>
<p>很简单，<code>[ESP+4]</code>告诉我的，<code>ESP 寄存器</code>永远指向堆栈的顶端，那<code>[ESP+4]</code>就是下一行喽，看一眼堆栈窗口，第二行的数据不正是我们输入的用户名吗？</p>
</li>
<li><p>接着，出现了第 2 处令人疑惑的代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0xi158x1j312n0b0q4t.jpg" alt="疑惑1"></p>
<p>机器码和<code>41</code>比较，这到底是啥意思？刚开始我也弄不明白，而且后面的逻辑也显示和<code>41</code>半毛钱关系没有，直到无意中在用户名输入了数字，弹出两次<code>注册失败</code>，才好像明白了这里判断的是啥？我们先看看 16 进制的<code>41</code>到底是什么：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0xochjx2j30b50bs3ys.jpg" alt="41"></p>
<p>原来<code>41</code>是大写字母<code>A</code>，而后面的<code>5A</code>则是大写字母<code>Z</code>，那我好像明白怎么回事儿了，它应该是在判断用户名是否是英文字母；</p>
</li>
<li><p>当字符的机器码大于<code>41</code>并且大于<code>5A</code>时，程序会跳转到一个新的<code>CALL</code>，那它干了什么呢：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0y7pkvqij312l0sc432.jpg" alt="新CALL"></p>
<p>可以看到，这里只有 3 行代码，我们分析一下，小写字母的机器码减去<code>20</code>是什么，没错，是对应的大写字母，这三行代码的作用就是：将用户名转换为大写字母，然后用大写字母替换用户名中的小写字母，然后返回：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0z4k7ifkj312m0sbn3m.jpg" alt="大写"></p>
<p>当用户名全部转为大写字母之后，又来到了一个<code>CALL</code>，这个<code>CALL</code>又是干什么的呢，<code>F7</code>跟进去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0zamesrsj312k0sbwic.jpg" alt="新CALL"></p>
<p>原来，是将转换为大写字母后的用户名的每个字节的机器码累加在一起，然后和<code>5678</code>异或，并把异或后的结果放入<code>EAX</code>并返回：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0zluaydsj312k0se0xd.jpg" alt="返回"></p>
</li>
</ul>
</li>
<li><p>用户名处理完了，接下来就是注册码了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ztl37fnj30oy03daa7.jpg" alt="比较"></p>
<p>刚从用户名的连环<code>CALL</code>里出来就这么刺激吗？把用户名运算后的结果和我们输入的注册码都 push 到了这个<code>CALL</code>里面，这里应该就是比较了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj10dmcv8zj30ox06cwey.jpg" alt="注册码"></p>
<p>结果很打脸啊，不是验证<code>CALL</code>而是运算注册码的<code>CALL</code>，而第一行的<code>PUSH EAX</code>只是个入栈而已。。。</p>
</li>
<li><p>验证环节</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj10q4hzwfj30k6063wf9.jpg" alt="验证"></p>
<p>根据<code>CALL</code>跳转的位置，轻松知道它的用途；</p>
</li>
<li><p>注册码的计算规则：</p>
<ul>
<li>用户名必须是字母；</li>
<li>将每个字母转为大写字母；</li>
<li>把每个字母的 16 进制累加在一起；</li>
<li>累加的结果与 5678 异或；</li>
<li>异或后的结果与 1234 异或；</li>
<li>将最后的结果转为 10 进制，注册码就出来啦；</li>
</ul>
</li>
<li><p>无图无真相</p>
<ul>
<li><p>例如：<code>yang</code>的大写<code>YANG</code>的 16 进制是<code>59 41 4E 47</code>；</p>
</li>
<li><p>加在一起是<code>59 + 41 + 4E + 47 &gt;&gt; 12F</code>；</p>
</li>
<li><p><code>12F</code>与<code>5678</code>异或<code>xor 12F, 5678 &gt;&gt; 5757</code>；</p>
</li>
<li><p><code>5757</code>与<code>1234</code>异或<code>xor 5757, 1234 &gt;&gt; 4563</code>；</p>
</li>
<li><p><code>4563</code>转为 10 进制后<code>17763</code>;</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj119l81wcj30b50csdg7.jpg" alt="上图"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>软编码寻找序列号（三）</title>
    <url>/posts/2238585999/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-9">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<ul>
<li><p>这是一个类似于蜘蛛纸牌的程序，需要安装，安装完成打开之后会提示输入注册码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2whju29rj310e0so0sw.jpg" alt="开始"></p>
</li>
<li><p>输入用户名和 6 位数字的注册码之后，发现<code>Ok</code>按钮无法点击：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wjvydm4j30ad07i746.jpg" alt="按钮"></p>
<p>有点意思，看来只有输入正确的序列号按钮才能点击，至于为啥注册码是 6 位数字，它不是已经说明了吗？</p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>猜测一下它的工作原理，如果在输入正确的注册码之后按钮可以点击，那就说明它会实时获取我们输入的内容并进行判断，这样的话，有用的应该就是<code>内存断点</code>了；</p>
</li>
<li><p>说干就干，既然要去内存中找我们输入的内容，那输入就一定得个性一点，起码不是内存中常见的，不然一找一大堆就无从下手了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wrgno31j309q06zmx1.jpg" alt="输入"></p>
</li>
<li><p>然后去<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，输入我们的序列号点击确定开始查找，记得勾选<code>区分大小写</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wtnjbibj30b806dglh.jpg" alt="查找"></p>
</li>
<li><p>输入的还算奇葩，只找到了一个：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wwddjlcj319s0rgaap.jpg" alt="查找结果"></p>
</li>
<li><p>设置<code>内存访问断点</code>，既然它都告诉我们是 6 位了，那就设置 6 个字节：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wytjh8dj319r0rct9e.jpg" alt="设置断点"></p>
</li>
<li><p>然后去程序界面再输入一个字符后，发现程序中断了，回到<code>OD</code>看看，嘿，它居然在转移数据，在数据窗口跟随一下<code>EDI</code>，果然是我们输入的假序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2x6v1zckj319p0qoq3v.jpg" alt="转移数据"></p>
</li>
<li><p>既然数据都挪窝儿了，那之前的断点也就没用了，选择<code>EDI</code>的数据右键<code>断点 &gt;&gt; 内存访问</code>重新设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xbtwkjcj319q0qmq3p.jpg" alt="新断点"></p>
</li>
<li><p>断点设置好之后，<code>F9</code>继续运行程序，程序再次中断，发现又在挪窝儿？怎么回事儿，挪窝儿这么快乐吗？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xgb4q4mj319p0rc3zj.jpg" alt="又一个断点"></p>
<p>重新设置<code>内存访问断点</code>，然后继续运行程序；</p>
</li>
<li><p>程序再次中断，并且有比较有跳转，这儿可能就是重点了，分析一下：</p>
<ul>
<li><p>第 1 行是：<code>EAX</code>的前 4 字节数据拷贝到<code>EDX</code>，<code>F7</code>单步执行，然后查看一下是什么东西：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xsh9gtlj319o0qnwfg.jpg" alt="查看EAX"></p>
<p>原来是我们输入的假序列号，前面还多了个<code>04</code>，应该是长度吧；</p>
</li>
<li><p>第 2 行是：<code>EDX</code>的前 4 字节数据拷贝到<code>EBX</code>，<code>F7</code>单步执行，然后查看一下是什么东西：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xx6m4ydj319o0qnab0.jpg" alt="查看EDX"></p>
<p>嘿嘿，一串可疑的数字，而且是 6 位，和序列号的规则很吻合，而且前面多了个<code>06</code>，应该也是长度；</p>
</li>
<li><p>接着往后分析，逻辑很常规，比较完前四个字节比较长度，都不相等就返回了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2y4ynby5j319s0qlgmp.jpg" alt="返回"></p>
</li>
</ul>
</li>
<li><p>结局没有悬念，用户名对应的序列号就是那串数字，不过，序列号是如何计算出来的呢？我们接着分析：</p>
<ul>
<li><p>我们都知道<code>RETN</code>返回的是调用位置的下一行，那跟着<code>RETN</code>去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2yc0ugkuj319u0qngml.jpg" alt="RETN"></p>
<p>按照程序的流程，既然这里是判断，那上面的就是获取和处理了，上面<code>CALL</code>不少，哪一个才是我们想要的那个呢，按照先获取后处理的流程来看，离我们最近的那个<code>CALL</code>应该是处理用的，但<code>CALL</code>上面那行代码看着也不像是给它传递参数，那就在这个<code>CALL</code>上设置断点，进去看看它是干嘛的；</p>
</li>
<li><p>设置好断点，重载程序并运行程序之后，程序都没有加载完成就中断了，既然都没有输入，那肯定不行啦，<code>F9</code>运行程序，起码运行到我们能输入内容；</p>
</li>
<li><p>然后，我们发现，输入用户名的时候，每输入一个字符都会中断一次，那就说明断点有效，虽然不知道这个<code>CALL</code>具体是干嘛的，但肯定和用户名有关，既然每次都中断，那就输入一次运行一次呗，直到用户名输入完成，还没有完，为了防止它没有完全获取用户名（鬼知道它是怎么获取的，万一是运行之后获取呢？），在输入完用户名最后一个字符之后，程序会再次中断，我们再运行程序一次，在序列号一栏中，输入一个字符，发现它中断了；</p>
</li>
<li><p>管它呢，反正用户名输入完了，也在序列号一栏输入字符了，能保证它获取了完整用户名就行，至于它是干啥的，<code>F7</code>进去看看不就知道了：</p>
<ul>
<li><p>刚分析了几行，发现它用同样的方法转移用户名，既然要知道序列号是怎么计算的，那肯定要跟着用户名喽，给<code>EDI</code>中的用户名数据设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2z03oif9j31ay0qqgmf.jpg" alt="用户名"></p>
</li>
<li><p>接着，<code>F9</code>运行程序，程序跳转到了这里，果然，这里就是用来生成序列号的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj30aheyyqj31az0qomy7.jpg" alt="小循环"></p>
<p>这里是一个完整的小循环，用来运算用户名的每一个字符，并且把结果累加，至于运算规则：</p>
<ul>
<li><p>字节下标从 1 开始；</p>
</li>
<li><p>字节机器码和下标相乘；</p>
</li>
<li><p><code>IMUL DWORD PTR DS:[EDX*4+4EB5D8]</code>这行代码中的所有特殊字符：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
<p>从上面的表格可以看出，用户名最大不能超过 16 进制的 14 位，也就是 10 进制的 20 位，代码中也一直和 14 做比较，当然，这是我的猜测，有兴趣的同学可以试试；</p>
</li>
<li><p>然后字节机器码和下标相乘的结果，和表格中对应下标的字符相乘；</p>
</li>
<li><p>接着，把每个字符运算的结果累加；</p>
</li>
<li><p>就这？这么简单？想多了；</p>
</li>
</ul>
</li>
<li><p>接着往下看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj30sq2vhsj31au0qn3zk.jpg" alt="余数"></p>
<p>在上一步，也就是那个小循环中，按照特定的规则运算了用户名的每一个字节，并把每个字节的运算结果进行累加，然后才是这一步，规则如下：</p>
<ul>
<li><p>上一步累加的最终结果和<code>A 的 6 次方</code>进行求余运算；</p>
</li>
<li><p>如果余数大于<code>A 的 5 次方</code>，进行下一步，也就是开始计算序列号，至于为什么要有这么个规定，如果你还记得序列号的规则，那就不会有什么疑惑了，因为只有余数大于<code>A 的 5 次方</code>，才能计算出 6 位数的序列号，看到这句话，是不是已经想到如何计算序列号了，追随你的心，是的，就是那样计算的；</p>
</li>
<li><p>如果余数小于<code>A 的 5 次方</code>，那么就重复执行上一步中的小循环，只不过，这一次的计算结果会累加在上一次计算的最终结果上，也就是，你只需要计算一个完整小循环，如果计算的结果求余<code>A 的 6 次方</code>小于<code>A 的 5 次方</code>，只需要把你计算的最终结果乘以 2，就是下次循环的计算结果，如果乘以 2 的结果求余<code>A 的 6 次方</code>还是小于<code>A 的 5 次方</code>，那就乘以 3 呗，以此类推；</p>
</li>
<li><p>不要急，下面就开始计算序列号了；</p>
</li>
</ul>
</li>
<li><p>接着，就到了计算序列号的<code>CALL</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj31e7p4jlj31ay0qmjsg.jpg" alt="计算序列号"></p>
<ul>
<li>这一步很简单，用累加结果求余<code>A 的 6 次方</code>，然后就是计算序列号的函数了；</li>
<li>到重点了，当然是<code>F7</code>进去看看喽；</li>
</ul>
</li>
<li><p>进<code>CALL</code>之后，你会很惊讶，因为真正的计算就简简单单几行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj31patcpxj31au0qk75i.jpg" alt="计算"></p>
<ul>
<li>用累加结果求余<code>A 的 6 次方</code>后的余数对<code>A</code>进行求余运算；</li>
<li>然后判断商是否为 0，不是 0 ，继续对<code>A</code>进行求余运算，直到商为 0；</li>
<li>把每次对<code>A</code>求余运算的余数加上 30 存起来；</li>
</ul>
</li>
<li><p>还没有结束，最后一步就是把上一步的结果逆序，然后就是真正的序列号了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj3278binyj31au0qmdh2.jpg" alt="剧终"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>啰哩啰嗦终于分析完了，总结一下注册码的生成规则：</p>
<ul>
<li><p>用户名必须小于 10 进制的 20 位，我也不确定啊，没试；</p>
</li>
<li><p>用户名字节的下标从 1 开始；</p>
</li>
<li><p>取用户名每个字节和它对应的下标进行乘法运算；</p>
</li>
<li><p>用每个字节运算的结果乘以对应下标的给定字符，给定字符如下，序号就是下标：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
</li>
<li><p>然后把每个字节乘以给定字符的结果相加；</p>
</li>
<li><p>用相加的结果求余<code>A 的 6 次方</code>，如果余数大于<code>A 的 5 次方</code>，向下执行；如果余数小于<code>A 的 5 次方</code>，用累加的最终结果乘以它的自然数倍数，如 2 倍或者 3 倍，直到最终结果求余<code>A 的 6 次方</code>的余数大于<code>A 的 5 次方</code>；</p>
</li>
<li><p>然后用上一步中的余数，也就是求余<code>A 的 6 次方</code>后的余数，对<code>A</code>进行求余运算，直到对<code>A</code>的求余运算商为 0；</p>
</li>
<li><p>把每次对<code>A</code>求余运算的余数加 30；</p>
</li>
<li><p>把余数加 30 后的数字逆序排列；</p>
</li>
<li><p>转为 10 进制就是用户名对应的序列号；</p>
</li>
</ul>
</li>
<li><p>说人话：</p>
<ul>
<li>16 进制的<code>A</code>是 10 进制的<code>10</code>;</li>
<li><code>A 的 6 次方</code>是<code>1000000</code>，也就是一百万；</li>
<li><code>A 的 5 次方</code>是<code>100000</code>，也就是十万；</li>
<li>也就是说，用户名累加的结果大于一百万的时候，这条规则才真正有意义，否则，对<code>A 的 6 次方</code>求余的余数永远是它自己；</li>
<li>至于为啥要大于<code>A 的 5 次方</code>，十万不就是最小的 6 位数吗？你不大于<code>A 的 5 次方</code>也就是不够 6 位，肯定不行喽；</li>
<li>至于对 10 求余的结果是什么，不用说了吧？</li>
<li>16 进制的<code>30</code>是什么，是 ASCII 码的<code>0</code>，所以，求余后加 0 的意义是什么？</li>
<li>总结：如果你输入的用户名运算的最终结果，转换为 10 进制是 6 位数字，那这个 6 位的数字就是注册码；如果小于 6 位，就用最终结果乘以 2 或 3 或 N，以此类推，直到是 6 位或更多位，当然，6 位最好，因为更多位需要求余 😊；</li>
</ul>
</li>
<li><p>无图无真相：</p>
<ul>
<li><p>例如：<code>crackme</code>的机器码是<code>63 72 61 63 6B 6D 65</code>；</p>
</li>
<li><p>每个字节和它对应的下标进行乘法运算：</p>
<table>
<thead>
<tr>
<th align="center">63 * 1</th>
<th align="center">72 * 2</th>
<th align="center">61 * 3</th>
<th align="center">63 * 4</th>
<th align="center">6B * 5</th>
<th align="center">6D * 6</th>
<th align="center">65 * 7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">63</td>
<td align="center">E4</td>
<td align="center">123</td>
<td align="center">18C</td>
<td align="center">217</td>
<td align="center">28E</td>
<td align="center">2C3</td>
</tr>
</tbody></table>
</li>
<li><p>用每个字节运算的结果乘以对应下标的给定字符：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">63 * D9</th>
<th align="center">E4 * 63</th>
<th align="center">123 * 58</th>
<th align="center">18C * 22</th>
<th align="center">217 * 3E</th>
<th align="center">28E * 93</th>
<th align="center">2C3 * F0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">53EB</td>
<td align="center">582C</td>
<td align="center">6408</td>
<td align="center">3498</td>
<td align="center">8192</td>
<td align="center">1778A</td>
<td align="center">296D0</td>
</tr>
</tbody></table>
</li>
<li><p>把每个字节乘以给定字符的结果相加：<code>53EB + 582C + 6408 + 3498 + 8192 + 1778A + 296D0 &gt;&gt; 5D4A3</code>；</p>
</li>
<li><p>对 10 求余再加 0 之类的操作就没必要了吧；</p>
</li>
<li><p>将<code>5D4A3</code>转换成 10 进制是<code>382115</code>；</p>
</li>
<li><p>输入用户名和注册码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj35sltkm7j30ld0gp0sz.jpg" alt="无图无真相"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>软编码寻找序列号（二）</title>
    <url>/posts/3362832349/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-8">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1lnjinquj307x04v0tf.jpg" alt="开始"></p>
<p>有点意思，输入内容之后没有任何提示，看来只有输入正确的序列号才会有提示；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>既然界面没有按钮，那就得先猜测它的工作原理了，如果它会在输入正确之后提示的话，那么它就是实时获取我们输入的内容并进行判断，这样的话，有用的应该就是<code>内存断点</code>了；</p>
</li>
<li><p>说干就干，既然要去内存中找我们输入的内容，那输入就一定得个性一点，起码不是内存中常见的，不然一找一大堆就无从下手了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1lnjinquj307x04v0tf.jpg" alt="输入"></p>
</li>
<li><p>然后去<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，输入我们的序列号点击确定开始查找，记得勾选<code>区分大小写</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m10r2ncj30b806e74c.jpg" alt="查找"></p>
</li>
<li><p>输入的还算奇葩，只找到了两个，选择第二个吧，虽然第一个是独立的，但它在内存中的范围不太像：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m2ueqnpj312j0nlgp6.jpg" alt="找到"></p>
</li>
<li><p>设置<code>内存访问断点</code>，长度随意，看心情，我就选 5 个字节了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m8qdz03j312i0noadj.jpg" alt="内存断点"></p>
</li>
<li><p>然后去程序界面再输入一个字符后，发现程序中断了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mbkjvz1j312k0npgob.jpg" alt="中断1"></p>
<p>不过中断的地方好像没什么用，我们输入的内容在<code>EDX</code>中，下面的代码段并没有操作它，<code>F9</code>继续运行程序；</p>
</li>
<li><p>刚一进程序领空就发现了亮点，这里好像就是比较了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mgimi9aj312i0nljub.jpg" alt="亮点"></p>
</li>
<li><p>分析一番之后发现，逻辑很常规：</p>
<ul>
<li><p>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</p>
</li>
<li><p>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步</p>
</li>
<li><p>最后，恢复寄存器的内容并<code>RETN</code>，然后就杳无音讯了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mp4qouej312g0qqdjn.jpg" alt="比较"></p>
</li>
</ul>
</li>
<li><p>至于正确的序列号，当然就是那串可疑字符串了，那这串字符是怎么来的呢，不能每次都这么找吧：</p>
<ul>
<li><p>我们都知道<code>RETN</code>返回的是调用位置的下一行，那跟着<code>RETN</code>去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mv3jb6bj312i0qnq6f.jpg" alt="调用位置"></p>
</li>
<li><p>按照程序的流程走，既然这里是判断，那上面的就是获取和处理了，上面有好几个<code>CALL</code>，哪一个才是我们想要的那个呢，按照先获取后处理的流程来看，离我们最近的那个<code>CALL</code>应该是处理用的，那么这个<code>CALL</code>上面那两行代码应该就是它的参数，在参数上设置断点，看看参数是什么就知道这个<code>CALL</code>的用途了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1n7mrqnaj312i0qp0w5.jpg" alt="重点"></p>
<p>设置断点，重载程序并运行后，程序中断了，但重点不在<code>反汇编窗口</code>，而是在<code>堆栈窗口</code>，我们发现了可疑字符串也就是正确的序列号，如果我们设置断点的这个<code>CALL</code>是处理函数的话，那么它还没运行怎么会出现正确的序列号呢？取消断点，在它上面那个<code>CALL</code>的参数上设置断点；</p>
</li>
<li><p>和上面的情况一样，程序中断后，在<code>堆栈窗口</code>，我们又发现了正确的序列号，再次取消断点，给它上面那个<code>CALL</code>设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1niua0lfj312g0qrgp0.jpg" alt="新断点"></p>
<p>这次就好多了，虽然没发现有用的数据但正确的序列号也没有出现，那这个<code>CALL</code>很可能就是生成序列号的函数了，<code>F7</code>跟进去看看，结果很丧气，它也不是；</p>
</li>
<li><p>那就接着往上呗，终于，在设置好断点，重载并运行程序之后有了欣喜的收获，用户名当作参数传递了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1o2fra1jj312j0qowhy.jpg" alt="真的重点"></p>
<p>虽然还没有运行代码，但信息窗口已经告诉我们它是什么了；</p>
</li>
<li><p>果断<code>F7</code>跟进去看看，都失败那么多次了，不差这一次：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1o7hfyf0j312h0qr0w3.jpg" alt="进CALL"></p>
<p>进来只有四行代码，但内容非常令人兴奋：这几行代码在检测有没有输入用户名；这就是一个好的开始，因为要操作数据的时候才会检测数据有没有输入；</p>
</li>
<li><p>从这个<code>CALl</code>里出来的窗口很熟悉，因为我们在这里已经操作了 3 次了，也失败了 3 次，这次将会是最后一次了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1ofq31sjj312h0qp78t.jpg" alt="多次操作"></p>
</li>
<li><p>这手灯下黑玩儿的漂亮，它一直在眼皮子底下计算序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1q8fz1njj312g0qmn0r.jpg" alt="序列号运算"></p>
<p>这就完了？那序列号呢？嘿嘿，在这里：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1qc14sgtj312i0qn42d.jpg" alt="序列号"></p>
<p>是的，运算结束后，虽然数据保存到了<code>EBP-C</code>的位置，但我们并没有弹栈，所以<code>EAX</code>没有被覆盖，双击<code>EAX</code>试试，对啦，将运算结果转为 10 进制就是这个用户名对应的序列号；</p>
</li>
</ul>
</li>
<li><p>序列号的算法：</p>
<ul>
<li>用户名最少两位；</li>
<li>用户名的下标从 1 开始；</li>
<li>取用户名每个字节和它对应的下标进行异或运算；</li>
<li>所有字节异或后的结果累加在一起；</li>
<li>取最后一个字节的机器码，与对应下标进行异或运算后，循环左移 C 位；</li>
<li>然后把左移的结果和所有字节异或后累加的结果相加；</li>
<li>最后把最终结果转换成 10 进制就是这个用户名对应的注册码；</li>
</ul>
</li>
<li><p>无图无真相</p>
<ul>
<li><p>例如：用户名<code>feng</code>对应的机器码是<code>66 65 6E 67</code>；</p>
</li>
<li><p>用户名的下标从 1 开始；</p>
</li>
<li><p>每个字节分别与它对应的下标进行异或运算<code>xor 66, 1 &gt;&gt; 67</code>，<code>xor 65, 2 &gt;&gt; 67</code>，<code>xor 6E, 3 &gt;&gt; 6D</code>，<code>xor 67, 4 &gt;&gt; 63</code>;</p>
</li>
<li><p>异或后的结果累加<code>67 + 67 + 6D + 63 &gt;&gt; 19E</code>;</p>
</li>
<li><p>取最后一个字节的机器码，与对应下标进行异或运算后，循环左移 C 位<code>xor 67, 4 &gt;&gt; 63</code>，<code>ROL 63, C &gt;&gt; 63000</code>;</p>
</li>
<li><p>然后把左移的结果和所有字节异或后累加的结果相加<code>63000 + 19E &gt;&gt; 6319E</code>；</p>
</li>
<li><p>转换成 10 进制<code>6319E &gt;&gt; 405918</code>；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1qoidbqcj30e409yq41.jpg" alt="真相"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之修改系统 DLL</title>
    <url>/posts/1859998567/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-19">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先运行软件，了解一下程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxyw10rtdj30w20o4go5.jpg" alt="运行程序"></p>
<p>运行程序后，首先弹出一个 NAG 窗口，点击 Register 后弹出程序主窗口，随机输入注册码并点击 OK 后，弹出错误弹窗；</p>
</li>
<li><p>寻找注册码</p>
<p>了解程序逻辑后，接下来需要解决注册码，因为机器码为自动生成，所以对于本机来说，这是一个硬编码，那就非常简单了；</p>
<ul>
<li><p>所见即所得，既然有弹窗，说明程序使用了<code>rtcMsgBox</code>；</p>
</li>
<li><p>随机输入后弹出错误弹窗，说明程序进行了字符串比较；</p>
</li>
<li><p>将程序倒入<code>OD</code>后，前两行代码说明了这是一个 VB 程序（这不是废话嘛，看文章标题就知道了）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyjydya2ij314u0u0gol.jpg" alt="前两行"></p>
<p>VB 程序有个特点：入口处都是一个 PUSH 指令，然后一个 CALL 指令；而且这里的 CALL 指令中的 JMP 后面跟着 MSVBVM60，也间接说明了这是 VB 程序；</p>
</li>
<li><p>接着，按下<code>Ctrl + N</code>查看函数列表，确定一下字符串比较使用的 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmylqjxfegj31550u0ad8.jpg" alt="函数列表"></p>
<p>在其中发现了<code>__vbaStrCmp</code>，程序应该是用这个函数判断真假注册码的；</p>
</li>
<li><p>既然知道了使用的 API，那就给这两个 API 设置断点，并做好备注，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyocxcyy3j314q0u0tbp.jpg" alt="断点禁用再启用"></p>
<p>运行程序后发现，由于<code>__vbaStrCmp</code>比较常用，多次中断在无关的位置，所以，暂时先禁用这个断点，等输入注册码后再启用，然后点击 OK；</p>
</li>
<li><p>程序中断两次，根据堆栈窗口的参数判断，第 1 次是机器码比较，第 2 次才是注册码比较，然后反汇编窗口跟随来到调用位置，在调用函数的参数上设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyon9iwpdj31510u0aem.jpg" alt="反汇编跟随"></p>
</li>
<li><p>禁用<code>__vbaStrCmp</code>断点，重载并运行程序后，程序中断在预期位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyovae4dmj314v0u0n1k.jpg" alt="重载并运行"></p>
<p>但是通过查看参数，发现这里不是理想的位置，应该是用于判断是否有输入；</p>
<p>既然这里不是需要的位置，那就清除此处的断点，启用<code>__vbaStrCmp</code>断点，继续跟踪，不过，在跟踪多次之后，还是遇到了刚开始时候的问题：由于<code>__vbaStrCmp</code>比较常用，会多次中断在无关的位置，那就放弃<code>__vbaStrCmp</code>吧，不是还有<code>rtcMsgBox</code>吗？</p>
</li>
<li><p>禁用<code>__vbaStrCmp</code>断点，重载并运行程序后，程序中断在<code>rtcMsgBox</code>的行首，反汇编窗口中跟随，来到调用位置，因为接下来就要弹窗了，所以字符串比较肯定在弹窗之前，往上翻阅代码，看看有没有<code>__vbaStrCmp</code>，别说，还真有，那还等什么，给<code>__vbaStrCmp</code>的参数设置断点，重载并运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmypbnl0qkj315f0u0djq.jpg" alt="收获"></p>
<p>单步执行程序后，收获颇丰，这里的第 2 参数不再是空，那这里就相当可疑了；</p>
</li>
<li><p>既然拿到了可疑的字符串，当然要试一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmypgwxn53j313c0ny40g.jpg" alt="满意"></p>
<p>嗯，这个弹窗甚是满意，这串字符就是本机机器码对应的真实注册码；</p>
</li>
</ul>
</li>
<li><p>4C 法移除 NAG 窗口</p>
<p>拿到注册码就结束了？当然不是，不觉得 NAG 窗口很烦人吗？那就去除它！</p>
<p>首先，第 1 想法就是<code>4C法</code>，简单粗暴，do it!</p>
<ul>
<li><p>程序倒入<code>OD</code>后，不要运行，<code>goto</code>到入口 PUSH 指令中的地址加上 4C 后的地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmypztaux7j314z0u0dks.jpg" alt="偏移后的地址"></p>
</li>
<li><p>然后在数据窗口，继续跟踪当前地址中存储的另一个<code>DWORD</code>地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyqa5b1fgj314s0u077j.jpg" alt="跟随 DWORD"></p>
</li>
<li><p>跟随<code>DWORD</code>来到数据窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyqjd343xj314c0diwf4.jpg" alt="结果类似的代码块"></p>
<p>这里有两个结构类似的数据块，每块 50(十六进制)个字节的长度,每块数据的第 24(十六进制)个字节处都有一个标志（第一个是 00，第二个是 04）；</p>
<p>而这个标志指定了代码块（也就是程序启动后要加载的窗体）出现的顺序，先加载 00，再加载 04；</p>
<p>大胆的猜测一下，由于 00 先加载，那 00 可能就是 NAG 窗口，而 04 则是主窗口，至于缺失的 01, 02, 03，可能是<code>Help</code> <code>Wrong</code>和<code>Okey</code>，因为它们都是子窗口，所以就不在这里吧；</p>
</li>
<li><p>所以，为了去掉 NAG 窗口，将此处的两个标志的值互换，即：00 改 04，04 改 00，这样， NAG 窗口就永远也没机会出现了，最后将修改保存到文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyqy5fclnj31550u00xk.jpg" alt="互换值"></p>
</li>
<li><p>最后，运行保存的文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyr2klk5sj312g0nmgn7.jpg" alt="运行"></p>
<p>没有出现 NAG 窗口，而是直接出现程序主窗体，接着，输入注册码，弹出 OK 弹窗；</p>
</li>
<li><p>以为这样就结束了？NO NO NO，4C 法并不是今天的重点，今天的重点是：修改系统 DLL；</p>
</li>
</ul>
</li>
<li><p>修改系统 DLL 移除 NAG 窗口</p>
<ul>
<li><p>首先，要用到修改版的<code>OD</code>，将程序倒入<code>OD</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn47zuerdlj31a80u0n05.jpg" alt="内存访问断点"></p>
<p>在<code>内存窗口</code>给<code>代码段</code>设置内存访问断点，然后运行程序；</p>
</li>
<li><p>多次运行程序后，来到程序的总分支，给所有跳转设置断点，了解它们的功能：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn482zrxcoj31a60u00w8.jpg" alt="总分支"></p>
<p>这好像是 VB 程序的一个特点，有一个类似交通枢纽的地方控制着程序的走向；</p>
</li>
<li><p>设置好断点后，重载并运行程序，程序会在设置断点的<code>JMP</code>位置依次中断，跟踪分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn489harmfj319u0u00vt.jpg" alt="分析JMP"></p>
<p>前三个已经满足了需求，至于其它几个，who cares?</p>
</li>
<li><p>既然已经知道了创建主窗体的跳转，去除 NAG 窗体还不简单，把创建 NAG 窗体的跳转改为创建主窗体的跳转不就结束战斗了？值得一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn48ia0i4oj31a30u0jv3.jpg" alt="修改 NAG"></p>
<p>复制创建主窗体的跳转并覆盖创建 NAG 窗体的跳转，然后保存修改到文件；</p>
</li>
<li><p>运行保存的程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn48lt1ea0j30w80kq400.jpg" alt="运行程序"></p>
<p>呃呃，并不是预期的结果，NAG 窗口还是出现了，不过，现在不用点击 Register，程序主窗体也会出现，也就是运行程序后，NAG 窗口和程序主窗体同时显示；</p>
</li>
<li><p>既然这样，以上做的都是无用功啦，直接去修改系统 DLL 它不香吗？</p>
<p>接下来的操作证明，这一步是修改系统 DLL 去除 NAG 窗口很关键的一步，至于重要在哪里，接着向下 👇</p>
</li>
<li><p>接下来使用的是原版汉化<code>OD</code>，有很多插件可以使用，<code>工欲善其事，必先利其器</code>嘛，而且修改版<code>OD</code>特殊的<code>内存访问断点</code>已经用不到了，<code>鸟尽弓藏</code>；</p>
</li>
<li><p>然后将保存的程序倒入<code>OD</code>，按下<code>Ctrl + G</code>转到<code>CreateWindowExA</code>函数并双击行首或按下<code>F2</code>设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn496ydgpqj31bd0u00wm.jpg" alt="goto 到 API"></p>
<p>既然程序有窗体，那它怎么也绕不开一个 API<code>CreateWindow</code>，至于这里为什么使用<code>CreateWindowExA</code>，而不是<code>CreateWindow</code>或<code>CreateWindowExW</code>，在<code>goto</code>窗口试试不就知道了；</p>
<p>认识一下<code>CreateWindow</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateWindow</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    该函数创建一个重叠式窗口、弹出式窗口或子窗口。</span><br><span class="line">    它指定窗口类，窗口标题，窗口风格，以及窗口的初始位置及大小（可选的）。</span><br><span class="line">    该函数也指定该窗口的父窗口或所属窗口（如果存在的话），及窗口的菜单。</span><br><span class="line">    若要使用除 CreateWindow 函数支持的风格外的扩展风格，则使用 CreateWindowEx 函数代替 CreateWindow 函数。</span><br><span class="line">    在 winuser.h 中根据是否已定义 Unicode 被分别定义为 CreateWindowW 和 CreateWindowA，然后两者又被分别定义为对 CreateWindowExW 和 CreateWindowExA 函数的调用。</span><br><span class="line">参数</span><br><span class="line">    LPCTSTR lpClassName,    &#x2F;&#x2F; 窗口类名称</span><br><span class="line">    LPCTSTR lpWindowName,   &#x2F;&#x2F; 窗口标题</span><br><span class="line">    DWORD   dwStyle,        &#x2F;&#x2F; 窗口风格，或称窗口格式</span><br></pre></td></tr></table></figure>

<p>参数很多非常多，在这里，关注的是第 2 和第 3 参数，也就是<code>WindowName</code>和<code>Style</code>；</p>
</li>
<li><p>设置好<code>CreateWindowExA</code>断点后，运行程序，程序中断后，在堆栈窗口可以看到：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn49z3divoj31au0u0jwv.jpg" alt="空标题"></p>
<p>前面的中断都不是需要的位置，而原因很简单，不管是 NAG 窗口还是程序主窗体都是有标题的，说明参数<code>WindowName</code>不可能为空；</p>
</li>
<li><p>那就继续运行程序，直到<code>WindowName</code>不为空：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn4a8d1hmcj30qo0kytar.jpg" alt="标题一样"></p>
<p>这次<code>WindowName</code>的值和 NAG 窗口的标题一模一样，就是它了；</p>
</li>
<li><p>然而，麻烦也来了，因为栈顶显示的很明白，调用来自<code>MSVBVM60.DLL</code>，这是个系统文件，所有程序共用此文件，如果因为这个程序而修改了系统文件，其它程序可能就会出错，怎么办？</p>
<p>当然有办法啦，和编程中的变量就近原则一样，调用也遵循这一原则，同名文件，谁离得近就用谁，那复制系统文件<code>MSVBVM60.DLL</code>到程序目录不就 OK👌 了？是的；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn4aqf3j34j31l70u0ae7.jpg" alt="私有 DLL"></p>
<p>复制系统 DLL 到程序目录后，就变成了私有 DLL，修改就不会污染全局了；</p>
</li>
<li><p>搞定了 DLL 文件，就要开始修改了，改什么？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn4az8oieqj31b70u0q6s.jpg" alt="修改 Style"></p>
<p>修改<code>CreateWindowExA</code>的参数<code>Style</code>的值，这里的<code>Style</code>有这么多的值，所以 NAG 窗口是一个有标题、按钮、文本以及层叠属性的窗体，而修改的目的很简单，就是让它成为不能拥有菜单，不能弹出的子窗体，对应的<code>Style</code>属性的值为<code>WS_CHILD</code>;</p>
<p>到了这里，理解深刻的同学可能已经知道了上个问题的答案：为什么要先修改交通枢纽的<code>JMP</code>跳转让程序运行时 NAG 窗口和主窗体同时显示后，然后才能修改系统 DLL 去除 NAG 窗口了；</p>
<p>因为这一步修改后，NAG 窗口不能弹出，没有按钮，那么按照之前程序的逻辑，点击 Register 按钮去触发主窗体就无从谈起了，因为修改后 Register 按钮已经不存在了，问题就来了：如果程序运行时 NAG 窗口和主窗体没有同时显示，如何在没有 Register 按钮的情况下，让主窗体显示？多么痛的领悟，卡了一天才恍然大明白！</p>
</li>
<li><p>修改<code>Style</code>属性，也就是窗口样式：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5g24yw5mj31b40u079i.jpg" alt="修改 Style"></p>
<p>可以看到，将<code>Style</code>的值修改为<code>40000000</code>后的属性值，正是想要的；</p>
<p>然后禁用<code>CreateWindowExA</code>断点，运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5gaj1760j31b30u0die.jpg" alt="堆栈修改运行"></p>
<p>程序主窗体直接出现，并没有出现 NAG 窗口，看来，此法可行；</p>
</li>
<li><p>但是，堆栈的修改只对本次运行有效，如何才能保存到文件呢？</p>
<p>那就要在代码上下功夫了，启用<code>CreateWindowExA</code>断点，重载并运行程序，到达理想的断点位置，跟随调用位置去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5h24o1e0j31ba0u0797.jpg" alt="调用位置"></p>
<p>不用看也知道调用是一个 CALL，因为<code>CreateWindowExA</code>是函数，既然要修改函数的<code>Style</code>参数，那肯定要在调用之前参数之后，而且还有一个条件：<code>WindowName</code>的值必须和 NAG 窗口相同，满足了这个条件，才能修改<code>Style</code>让它消失；</p>
<p>既有判断代码，还有操作代码，但这里并没有多余的空指令行来施展，多出来的这些代码要写在哪里呢？设想，如果修改这个 CALL 为跳转，跳转到某个位置，做一些操作之后再跳回来，是否可行？值得一试；</p>
<p>值得注意 ⚠️ 的是，修改既不能影响程序的运行，还需要达到目的，在这里 CALL 只有一行，也就是说，接下来的跳转也只能是一行，只能用间接寻址了；</p>
</li>
<li><p>首先复制原本 CALL 的代码，然后修改 CALL 为 JMP，跳转到空代码段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5i9ro3lij31b40u0jwe.jpg" alt="修改为 JMP"></p>
<p>因为目的是在 CALL 调用之前添加判断和操作代码，所以调用 CALL 的代码后面还会用到，需要复制到可靠的位置保留下来，至于跳转的空代码段，位置随意，看心情，但地址需要记得住，当然也可以复制地址到可靠的位置保存；</p>
</li>
<li><p>接下来就是到空代码段，写属于自己的逻辑：</p>
<ol>
<li><p>因为是间接寻址，所以，JMP 跳转的其实是当前地址中存储的地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5iqpnonlj31b30u0gqr.jpg" alt="地址为空"></p>
</li>
<li><p>所以要把真正的跳转地址写入当前地址的存储位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5j32i1wxj31au0u0n3m.jpg" alt="写入真实地址"></p>
<p>写入真实跳转地址后，再看 JMP，就发现，左侧的跳转提示有了，信息窗口的跳转地址不再是空了；</p>
</li>
<li><p>然后写属于自己的代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5kwjf4vgj31ba0u0gt1.jpg" alt="自己的代码"></p>
<p>首先，判断<code>WindowName</code>是否为 NULL，如果是 NULL，直接调用<code>CreateWindowExA</code>，如果不是，判断<code>WindowName</code>的前 4 字节和给定字符是否相等，不相等就直接调用<code>CreateWindowExA</code>，如果相等，说明是 NAG 窗口，则修改<code>Style</code>为<code>WS_CHILD</code>，然后调用<code>CreateWindowExA</code>，最后，调用结束后，需要用<code>JMP</code>回到程序原来的位置，至于给定的字符，其实就是 NAG 窗口标题的前 4 字节：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5l4hlhmuj31be0u0jw1.jpg" alt="给定字符"></p>
<p>如果想让程序更严谨一些，可以循环比较<code>WindowName</code>的值和 NAG 窗口的标题是否完全一致；</p>
</li>
</ol>
</li>
<li><p>修改完成后，就是保存修改到文件了，由于这里没有保存全部修改选项，只能分为两次保存：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5l7ihkm8j31b20u0n1f.jpg" alt="保存空代码段"></p>
<p>保存增加的代码到文件；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5liun36pj31b30u0jw8.jpg" alt="修改 CALl 为 JMP"></p>
<p>保存修改的 JMP 到文件；</p>
</li>
<li><p>然后运行程序，嗯？双击程序后，没有任何反应，看来修改出错了，程序被改坏了，不要着急删除，倒入<code>OD</code>看看出错在哪里？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5lyisgxxj31b50u0jw2.jpg" alt="位置不同"></p>
<p>可以看到，程序运行时，窗口标题和样式的堆栈位置前移了 4 个字节，应该就是这里出错了，修改代码并保存，然后重载程序，检查修改：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5m3jzeyij31b60u0wiy.jpg" alt="参数被修改"></p>
<p>程序运行自定义代码后，NAG 窗口在被创建前，<code>Style</code>属性的值已经被修改了；</p>
</li>
<li><p>运行程序并输入注册码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5me3bscwj31080u040o.jpg" alt="成功"></p>
<p>直接显示程序主窗体，输入注册码，显示 OK 弹窗！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>Windows</category>
        <category>VB 汇总</category>
      </categories>
      <tags>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>井字棋游戏</title>
    <url>/posts/3761999666/</url>
    <content><![CDATA[<h4 id="什么是井字棋"><a href="#什么是井字棋" class="headerlink" title="什么是井字棋"></a>什么是井字棋</h4><ol>
<li>在 3 * 3 的棋盘中，双方轮流放子，当某一方的三个子连成一线（行，列，对角）时，该方获胜；</li>
<li>如果棋盘已放满但并未出现三个子连成一线的情况，则打成平手；<span id="more"></span></li>
</ol>
<h4 id="游戏实现的思路"><a href="#游戏实现的思路" class="headerlink" title="游戏实现的思路"></a>游戏实现的思路</h4><h5 id="0-逻辑分析"><a href="#0-逻辑分析" class="headerlink" title="0. 逻辑分析"></a>0. 逻辑分析</h5><ol>
<li>首先提供一个选择菜单，有进入游戏和退出游戏选项；</li>
<li>显示棋盘，且每落子一次，都需要棋盘当前状态显示出来；</li>
<li>游戏开始，双方轮流落子，落子后判断输赢；</li>
<li>当一方获胜后，再次提供选择：退出游戏 or 再玩一次（我输了，我不服嘛，不过和非人工智能的电脑玩，怎么可能会输）；</li>
</ol>
<h5 id="1-main-函数"><a href="#1-main-函数" class="headerlink" title="1. main 函数"></a>1. main 函数</h5><p>在 main 函数中写出程序的整体逻辑，然后再具体实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  //输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //电脑随机落子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;   //电脑落子后休眠 1 秒</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; //sleep 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义棋盘的行和列</span></span><br><span class="line"><span class="comment">//伪需求，不能自定行和列，因为逻辑已经写死了</span></span><br><span class="line"><span class="comment">//只是为了便于引用（维护）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*没有工程化，这么写是不是脱裤子放屁？*/</span></span><br><span class="line"><span class="comment">//显示菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_menu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//游戏开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通常，在玩井字棋游戏时，红方用 X 表示，蓝方用 O（字母，非 0） 表示，所以需要 char 数组来存储数据</span></span><br><span class="line">    <span class="keyword">char</span> arr[ROW][COL] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//接收用户输入</span></span><br><span class="line">    <span class="keyword">int</span> input = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单至少会显示一次，do while 正合适</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//显示菜单</span></span><br><span class="line">        display_menu();</span><br><span class="line">        <span class="comment">//提示用户输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入选择:&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//接收用户输入</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (input)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//输入 1 表示开始游戏</span></span><br><span class="line">            play_game(arr, ROW, COL);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//输入 0 表示退出游戏</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出游戏！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">//非 0 非 1 不正确，重新输入</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误，请重新输入！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (input); <span class="comment">// 0 退出，非 0 为真，刚刚好</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-菜单"><a href="#2-菜单" class="headerlink" title="2. 菜单"></a>2. 菜单</h5><p>通常，提供菜单会让用户感到尊重和愉悦，多种选择也意味着服务的精细，废话不多说，上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******** 1. play ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******** 0. exit ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>菜单简陋，聊胜于无；</p>
<h5 id="3-开始游戏"><a href="#3-开始游戏" class="headerlink" title="3. 开始游戏"></a>3. 开始游戏</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化棋盘</span></span><br><span class="line">    init_board(arr, ROW, COL);</span><br><span class="line">    <span class="comment">//显示棋盘</span></span><br><span class="line">    display_board(arr, ROW, COL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是初始化棋盘，然后显示棋盘，有棋盘了才能落子嘛；</p>
<h5 id="4-初始化棋盘"><a href="#4-初始化棋盘" class="headerlink" title="4. 初始化棋盘"></a>4. 初始化棋盘</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_board</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>游戏开始时，棋盘应该为空，所以将 char 数组的内容重新初始化；</p>
<h5 id="5-打印并显示棋盘"><a href="#5-打印并显示棋盘" class="headerlink" title="5. 打印并显示棋盘"></a>5. 打印并显示棋盘</h5><p>根据行和列生成棋盘，划分如图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp2vpkw512j30ra0riaab.jpg" alt="划分"></p>
<p>如果将每行要显示的元素和分隔线看作一个整体的话，棋盘可以按照行和列完美分割，只是最后一行和最后一列没有分隔线，实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_board</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印坐标 - 棋盘内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %c &quot;</span>, arr[i][j]);</span><br><span class="line">            <span class="comment">//如果不是每行的最后一个元素，则打印列分隔线</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; col - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印分隔符</span></span><br><span class="line">        <span class="comment">//如果不是最后一行，则打印行分隔线</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; row - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">                <span class="comment">//如果不是每行的最后一个元素，则打印列分隔线</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; col - <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，已经可以显示一个空棋盘了，测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp2w0yqoczj30ba0hsmy6.jpg" alt="测试空棋盘"></p>
<p>空棋盘正常显示，其它逻辑也无误；</p>
<p>棋盘准备好了，接下来就该主角儿登场了；</p>
<h5 id="6-玩家落子-电脑落子"><a href="#6-玩家落子-电脑落子" class="headerlink" title="6. 玩家落子 / 电脑落子"></a>6. 玩家落子 / 电脑落子</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//电脑落子随机数种子，放在 main 函数中会不会更好</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    init_board(arr, ROW, COL);</span><br><span class="line">    display_board(arr, ROW, COL);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户标识为 &#x27;X&#x27;</span></span><br><span class="line"><span class="comment">     * 电脑标识为 &#x27;O&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//玩家落子</span></span><br><span class="line">        player_move(arr, ROW, COL);</span><br><span class="line">        <span class="comment">//电脑落子</span></span><br><span class="line">        computer_move(arr, ROW, COL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是用户输入，接收用户输入后判断，规则如下：</p>
<ol>
<li>输入是否越界，越界则重新输入；</li>
<li>输入的坐标是否被占用（已经落子），占用则重新输入；</li>
<li>以上两种情况都不存在，则将用户标识（X）放入数组中坐标对应的位置；</li>
<li>然后显示棋盘；</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">player_move</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要落子的坐标:&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断输入越界</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">0</span> || x &gt; row || y &lt;= <span class="number">0</span> || y &gt; col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;坐标非法，请重新输入！\n&quot;</span>);</span><br><span class="line">            display_board(arr, ROW, COL);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断坐标占用</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[x - <span class="number">1</span>][y - <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;坐标已被占用，请重新输入！\n&quot;</span>);</span><br><span class="line">            display_board(arr, ROW, COL);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存放用户标识 &#x27;X&#x27;</span></span><br><span class="line">            arr[x - <span class="number">1</span>][y - <span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            display_board(arr, ROW, COL);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是电脑落子，生成随机坐标，然后判断，规则如下：</p>
<ol>
<li>坐标是否被占用，占用则重新生成随机数；</li>
<li>坐标没有被占用，则将电脑标识（O）存入数组中坐标对应的位置；</li>
<li>然后显示棋盘；</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computer_move</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;电脑落子...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// m % n = 0 ~ n - 1</span></span><br><span class="line">        <span class="comment">//以 3 为例，9 % 3 = 0，10 % 3 = 1，11 % 3 = 2，余数永远是 0 ～ (n - 1)</span></span><br><span class="line">        x = rand() % row;</span><br><span class="line">        y = rand() % col;</span><br><span class="line">        <span class="comment">//为空说明坐标没有被占用（没有落子），则将电脑标识放入数组中坐标对应的位置</span></span><br><span class="line">        <span class="keyword">if</span> (arr[x][y] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存放电脑标识 &#x27;O&#x27;</span></span><br><span class="line">            arr[x][y] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            <span class="comment">//休眠 1 秒，表示电脑在思考（🌹🐔）</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            display_board(arr, ROW, COL);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp2x2kjy5pj30zu0ty781.jpg" alt="再来测试一下"></p>
<p>对输入越界的判断正常，对坐标占用的判断正常，唯独在用户已经胜出的时候没有终止程序，接下来就需要判断胜负了；</p>
<h5 id="7-棋盘状态"><a href="#7-棋盘状态" class="headerlink" title="7. 棋盘状态"></a>7. 棋盘状态</h5><p>胜负判断的规则很简单：</p>
<ol>
<li>任意行、列、对角线的三个字符相同，则该字符表示的玩家胜出；</li>
<li>棋盘放满但没有玩家胜出，则平局；</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数就是不能改行和列的原因</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_win</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;X&#x27; 为玩家输入</span></span><br><span class="line"><span class="comment">     * &#x27;O&#x27; 为电脑输入</span></span><br><span class="line"><span class="comment">     * &#x27;Q&#x27; 为平局</span></span><br><span class="line"><span class="comment">     * &#x27;C&#x27; 为继续</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">char</span> rst = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果同一行的所有字符全部相同，返回任意单元的字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][<span class="number">0</span>] == arr[i][<span class="number">1</span>] &amp;&amp; arr[i][<span class="number">1</span>] == arr[i][<span class="number">2</span>] &amp;&amp; arr[i][<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rst = arr[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果同一列的所有字符全部相同，返回任意单元的字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>][i] == arr[<span class="number">1</span>][i] &amp;&amp; arr[<span class="number">1</span>][i] == arr[<span class="number">2</span>][i] &amp;&amp; arr[<span class="number">0</span>][i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rst = arr[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左上至右下的对角线</span></span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>][<span class="number">0</span>] == arr[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; arr[<span class="number">1</span>][<span class="number">1</span>] == arr[<span class="number">2</span>][<span class="number">2</span>] &amp;&amp; arr[<span class="number">2</span>][<span class="number">2</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = arr[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右上至左下的对角线</span></span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>][<span class="number">2</span>] == arr[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; arr[<span class="number">1</span>][<span class="number">1</span>] == arr[<span class="number">2</span>][<span class="number">0</span>] &amp;&amp; arr[<span class="number">2</span>][<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = arr[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//棋盘未满且没有序列字符相同，返回继续</span></span><br><span class="line">    <span class="keyword">if</span> (is_board_full(arr, row, col) == <span class="number">1</span> &amp;&amp; rst == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//棋盘已满且没有序列字符相同，返回平局</span></span><br><span class="line">    <span class="keyword">if</span> (is_board_full(arr, row, col) == <span class="number">0</span> &amp;&amp; rst == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断棋盘是否已满：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_board_full</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 1 棋盘未满</span></span><br><span class="line"><span class="comment">     * 返回 0 棋盘已满</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                rst = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-定胜负"><a href="#8-定胜负" class="headerlink" title="8. 定胜负"></a>8. 定胜负</h5><p>有了棋盘状态，现在可以定胜负了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//棋盘状态</span></span><br><span class="line">    <span class="keyword">char</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//电脑落子随机数种子</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    init_board(arr, ROW, COL);</span><br><span class="line">    display_board(arr, ROW, COL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;X&#x27; 为玩家输入</span></span><br><span class="line"><span class="comment">     * &#x27;O&#x27; 为电脑输入</span></span><br><span class="line"><span class="comment">     * &#x27;Q&#x27; 为平局</span></span><br><span class="line"><span class="comment">     * &#x27;C&#x27; 为继续</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        player_move(arr, ROW, COL);</span><br><span class="line">        rst = is_win(arr, ROW, COL);</span><br><span class="line">        <span class="comment">//用户落子后，棋盘未满则继续</span></span><br><span class="line">        <span class="keyword">if</span> (rst != <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        computer_move(arr, ROW, COL);</span><br><span class="line">        rst = is_win(arr, ROW, COL);</span><br><span class="line">        <span class="comment">//电脑落子后，棋盘未满则继续</span></span><br><span class="line">        <span class="keyword">if</span> (rst != <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行到此处表示上面的循环终止了；</span></span><br><span class="line">    <span class="comment">//意味着返回的字符不是 &#x27;C&#x27;；</span></span><br><span class="line">    <span class="comment">//则说明找到相同的字符或棋盘满了</span></span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;玩家赢！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rst == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;电脑赢！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp2ygmx21aj30g805yaa9.jpg" alt="最终测试"></p>
<h5 id="9-完整代码"><a href="#9-完整代码" class="headerlink" title="9. 完整代码"></a>9. 完整代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义棋盘的行和列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_menu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//初始化棋盘内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_board</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//生成并显示棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_board</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//游戏开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//玩家落子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">player_move</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//电脑落子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computer_move</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//返回棋盘状态</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_win</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//判断棋盘是否放满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_board_full</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//井字棋游戏</span></span><br><span class="line">    <span class="keyword">char</span> arr[ROW][COL] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> input = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        display_menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入选择:&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (input)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            play_game(arr, ROW, COL);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出游戏！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误，请重新输入！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******** 1. play ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******** 0. exit ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_board</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_board</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %c &quot;</span>, arr[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; col - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印分隔符</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; row - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; col - <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//棋盘状态</span></span><br><span class="line">    <span class="keyword">char</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//电脑落子随机数种子</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    init_board(arr, ROW, COL);</span><br><span class="line">    display_board(arr, ROW, COL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;X&#x27; 为玩家输入</span></span><br><span class="line"><span class="comment">     * &#x27;O&#x27; 为电脑输入</span></span><br><span class="line"><span class="comment">     * &#x27;Q&#x27; 为平局</span></span><br><span class="line"><span class="comment">     * &#x27;C&#x27; 为继续</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        player_move(arr, ROW, COL);</span><br><span class="line">        rst = is_win(arr, ROW, COL);</span><br><span class="line">        <span class="keyword">if</span> (rst != <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        computer_move(arr, ROW, COL);</span><br><span class="line">        rst = is_win(arr, ROW, COL);</span><br><span class="line">        <span class="keyword">if</span> (rst != <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;玩家赢！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rst == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;电脑赢！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rst == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">player_move</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要落子的坐标:&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">0</span> || x &gt; row || y &lt;= <span class="number">0</span> || y &gt; col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;坐标非法，请重新输入！\n&quot;</span>);</span><br><span class="line">            display_board(arr, ROW, COL);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[x - <span class="number">1</span>][y - <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;坐标已被占用，请重新输入！\n&quot;</span>);</span><br><span class="line">            display_board(arr, ROW, COL);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[x - <span class="number">1</span>][y - <span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            display_board(arr, ROW, COL);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computer_move</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;电脑落子...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = rand() % row;</span><br><span class="line">        y = rand() % col;</span><br><span class="line">        <span class="keyword">if</span> (arr[x][y] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[x][y] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            display_board(arr, ROW, COL);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_win</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;X&#x27; 为玩家输入</span></span><br><span class="line"><span class="comment">     * &#x27;O&#x27; 为电脑输入</span></span><br><span class="line"><span class="comment">     * &#x27;Q&#x27; 为平局</span></span><br><span class="line"><span class="comment">     * &#x27;C&#x27; 为继续</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">char</span> rst = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果同一行的所有单元字符全部相同，返回任意单元的字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][<span class="number">0</span>] == arr[i][<span class="number">1</span>] &amp;&amp; arr[i][<span class="number">1</span>] == arr[i][<span class="number">2</span>] &amp;&amp; arr[i][<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rst = arr[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果同一列的所有单元字符全部相同，返回任意单元的字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>][i] == arr[<span class="number">1</span>][i] &amp;&amp; arr[<span class="number">1</span>][i] == arr[<span class="number">2</span>][i] &amp;&amp; arr[<span class="number">0</span>][i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rst = arr[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左上至右下的对角线</span></span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>][<span class="number">0</span>] == arr[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; arr[<span class="number">1</span>][<span class="number">1</span>] == arr[<span class="number">2</span>][<span class="number">2</span>] &amp;&amp; arr[<span class="number">2</span>][<span class="number">2</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = arr[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右上至左下的对角线</span></span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>][<span class="number">2</span>] == arr[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; arr[<span class="number">1</span>][<span class="number">1</span>] == arr[<span class="number">2</span>][<span class="number">0</span>] &amp;&amp; arr[<span class="number">2</span>][<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = arr[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//棋盘未满且没有序列字符相同，返回继续</span></span><br><span class="line">    <span class="keyword">if</span> (is_board_full(arr, row, col) == <span class="number">1</span> &amp;&amp; rst == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//棋盘已满且没有序列字符相同，返回平局</span></span><br><span class="line">    <span class="keyword">if</span> (is_board_full(arr, row, col) == <span class="number">0</span> &amp;&amp; rst == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_board_full</span><span class="params">(<span class="keyword">char</span> arr[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 1 棋盘未满</span></span><br><span class="line"><span class="comment">     * 返回 0 棋盘已满</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                rst = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，一个简单的井字棋游戏就完成了，内容简陋，可以优化的地方还有很多，各位可自行扩展，玩的开心！😄😄😄</p>
]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>井字棋游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂的 ACProtect 与强大的 OllyScript</title>
    <url>/posts/3965361042/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/UnPackMe-8">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 OD 插件 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-1">OllyDump</a>，来自互联网；</li>
<li>IAT 重建工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>强大的<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-5">OllyScript</a>，来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><h5 id="编写脚本绕过检测硬件断点到达-OEP"><a href="#编写脚本绕过检测硬件断点到达-OEP" class="headerlink" title="编写脚本绕过检测硬件断点到达 OEP"></a>编写脚本绕过检测硬件断点到达 OEP</h5><ol>
<li><p>将 CM 导入 OD，开始脱壳的第 1 步，寻找 OEP，多次尝试后，发现<code>最后一次异常法</code>可以快速到达 OEP；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goc9hn2m2yj31e70u0q73.jpg" alt="最后一次异常法"></p>
<p>到达 OEP 后发现两点不同之处：</p>
<ul>
<li>OEP 处的指令不是 C++ 程序的入口；</li>
<li>堆栈数据与 EP 处不同；</li>
</ul>
<p>通过这两个不同之处，基本可以确定有 Stolen-Code；</p>
</li>
<li><p>为了更方便的到达 OEP，给当前 OEP 设置一个硬件执行断点，设置好断点，重载并运行程序后，发现程序会直接运行并不会中断在 OEP；</p>
</li>
<li><p>重载程序，在 KiUserExceptionDispatcher 以及其内部调用的 ZwContinue 处设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocadavlpgj317k0let9n.jpg" alt="KiUserExceptionDispatcher"></p>
<p>设置好断点后运行程序；</p>
</li>
<li><p>程序中断在 KiUserExceptionDispatcher 函数的行首，此时，堆栈中 ESP + 4 的单元中存放着 CONTEXT 结构体的指针，在数据窗口中查看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocawjjotkj31e30u0wit.jpg" alt="CONTEXT"></p>
<p>可以看到当前设置的 OEP 硬件断点，而其它 3 个为空；</p>
</li>
<li><p><code>F7</code>单步运行程序，发现在经过一个 CALL 后，断点被清除了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocb3tby23j31dg0u0ad6.jpg" alt="断点被清除了"></p>
<p>之所以无法用硬件断点到达 OEP，是因为经过异常派发函数后，断点被清除了；</p>
</li>
<li><p>这种情况下想快速到达 OEP 就需要借助 OllyScript 来绕过异常处理，重新设置断点；</p>
<ul>
<li><p>方法 1：检测清除断点的 CALL 是否执行；</p>
<p>比如：当 ESP 到达 ZwContinue 时，清除断点的 CALL 肯定运行完毕了，此时就可以恢复硬件断点了；</p>
<p>缺点也很明显，如果在 KiUserExceptionDispatcher 函数中还有清除断点的指令，这种方法就失效了；</p>
</li>
<li><p>方法 2：判断 KiUserExceptionDispatcher 函数是否执行完毕；</p>
<p>获取 KiUserExceptionDispatcher 函数的返回地址并设置断点，当程序中断在返回位置时就表示函数运行完毕，此时就可以恢复硬件断点了；</p>
</li>
</ul>
</li>
<li><p>显然第 2 种方法更好，不过函数的返回地址在哪呢？要返回到哪里呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocbuuu8ruj31dy0u043v.jpg" alt="返回地址"></p>
<p>函数的返回地址位于 CONTEXT 结构体 0xB8 偏移处；</p>
<p>根据计算 12FC8C + 0B8 = 12FD44（16 进制数以字母开头时需要前缀 0 或 0x，不然 OD 不认识）；</p>
<p>当前的返回地址为 00471395（不够直观时可以切换显示方式）；</p>
<p>继续运行程序发现，函数被调用了两次，而最终的返回地址为 00471090；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocc4mknmjj31e30u077r.jpg" alt="00471090"></p>
<p>函数的返回地址为 00471090，在相应区段设置内存访问断点，看看函数要返回到哪里：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocjei1icuj31e10u077l.jpg" alt="返回外壳"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocjd3q4roj30x204wwek.jpg" alt="内存映射"></p>
<p>通过内存窗口可以看到，程序的代码段位于 00401000 ～ 0044AFFF，返回地址不在其中，返回地址所在的区段应该是由壳创建的，属于壳的区段；</p>
</li>
<li><p>找到了返回地址，就可以开始写 OllyScript 脚本了：</p>
<ul>
<li><p>首先，需要在 OEP 处设置硬件执行断点：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bphws 004271b5, &quot;x&quot; //OEP 设置硬件执行断点</span><br></pre></td></tr></table></figure></li>
<li><p>然后，需要分支来判断中断的位置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">work: //主分支</span><br><span class="line">eob to_process //跳向判断分支</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">to_process: //判断分支</span><br></pre></td></tr></table></figure></li>
<li><p>如果中断在 KiUserExceptionDispatcher 函数的行首，也就是 7C92E47C，则移除 OEP 处的断点：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">to_process:</span><br><span class="line">cmp eip, 7c92e47c //中断位于 KiUserExceptionDispatcher 函数的行首</span><br><span class="line">je to_clear //跳向清除分支</span><br><span class="line"></span><br><span class="line">to_clear: //清除分支</span><br><span class="line">bphwc 004271b5 //清除断点</span><br><span class="line">jmp work //回到主分支，继续判断</span><br></pre></td></tr></table></figure></li>
<li><p>如果中断在 ZwContinue，也就是 7C92E493，则记录函数的返回地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goci17ebcqj31ds0u078l.jpg" alt="中断在 ZwContinue"></p>
<p>当中断位于 ZwContinue 时，ESP 指向的值就是 CONTEXT 结构体的指针；</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var retaddr //声明记录返回地址的变量</span><br><span class="line"></span><br><span class="line">to_process:</span><br><span class="line">cmp eip, 7c92e47c</span><br><span class="line">je to_clear</span><br><span class="line">cmp eip, 7c92e493 //中断位于 ZwContinue</span><br><span class="line">je to_record //跳向记录分支</span><br><span class="line"></span><br><span class="line">to_clear:</span><br><span class="line">bphwc 004271b5</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_record: //记录分支</span><br><span class="line">mov retaddr, esp //记录当前 esp 的地址</span><br><span class="line">mov retaddr, [retaddr] //获取当前 esp 的值，也就是 CONTEXT 结构体的指针</span><br><span class="line">add retaddr, 0b8 //偏移 0xB8 为返回地址</span><br><span class="line">mov retaddr, [retaddr] //记录返回地址</span><br><span class="line">bp retaddr //返回地址设置 CC 断点</span><br><span class="line">jmp work //回到主分支，继续判断</span><br></pre></td></tr></table></figure></li>
<li><p>如果中断在返回位置，则需要重新设置 OEP 的硬件执行断点</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var retaddr</span><br><span class="line"></span><br><span class="line">beginning: //添加标签，减少代码冗余</span><br><span class="line">bphws 004271b5, &quot;x&quot; //OEP 设置硬件执行断点</span><br><span class="line"></span><br><span class="line">to_process:</span><br><span class="line">cmp eip, 7c92e47c</span><br><span class="line">je to_clear</span><br><span class="line">cmp eip, 7c92e493</span><br><span class="line">je to_record</span><br><span class="line">cmp eip, retaddr //中断位于返回地址</span><br><span class="line">je to_reset //跳向重新设置分支</span><br><span class="line"></span><br><span class="line">to_clear:</span><br><span class="line">bphwc 004271b5</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_record:</span><br><span class="line">mov retaddr, esp</span><br><span class="line">mov retaddr, [retaddr]</span><br><span class="line">add retaddr, 0b8</span><br><span class="line">mov retaddr, [retaddr]</span><br><span class="line">bp retaddr //返回地址设置 CC 断点</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_reset: //重新设置分支</span><br><span class="line">bc retaddr //取消返回位置的断点</span><br><span class="line">jmp beginning //重新设置 OEP 硬件执行断点</span><br></pre></td></tr></table></figure></li>
<li><p>最后，如果断点全部没有命中，则说明硬件断点设置完成，弹出消息弹窗：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var retaddr</span><br><span class="line"></span><br><span class="line">beginning:</span><br><span class="line">bphws 004271b5, &quot;x&quot;</span><br><span class="line"></span><br><span class="line">work:</span><br><span class="line">eob to_process</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">to_process:</span><br><span class="line">cmp eip, 7c92e47c</span><br><span class="line">je to_clear</span><br><span class="line">cmp eip, 7c92e493</span><br><span class="line">je to_record</span><br><span class="line">cmp eip, retaddr</span><br><span class="line">je to_reset</span><br><span class="line">jmp final //断点全部没有命中</span><br><span class="line"></span><br><span class="line">to_clear:</span><br><span class="line">bphwc 004271b5</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_record:</span><br><span class="line">mov retaddr, esp</span><br><span class="line">mov retaddr, [retaddr]</span><br><span class="line">add retaddr, 0b8</span><br><span class="line">mov retaddr, [retaddr]</span><br><span class="line">bp retaddr</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_reset:</span><br><span class="line">bc retaddr</span><br><span class="line">jmp beginning</span><br><span class="line"></span><br><span class="line">final:</span><br><span class="line">MSGYN &quot;是否继续？&quot; //包含按钮的弹窗</span><br><span class="line">cmp $RESULT, 1 //继续的值为 1，取消为 0</span><br><span class="line">je beginning</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>这就是脚本的全部逻辑与内容；</p>
</li>
</ul>
</li>
<li><p>脚本写好了，试一下：</p>
<p>需要注意的是，脚本是根据中断位置执行的，在脚本中会自动设置返回位置的 CC 断点，但 KiUserExceptionDispatcher 和 ZwContinue 函数的断点不会自动设置，所以运行前需要手动设置这两个断点；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocijikk24j31e60u0q64.jpg" alt="成功到达 OEP"></p>
<p>运行脚本后，成功到达 OEP；</p>
</li>
</ol>
<h5 id="利用-Run-跟踪记录功能定位-Stolen-Code"><a href="#利用-Run-跟踪记录功能定位-Stolen-Code" class="headerlink" title="利用 Run 跟踪记录功能定位 Stolen Code"></a>利用 Run 跟踪记录功能定位 Stolen Code</h5><ol>
<li><p>在初次到达 OEP 时，根据栈内容和 OEP 指令就确定这个 CM 有 Stolen-Code；</p>
</li>
<li><p>之前使用的方法是单步执行，寻找第 1 条指令<code>PUSH EBP</code>，这种方法适用于简单的加壳程序，但如果花指令有几百上千条，就捉襟见肘了；</p>
</li>
<li><p>使用 Run 跟踪记录功能把最接近 OEP 的指令记录下来，然后静态分析，更快捷高效；</p>
</li>
<li><p>给 KiUserExceptionDispatcher 和 ZwContinue 函数设置断点，在最后一次中断于 ZwContinue 时，在返回地址对应的区段设置内存访问断点，然后到达函数返回地址，接着取消内存访问断点，同时给 OEP 设置硬件执行断点，作为 RUN 跟踪的终止条件；</p>
</li>
<li><p>打开 RUN 跟踪面板，选择记录到文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gock22zbvmj31e70u0gou.jpg" alt="选择记录到文件"></p>
</li>
<li><p>确认调试设置异常选项中已经忽略所有异常，防止自动跟踪过程中因为异常而中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gock3lgw7rj31e40u0did.jpg" alt="调试菜单异常选项"></p>
</li>
<li><p>在调试菜单中启用 RUN 跟踪功能：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gock7s12p5j31eb0u077h.jpg" alt="启用 RUN 跟踪功能"></p>
<p>可以根据<code>关闭 RUN 跟踪</code>按钮是否可用来判断有没有打开 RUN 跟踪功能；</p>
</li>
<li><p>按下<code>Ctrl + F11</code>或在调试菜单中选择<code>跟踪步入</code>选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gockamffe7j31e80u0mz8.jpg" alt="跟踪步入"></p>
</li>
<li><p>耐心等待，直到程序的状态由跟踪变为暂停：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gockxv5vjij31e80u0jva.jpg" alt="由跟踪变为暂停"></p>
</li>
<li><p>使用 EditPlus 打开 RUN 跟踪记录的文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocl0d1heaj31f80u0jv8.jpg" alt="EditPlus"></p>
<p>文件有 40M+ 大小，执行的指令有 90 多万行（幸亏我 F7 了几百行就放弃了），终止的条件是到达 OEP，这就是给 OEP 设置硬件执行断点的原因；</p>
</li>
<li><p>在 EditPlus 中文件末尾按下<code>Ctrl + F</code>，倒序搜索<code>PUSH EBP</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocl5rrp27j31f20u0n1d.jpg" alt="搜索`PUSH EBP`"></p>
<p>至于为啥要倒序搜索，因为倒序会搜索到离当前 OEP 最近的相匹配的指令，也是最接近原始 OEP 的指令；</p>
<p>可以看到，<code>PUSH EBP</code>后，ESP 的值为 12FFC0，紧接着是<code>PUSH -1</code>，那么 ESP 的值应该是 12FFBC；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocleswiz2j31e00u0wjb.jpg" alt="PUSH -1"></p>
<p>查看当前 OEP 的栈窗口，栈顶地址为 12FFBC 且值为 -1，完全吻合，这些应该就是原始 OEP 的指令；</p>
</li>
<li><p>将这三行有用的指令复制到 OD 任意位置，查看占用字节：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goclmoh01aj30v40243ye.jpg" alt="查看占用字节"></p>
<p>这三行指令占用 5 个字节，那么，当前 OEP 往前 5 个字节就是原始 OEP，即 4271B5 - 5 = 4271B0；</p>
<p>复制三行指令的机器码，粘贴到原始 OEP，同时撤销查看占用字节时的修改；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goclqf5cnoj31du0u0tcb.jpg" alt="复制三行指令的机器码"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goclvo8lg4j31e60u0q6z.jpg" alt="粘贴到原始 OEP"></p>
</li>
<li><p>用 OllyDump 将修改好的数据转存下来：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1goclz27q14j31e70u0434.jpg" alt="OllyDump"></p>
<p>需要修改偏移为原始 OEP 的偏移，并取消重建输入表选项；</p>
</li>
</ol>
<h5 id="编写脚本修复-IAT-重定向"><a href="#编写脚本修复-IAT-重定向" class="headerlink" title="编写脚本修复 IAT 重定向"></a>编写脚本修复 IAT 重定向</h5><ol>
<li><p>Dump 完程序，接下来就是修复 IAT 了，使用脚本到达 OEP 后，在汇编窗口右键选择查找，然后选择所有模块间的调用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocpzdorh7j31ed0u0whq.jpg" alt="所有模块间的调用"></p>
<p>可以看到有一部分有函数名，有一部分没有函数名，说明 IAT 中部分数据被重定向了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocq6zcmscj31e00u0433.jpg" alt="数据窗口中跟随"></p>
<p>在任意调用上双击或按下 Enter 键或右键选择反汇编窗口中跟随，就可以到达调用位置；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocqdoil0xj31dz0u0wik.jpg" alt="内存窗口"></p>
<p>在数据窗口查看所有 IAT 项后发现，虽然被重定向了，但都处于同一区段，也就是壳所在的区段，并没有专门创建新的区段；</p>
</li>
<li><p>复制之前的脚本，重命名为 IAT.txt，以 00460974 为例（第 1 个被重定向的数据）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var retaddr</span><br><span class="line"></span><br><span class="line">beginning:</span><br><span class="line">bphws 00460974, &quot;w&quot; //修改地址，类型为写入</span><br><span class="line"></span><br><span class="line">work:</span><br><span class="line">eob to_process</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">to_process:</span><br><span class="line">cmp eip, 7c92e47c</span><br><span class="line">je to_clear</span><br><span class="line">cmp eip, 7c92e493</span><br><span class="line">je to_record</span><br><span class="line">cmp eip, retaddr</span><br><span class="line">je to_reset</span><br><span class="line">jmp final</span><br><span class="line"></span><br><span class="line">to_clear:</span><br><span class="line">bphwc 00460974 //修改地址</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_record:</span><br><span class="line">mov retaddr, esp</span><br><span class="line">mov retaddr, [retaddr]</span><br><span class="line">add retaddr, 0b8</span><br><span class="line">mov retaddr, [retaddr]</span><br><span class="line">bp retaddr</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_reset:</span><br><span class="line">bc retaddr</span><br><span class="line">jmp beginning</span><br><span class="line"></span><br><span class="line">final:</span><br><span class="line">MSGYN &quot;是否继续？&quot;</span><br><span class="line">cmp $RESULT, 1</span><br><span class="line">je beginning</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>修改断点地址为 460974，断点类型为写入，至于为什么要用脚本，因为可以绕过断点检测呀；</p>
</li>
<li><p>手动设置 KiUserExceptionDispatcher 和 ZwContinue 断点，然后载入脚本：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocr3yu3m8j31e10u0dkp.jpg" alt="写入位置"></p>
<p>硬件断点中断的位置是下一条指令，查看上面一条指令，将 EAX 的值写入 EDI 指向的地址中，数据窗口查看，是第 1 个被重定向的数据；</p>
</li>
<li><p>反汇编窗口中跟随 EAX 的值，只有简短的 3 条指令：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocr9r9vyij31nu02ydfx.jpg" alt="3条指令"></p>
<p>将自然数 F0616754 压入堆栈，然后用这个自然数与 8CE1703B 异或，接着就返回了；</p>
<p>460974 中存放的是重定向后函数的地址，也就是说 F0616754 与 8CE1703B 异或后就是函数的入口地址，计算一下：</p>
<p><code>XOR F0616754, 8CE1703B</code>结果为 7C80176F；</p>
</li>
<li><p>将堆栈窗口向上滚动，在 ESP-C 的位置可以看到函数真正的入口点以及函数名：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrl5k6d8j30n4090weo.jpg" alt="ESP - C"></p>
<p>可以看到，这个被重定向的函数为 kernel32.GetSystemTime，入口地址为 7C80176F，与手动计算的一致；</p>
<p>这样的话，就可以用脚本将 EBP-C 位置的数据写入 EDI 指向的地址，不就修复重定向了，岂不美哉？</p>
</li>
<li><p>看完被重定向的函数，还有一部分是没有重定向的，以 460818 为例，修改脚本中的地址，手动设置两个断点后载入脚本：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocs3418mxj31dv0u0djn.jpg" alt="460818"></p>
<p>不仅与之前中断的指令相同，就连地址也相同，唯一不同的就是 EAX；</p>
<p>这样的话，就可以通过判断 EAX 中的地址来确定是否为重定向的值以及是否将 EBP-C 中的地址写入 EDI 指向的地址；</p>
</li>
<li><p>如何确定哪些数据是被重定向的呢？在内存窗口可以找到答案：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocs8xkiizj30yy0q2myn.jpg" alt="内存窗口可以找到答案"></p>
<p>IAT 被重定向的数据处于同一区段，也就是 0046B000 ～ 0048DFFF 之间，如果 EAX 的值在 0046B000 ～ 0048DFFF 之间，就说明被重定向了；</p>
<p>同时查看各 DLL 的原始地址可以发现，所有 DLL 都位于 5D170000 之后，如果 EAX 的值大于 5D170000，说明就没有被重定向；</p>
<p>综合起来，取简单好记的中间值就是：如果 EAX 大于 50000000，则说明没有被重定向，否则就是被重定向了，需要将 EBP-C 中的值写入 EDI 指向的地址中；</p>
</li>
<li><p>逻辑清晰后，开始编写脚本：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//第 1 个变量用来存储 KiUserExceptionDispatcher 函数的返回值</span><br><span class="line">var retaddr</span><br><span class="line">//第 2 个变量用来存储 ESP-C 的值</span><br><span class="line">var repaddr</span><br><span class="line"></span><br><span class="line">beginning:</span><br><span class="line">bphws 004743d5, &quot;x&quot; // MOV DWORD PTR DS:[EDI],EAX</span><br><span class="line"></span><br><span class="line">work:</span><br><span class="line">eob to_process</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">to_process:</span><br><span class="line">cmp eip, 7c92e47c</span><br><span class="line">je to_clear</span><br><span class="line">cmp eip, 7c92e493</span><br><span class="line">je to_record</span><br><span class="line">cmp eip, retaddr</span><br><span class="line">je to_reset</span><br><span class="line">cmp eip, 004743d5 //中断于 004743d5 则跳向修复</span><br><span class="line">je to_repair</span><br><span class="line">jmp final</span><br><span class="line"></span><br><span class="line">to_clear:</span><br><span class="line">bphwc 004743d5</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_record:</span><br><span class="line">mov retaddr, esp</span><br><span class="line">mov retaddr, [retaddr]</span><br><span class="line">add retaddr, 0b8</span><br><span class="line">mov retaddr, [retaddr]</span><br><span class="line">bp retaddr</span><br><span class="line">jmp work</span><br><span class="line"></span><br><span class="line">to_reset:</span><br><span class="line">bc retaddr</span><br><span class="line">jmp beginning</span><br><span class="line"></span><br><span class="line">to_repair:</span><br><span class="line">cmp eax, 50000000</span><br><span class="line">ja beginning //eax 大于 50000000 则不用修复</span><br><span class="line">mov repaddr, esp</span><br><span class="line">//add repaddr, -0C //OllyScript 好像不支持加负数</span><br><span class="line">sub repaddr, c //esp-c</span><br><span class="line">mov repaddr, [repaddr] //esp-c 的值</span><br><span class="line">mov [edi], repaddr //拷贝到 edi 指向的地址</span><br><span class="line">jmp beginning</span><br><span class="line"></span><br><span class="line">final:</span><br><span class="line">MSGYN &quot;是否继续？&quot;</span><br><span class="line">cmp $RESULT, 1</span><br><span class="line">je beginning</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></li>
<li><p>写完当然是测试啦，手动设置 KiUserExceptionDispatcher 和 ZwContinue 断点，然后载入脚本：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocu41c99zg30xd0j8qv8.gif" alt="测试"></p>
<p>IAT 重定向已经被修复啦，完美；</p>
</li>
<li><p>打开 ImportREC ，填写相关选项：</p>
<p>OEP 的 RVA 为：271B0；<br>IAT 的 RVA 为：60818；<br>IAT 的 Size 为：710；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocushvasyj30wm0oq75k.jpg" alt="ImportREC"></p>
<p>然而，有一个无效选项，RVA 为 00060DE8，重载程序，给无效数据设置内存写入断点，设置 KiUserExceptionDispatcher 和 ZwContinue 断点，然后载入脚本；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocvi5q5k5j31e00u0tcj.jpg" alt="然后载入脚本"></p>
<p>可以看到，ESP-C 位置的数据的确是 46E5CB，看来不是脚本的问题；</p>
</li>
<li><p>重载程序，使用 OEP.txt 到达 OEP 后，给 460DE8 设置内存写入断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocvwfjufej317c06adg6.jpg" alt="给 460DE8 设置内存写入断点"></p>
<p>程序中断，既然要定位的是系统 API 函数，那么它的入口地址肯定大于 50000000，按下<code>Ctrl + T</code>设置条件，当 EIP 位于 0 ～ 50000000 之外是就意味着调用了系统 API，那时就暂停程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocw420yzsj31e00u0q7o.jpg" alt="设置条件"></p>
<p>设置完成后，按下<code>Ctrl + F11</code>或调试菜单选择跟踪步入运行程序；</p>
</li>
<li><p>中断在这里，查看寄存器窗口就已经知道调用的是 USER32.MessageBoxA 了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gocwbliwkaj31gh0u0teq.jpg" alt="USER32.MessageBoxA"></p>
<p>反汇编窗口中跟随到调用位置之后，发现 CALL 直接调用的正是 460DE8；</p>
</li>
<li><p>返回 ImportREC，修改无效选项，然后修复 dumped.exe；</p>
</li>
</ol>
<h5 id="修复-Anti-Dump"><a href="#修复-Anti-Dump" class="headerlink" title="修复 Anti-Dump"></a>修复 Anti-Dump</h5><ol>
<li><p>打开修复完成的程序，发现程序无法正常运行，将修复后的程序导入 OD，同时取消忽略异常；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1godgpvdx2hj30q20jwdgf.jpg" alt="取消忽略异常"></p>
</li>
<li><p>在 OD 中运行程序后，提示信息显示有个访问违规异常，打开调用窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gode6nyuonj31e20u0tbe.jpg" alt="调用窗口"></p>
<p>应该是 429806 处调用 46C5F3 时产生了访问违规异常，在这行右键选择显示调用，定位到调用位置；</p>
</li>
<li><p>接着在调用指令上按下 Enter 或右键选择跟随，查看 CALL 里面的内容：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1godede3gyyj31e00u0q6j.jpg" alt="查看 CALL 里面的内容"></p>
</li>
<li><p>原来，CALL 是间接调用，内部是跳转表，但却没有数据，这就是壳的 Anti-Dump：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1godekpyrvlj31e60u00wv.jpg" alt="内部是跳转表"></p>
<p>怪不得 EIP 指向 0，是因为跳转表中的地址根本没有数据；</p>
</li>
<li><p>再打开一个 OD 窗口，载入未脱壳的程序并运行，然后定位到跳转表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1godezj22hsj318w0u0n23.jpg" alt="然后定位到跳转表"></p>
<p>对比两个窗口，因为没有数据，右键菜单没有跟随选项，信息窗口数据为 0，数据窗口数据也为 0；</p>
</li>
<li><p>在原程序的跳转表上按下 Enter 或右键选择跟随：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1godf4c2plbj31e20u00xw.jpg" alt="在原程序的跳转表上"></p>
<p>尝试多次后发现，跳转表项是顺序跳转的，每次执行 6 字节的指令就返回，且跳转表每项也是 6 个字节；</p>
</li>
<li><p>如果用跳转后执行的指令直接替换跳转表，应该就能解决 Anti-Dump 了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1godfkekqu9j315k0u0td1.jpg" alt="复制跳转后的指令"></p>
<p>在原程序所在的 OD 中选中所有指令，然后选择二进制复制，汇编窗口或数据窗口复制皆可，然后在 dump 程序所在的 OD 中选中所有跳转表项，然后选择二进制粘贴；</p>
<p>在这里指令不会完全覆盖跳转表，而指令下方的 0B6 应该是无效数据，复制了也白搭，就以指令长度为准吧，不行了再粘贴 0B6；</p>
</li>
<li><p>保存修改到文件，然后运行程序，bingo！</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1godgug2w3oj30wo0ag74x.jpg" alt="bingo！"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OEP</tag>
        <tag>Anti-Dump</tag>
        <tag>IAT</tag>
        <tag>Stolen-Code</tag>
        <tag>OllyScript</tag>
        <tag>ACProtect</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理小记</title>
    <url>/posts/724103910/</url>
    <content><![CDATA[<blockquote>
<p>记录<a href="http://www.hzcourse.com/web/refbook/detail/4372/215">Windows PE 权威指南</a>以及<a href="https://bbs.pediy.com/forum-99.htm">加密解密</a>等书中对异常处理的原理及流程的部分描述；</p>
</blockquote>
<p>Windows 的异常处理是操作系统处理程序错误或异常的一系列流程和技术的总称；</p>
<p>开发人员主要使用的两种异常处理技术是：</p>
<ul>
<li>SEH（Structured Exception Handling，结构化异常处理）：全局异常链表，不同的线程共用一个；</li>
<li>VEH（Vectored Exception Handler，向量化异常处理）：局部异常链表，线程相关，位于当前线程的堆栈当中，不同线程不同堆栈；</li>
</ul>
<span id="more"></span>

<h3 id="异常基本概念"><a href="#异常基本概念" class="headerlink" title="异常基本概念"></a>异常基本概念</h3><p>Intel 在从 386 开始的 IA-32 家族处理中引入了中断（Interrupt）和 异常（Exception）的概念；</p>
<ol>
<li>中断是由外部硬件设备或异步事件产生的；</li>
<li>异常是由内部事件产生的，可分为故障（Fault）、陷阱（Trap）和终止（Abort） 3 种；</li>
<li>故障异常和陷阱异常是可恢复的；</li>
<li>故障异常通常是因为执行指令失败而引起的，如除 0 异常，以及 EIP 指向了不可执行的页面等；<br>此类异常有一个共同点，那就是发生异常时自动压入栈的是失败指令的地址，而不是下一条指令的地址，这样做的原因是：当异常遍历过程返回时，可以重新执行一遍这条指令；</li>
<li>陷阱异常通常是因为执行了自陷指令（如 INT3）而引发的异常，这类异常的返回地址是自陷指令的下一条指令所在的地址；</li>
<li>终止类异常是不可恢复的，发生此类异常，系统必须重启；<br>这类异常专指那些已经无法恢复的严重错误，如硬件故障引发的异常，或系统表中出现了错误值引发的异常；</li>
</ol>
<p>异常就是在应用程序正常执行过程中发生的不正常事件；</p>
<p>由 CPU 引发的异常称为硬件异常，例如访问无效的内存地址；</p>
<p>由操作系统或应用程序引发的异常称为软件异常；</p>
<p>Intel CPU 常见的异常列表：</p>
<table>
<thead>
<tr>
<th align="center">中断类型号</th>
<th align="center">类型</th>
<th align="center">相关指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00</td>
<td align="center">触发运算出错，除数为 0 时中断</td>
<td align="center">DIV、IDIV</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">调试异常（包括单步调试和硬件调试）</td>
<td align="center">任何指令</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">断点中断</td>
<td align="center">INT3 指令</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">溢出中断</td>
<td align="center">INT0</td>
</tr>
<tr>
<td align="center">05</td>
<td align="center">读写内存冲突，即越界异常</td>
<td align="center">BOUND</td>
</tr>
<tr>
<td align="center">06</td>
<td align="center">非法指令故障</td>
<td align="center">非法指令编码或操作数</td>
</tr>
<tr>
<td align="center">07</td>
<td align="center">设备不可用</td>
<td align="center">浮点指令或 WAIT</td>
</tr>
<tr>
<td align="center">08</td>
<td align="center">异常嵌套，双重故障，即在异常处理过程中又发生了异常</td>
<td align="center">任何指令</td>
</tr>
<tr>
<td align="center">0A</td>
<td align="center">非法任务状态段，无效 TSS 中断</td>
<td align="center">JMP、CALL、IRET、中断</td>
</tr>
<tr>
<td align="center">0B</td>
<td align="center">段不存在异常</td>
<td align="center">装载段寄存器</td>
</tr>
<tr>
<td align="center">0C</td>
<td align="center">栈异常</td>
<td align="center">装载 SS 寄存器或 SS 段寻址</td>
</tr>
<tr>
<td align="center">0D</td>
<td align="center">通用保护异常</td>
<td align="center">任何特权指令，任何访问存储器的指令</td>
</tr>
<tr>
<td align="center">0E</td>
<td align="center">页异常</td>
<td align="center">任何访问存储器的指令</td>
</tr>
<tr>
<td align="center">0F</td>
<td align="center">浮点运算异常</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>除了 CPU 能够捕获一个事件并引发一个硬件异常外，在代码段中可以主动引发一个软件异常，只需调用 RaiseException() 函数；</p>
<p>实际上，在高级语言的异常处理模型中的大部分抛出异常的操作，最终都是对 RaiseException() 函数的调用；</p>
<p>RaiseException() 函数声明如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">VOID RaiseException(</span><br><span class="line">    DWORD dwExceptionCode,      //标识引发异常的代码</span><br><span class="line">    DWORD dwExceptionFlags,     //异常是否继续执行的标识</span><br><span class="line">    DWORD nNumberOfArguments，  //参数个数</span><br><span class="line">    CONST DWORD *lpArguments    //指向参数缓冲区的指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>程序捕获软件异常的方法与捕获硬件异常的方法完全相同；</p>
<h3 id="异常处理的基本过程"><a href="#异常处理的基本过程" class="headerlink" title="异常处理的基本过程"></a>异常处理的基本过程</h3><p>Windows 正常启动后，将运行在保护模式下，当有中断或异常发生时，CPU 会通过中断描述符表（Interrupt Descriptor Table，IDT）来寻找处理函数；</p>
<p>IDT 表是 CPU（硬件）和操作系统（软件）交接中断和异常的关口；</p>
<h4 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h4><p>IDT 是一张位于物理内存中的线性表，共有 256 项；</p>
<p>在 32 位模式下每个 IDT 项的长度是 8 字节，在 64 位模式下则为 16 字节；</p>
<p>操作系统在启动阶段会初始化这个表，系统中的每个 CPU 都有一份 IDT 的拷贝；</p>
<p>IDT 的位置和长度是由 CPU 的 IDTR 寄存器描述的；</p>
<p>IDTR 寄存器共有 48 位，其中高 32 位是表的基址，低 16 位是表的长度；</p>
<p>尽管可以使用 SIDT 和 LIDT 指令来读写该寄存器，但 LIDT 是特权指令，只能在 Ring0 特权级下运行；</p>
<p>IDT 的每一项都是一个门结构，它是发生中断或异常时 CPU 转移控制权的必经之路：</p>
<ul>
<li>任务门（Task-gate）描述符，主要用于 CPU 的任务切换（TSS 功能）；</li>
<li>中断门（Interrupt-gate）描述符，主要用于描述中断处理程序的入口；</li>
<li>陷阱门（Trap-gate）描述符，主要用于描述异常处理程序的入口；</li>
</ul>
<h4 id="异常处理的准备工作"><a href="#异常处理的准备工作" class="headerlink" title="异常处理的准备工作"></a>异常处理的准备工作</h4><p>当有中断或异常发生时，CPU 会根据中断类型号（这里把异常也视为一种中断）转而执行对应的中断处理程序，对异常来说就是 KiTrapXX 函数；</p>
<p>例如 KiTrap03：</p>
<ul>
<li>处理 INT3 异常的函数；</li>
<li>在开始异常处理时，先构造 TRAP_FRAME 陷阱帧结构，用来保存系统调用、中断、异常发生时的寄存器现场，方便之后回到用户空间 / 回到中断处时，恢复寄存器的值，继续执行；</li>
<li>KiTrap03 实际上调用了 CommonDispatchException；</li>
</ul>
<p>CommonDisPatchException：</p>
<ul>
<li>判断是用户异常还是内核异常，使用的是 CS 段寄存器的最后两位；</li>
<li>构建一个异常记录的结构；</li>
<li>实际上调用了 KiDispatchException 来处理异常；</li>
</ul>
<p>KiDispatchException：</p>
<ul>
<li>该函数用于分发异常，根据异常所产生的模式找到异常的函数；</li>
<li>如果异常发生在内核模式，函数会直接调用一个异常处理函数直接处理异常；</li>
<li>如果异常发生在用户模式，则函数会将异常记录、异常栈帧和陷阱栈帧拷贝到用户模式的线程的栈（这些信息在用户态可以被修改，被修改会重新设置到线程环境上），随后函数会进入到用户态，到了用户态之后会被专门的函数去处理异常；</li>
</ul>
<p>各个异常处理函数除了针对本异常的特定处理外，通常会将异常信息进行封装，以便进行后续处理；</p>
<p>封装的内存主要有两部分，一部分是异常记录，包含本次异常的信息，该结构定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">typedef struct _EXCEPTION_RECORD&#123;</span><br><span class="line">    NTSTATUS ExceptionCode;                     //异常代码</span><br><span class="line">    ULONG ExceptionFlags;                       //异常的状态位标志</span><br><span class="line">    struct _EXCEPTION_RECORD *ExceptionRecord;  //指向另一个 EXCEPTION_RECORD（异常记录块） 的指针</span><br><span class="line">    PVOID ExceptionAddress;                     //异常发生的地址（本次异常的返回位置）</span><br><span class="line">    ULONG NumberParameters;                     // 数组 ExceptionInformation 中有效数据的个数</span><br><span class="line">    ULONG_PTR ExceptionInformation;             //附加信息</span><br><span class="line">&#125; EXCEPTION_RECORD</span><br></pre></td></tr></table></figure>

<p>异常记录块用来记录一个异常所对应的相关信息，其中含有异常的代码、发生异常时的系统状态、异常之间的联系等，每一个异常发生时，系统都会传递一个这样的数据结构；</p>
<p>另一部分被封装的内容称为陷阱帧，它精确描述了发生异常时线程的状态（Windows 的任务调度是基于线程的）；<br>TRAP_FRAME 陷阱帧结构与处理器高度相关，因此在不同的平台上有不同的定义；</p>
<p>TRAP_FRAME 陷阱帧结构包含每个寄存器的状态，但该结构一般仅供系统内核自身或调试系统使用，当需要把控制权交给用户注册的异常处理程序时，会将 TRAP_FRAME 转换成一个名为 CONTEXT 的结构，它包含线程运行时处理器各主要寄存器的完整镜像，用于保存线程运行环境；</p>
<p>包装完毕后，异常处理函数会进一步调用系统内核的 nt!KiDispatchException 函数来处理异常；</p>
<p>该函数原型定义如下，其中第 1 参数和第 3 参数正是上面封装的两个结构体：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">VOID</span><br><span class="line">KiDispatchException(</span><br><span class="line">    IN PEXCEPTION_RECORD ExceptionRecord,       //异常结构信息，指向 ExceptionRecord 的指针</span><br><span class="line">    IN PKEXCEPTION_FRAME ExceptionFrame,        //对 NT386（x86） 系统总是为 NULL，未使用</span><br><span class="line">    IN PKTRAP_FRAME TrapFrame,                  //发生异常时的陷阱帧</span><br><span class="line">    IN KPROCESSOR_MODE PreviousMode,            //发生异常时的 CPU 模式是内核模式还是用户模式</span><br><span class="line">    IN BOOLEAN FirstChance                      //是否第 1 次处理该异常</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="内核状态的异常处理过程"><a href="#内核状态的异常处理过程" class="headerlink" title="内核状态的异常处理过程"></a>内核状态的异常处理过程</h4><p>当 PreviousMode 为 KernelMode 时，表示是内核模式下产生的异常，此时 KiDispatchException 会按以下步骤分发异常：</p>
<ol>
<li><p>检测当前系统是否正在被内核调试器调试，如果内核调试器不存在，将跳过本步骤；</p>
<p>如果内核调试器存在，系统就会把异常处理的控制权转交给内核调试器，并注明是第 1 次处理机会（FirstChance）；</p>
<p>内核调试器取得控制权之后，会根据用户对异常处理的设置来确定是否要处理该异常；</p>
<p>如果无法确定该异常是否要处理，就会发生中断，把控制权交给用户，由用户决定是否处理；</p>
<p>如果调试器正确处理了该异常，那么发生异常的线程就会回到原来产生异常的位置继续执行；</p>
</li>
<li><p>如果不存在内核调试器，或者在第 1 次处理机会时调试器选择不处理该异常，系统就会调用 nt!RtlDispatchException 函数，根据线程注册的结构化异常处理（SEH）过程来处理该异常；</p>
</li>
<li><p>如果 nt!RtlDispatchException 函数没有处理该异常，系统会给调试器第 2 次处理机会（Second Chance），此时调试器可以再次取得对异常的处理权；</p>
</li>
<li><p>如果不存在内核调试器，或者第 2 次机会调试器仍不处理，系统就认为在这种情况下不能继续运行了，为了避免引起更加严重的、不可预知的错误，系统会直接调用 KeBugCheckEx 产生一个错误码为“KERNEL_MODE_EXCEPTION_NO_HANDLED”（其值为 0x0000008E）的 BSOD（俗称蓝屏错误）；</p>
</li>
</ol>
<h4 id="用户态的异常处理过程"><a href="#用户态的异常处理过程" class="headerlink" title="用户态的异常处理过程"></a>用户态的异常处理过程</h4><p>当 PreviousMode 为 UserMode 时，表示是用户模式下产生的异常，此时 KiDispatchException 函数仍然会检测内核调试器是否存在；</p>
<p>如果内核调试器存在，会优先把控制权交给内核调试器进行处理，所以，使用内核调试器调试用户态程序是完全可行的，并且不依赖进程的调试端口；</p>
<p>在大多数情况下，内核调试器对用户态的异常不感兴趣，也就不会去处理它，此时，nt!KiDispatchException 函数仍然像处理内核态异常一样按两次处理机会进行分发；</p>
<ol>
<li><p>如果发生异常的程序正在被调试，那么将异常信息发送给正在调试它的用户态调试器，给调试器第 1 次处理机会，如果没有调试器，则跳过本步骤；</p>
</li>
<li><p>如果不存在用户态调试器或调试器未处理该异常，那么在栈上放置 EXCEPTION_RECORD 和 CONTEXT（ 用户态 TRAP_FRAME 陷阱帧结构） 两个结构，并将控制权返回用户态的 ntdll.dll 中的 KiUserExceptionDispatcher 函数，由它调用 ntdll!KiDispatchException 函数进行用户态的异常处理，这一部分涉及 SEH 和 VEH 两种异常处理机制；</p>
<p>其中，SEH 部分包括应用程序调用 API 函数 SetUnhandleExceptionFilter 设置的顶级异常处理程序；</p>
<p>但如果有调试器存在，顶级异常处理将被跳过，进入下一阶段的处理，否则将由顶级异常处理程序进行终结处理（通常是显示一个应用程序错误对话框并根据用户的选择决定是终止程序还是附加到调试器）；</p>
<p>如果没有调试器能附加于其上或调试器还是处理不了异常，系统就调用 ExitProcess 函数来终结程序；</p>
<p>KiUserExceptionDispatcher：</p>
<ul>
<li>函数第 1 个参数为异常类型，第 2 个参数为产生异常时的上下文记录；</li>
<li>KiUserExceptionDispatcher 的核心是对 RtlDispatchException 的调用；<br>如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException 的调用就不会返回；<br>如果它返回了，只有两种可能：调用了 NtContinue 以便让进程继续执行，或者产生了新的异常，如果是这样，那异常就不能再继续处理了，必须终止进程；</li>
</ul>
</li>
<li><p>如果 ntdll!KiDispatchException 函数在调用用户态的异常处理过程中未能处理该异常，那么异常处理过程会再次返回 nt!KiDispatchException ，它将再次把异常信息发送给用户态的调试器，给调试器第 2 次处理机会；</p>
<p>如果没有调试器存在，则不会进行第 2 次分发，而是直接结束进程；</p>
</li>
<li><p>如果第 2 次机会调试器仍不处理，nt!KiDispatchException 会再次尝试把异常分发给进程的异常端口进行处理；</p>
<p>该端口通常由子系统进程 csrss.exe 进行监听，子系统监听到该错误后，通常会显示一个“应用程序错误”对话框，用户可以点击“确定”按钮或者最后将其附加到调试器上的“取消”按钮；</p>
<p>如果没有调试器能附加于其上，或者调试器还是处理不了异常，系统就调用 ExitProcess 函数来终结程序；</p>
</li>
<li><p>在终结程序之前，系统会再次调用发生异常的线程中的所有异常处理过程，这是线程异常处理过程所获得的清理未释放资源的最后机会，此后程序就终结了；</p>
</li>
</ol>
<h4 id="异常的分发过程"><a href="#异常的分发过程" class="headerlink" title="异常的分发过程"></a>异常的分发过程</h4><p>内核态异常的分发过程：</p>
<ol>
<li><p>如果 PreviousMode 为 KernelMode(0)，那么对于第 1 轮处理机会，KiDispatchException 会试图先通知内核调试器来处理该异常；</p>
</li>
<li><p>内核变量 KiDebugRoutine 是用来标识内核调试引擎交互的接口函数；</p>
<p>当内核调试引擎启用时，KiDebugRoutine 指向内核调试引擎 KdpTrap，这个函数会进一步把异常信息封装为数据包发送给内核调试器，当调试内核调试引擎没有启用时，KiDebugRoutine 指向 KdpStub 函数，简单处理后返回；</p>
</li>
<li><p>如果 KiDebugRoutine 返回 TRUE，也就是内核引擎处理了异常，那么 KiDispatchException 便停止继续分发，准备返回；</p>
<p>如果 KiDebugRoutine 返回 FALSE，也就是没有处理该异常，那么 KiDispatchException 会调用 RtlDispatchException 函数，试图寻找已经注册的结构化异常处理器；</p>
<p>会遍历异常登记链表，依次执行每个异常处理器；</p>
<p>如果某个异常处理器处理了，RtlDispatchException 返回 TRUE，否则返回 FALSE；</p>
</li>
<li><p>RtlDispatchException 返回 FALSE，KiDispatchException 会试图给内核调试器第二次机会，如果 KiDebugRoutine 仍然返回 FALSE，那么 KiDispatchException 会认为这是无人处理的异常，会调用 KeBugCheckEx；</p>
</li>
</ol>
<p>用户态异常的分发过程：</p>
<ol>
<li><p>如果是用户模式，即 PreviousMode 参数等于 UserMode(0)，对于第 1 次处理机会，KiDispatchException 会试图将异常分发给用户态的调试器，如果 DebugPort 不为空，将异常发送给调试子系统，调试子系统将异常发送给调试器，如果处理了异常分发结束；</p>
</li>
<li><p>如果调试器没有处理该异常，KiDispatchException 修改用户态栈，返回用户层之后执行 KiUserExceptionDispatcher，此函数会调用 RtlDispatchException 来寻找异常处理器，首先遍历 VEH，然后遍历 SEH；</p>
<p>如果 RtlDispatchException 返回 FALSE，并且当前进程在被调试，那么 KiUserExceptionDispatcher 会调用 ZwRaiseException 并将 FirstChance 设置为 FALSE，进行第二轮分发。如果没有被调试，结束进程；</p>
</li>
<li><p>ZwRaiseException 会通过内核服务 NtRaiseException 把异常传递给 KiDispatchException 来进行分发；</p>
<p>第二次，将异常传递给调试器，如果没有处理将异常分配给 ExceptionPort 异常端口监听者处理，如果返回 FALSE，结束进程；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>逆向分析</category>
        <category>脱壳技术</category>
        <category>文章资料</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>手动重建 IAT</title>
    <url>/posts/3969158325/</url>
    <content><![CDATA[<blockquote>
<p>破坏原程序的输入表是加密外壳必备的功能，因此在脱壳中，输入表的处理是一个关键环节，这需要脱壳者对 PE 格式中输入表的概念必须非常清楚；</p>
<p>手动修复可以更清晰的理解重建输入表的过程及原理，但很辛苦，需要细心细心再细心，中间因为数值填错而苦苦寻找，想象一下在一堆二进制中找一个数值错误，很可怕，但很值得，弄懂了原理，以后就善用工具了；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">UnPackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="http://www.aspack.com/">ASPACK</a>：收费软件，可以试用；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-2">LoadPE</a>，来自互联网；</li>
<li>16 进制修改器为 WinHex；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<span id="more"></span></li>
</ul>
<h4 id="输入表重建的原理"><a href="#输入表重建的原理" class="headerlink" title="输入表重建的原理"></a>输入表重建的原理</h4><p>在输入表结构中，与实际运行相关的主要是 IAT 结构，这个结构用于保存 API 的实际地址；</p>
<p>PE 文件运行时将初始化输入表的这一部分：</p>
<ul>
<li>Windows 加载器首先搜索 OriginalFirstThunk；</li>
<li>如果存在，加载程序将迭代搜索数组中的每个指针，找到每个 IMAGE_IMPORT_BY_NAME 结构所指向的输入函数的地址；</li>
<li>然后，加载器用函数真正的入口地址代替由 FirstThunk 指向的 IMAGE_THUNK_DATA 数组中元素的值；</li>
<li>初始化结束后，输入表中的其它部分就不重要了，程序依靠 IAT 提供的函数地址就可以正常运行；</li>
</ul>
<p>外壳程序一般都会修改原程序文件的输入，然后自己模仿 PE 装载器来填充 IAT 中的相关数据，也就是说，内存中只有一个 IAT，原程序的输入表不在内存中；</p>
<p>输入表重建就是根据这个 IAT 还原整个输入表的结构，包括 IID 结构以及其它各成员指向的数据等；</p>
<p>一些加密软件为了防止输入表被还原，在 IAT 加密上大作文章，此时，由外壳填充到 IAT 中的不是实际的 API 地址，而是用于 Hook API 的外壳代码的地址；</p>
<p>这样，外壳中的代码一旦完成了加载工作，在进入原程序的代码之后，仍然能够间接获得程序的控制权；</p>
<p>因为程序总要与系统打交道，与系统打交道的途径是 API，而 API 的地址已经被替换为外壳的 Hook API 的地址，所以，每次程序与系统打交道，都会让外壳程序获得一次控制权；</p>
<p>这样，外壳就可以进行反跟踪，从而继续保护软件，同时完成某些特殊任务了；</p>
<p>综上所述，重建输入表的关键是获取未加密的 IAT，一般的做法是跟踪加壳程序对 IAT 的处理过程，修改相关指令，不让外壳加密 IAT；</p>
<h4 id="确定-IAT-的地址和大小"><a href="#确定-IAT-的地址和大小" class="headerlink" title="确定 IAT 的地址和大小"></a>确定 IAT 的地址和大小</h4><p>输入表重建的关键是 IAT 的获得；</p>
<p>一般程序的 IAT 是连续排列的，以一个 DWORD 字的 0 作为结束，因此，只要确定 IAT 的一个点，就能获得整个 IAT 的地址和大小；</p>
<p>程序中的每一个 API 函数在 IAT 中都有自己的位置，这样，无论在代码中调用函数多少次，都会通过 IAT 中的同一个函数指针来完成；</p>
<p>程序调用输入函数分为直接调用和间接调用：</p>
<p>直接调用：<code>CALL DWORD PTR [00401506]</code>，直接调用跳转的地址就是函数的行首；</p>
<p>间接调用：<code>CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt;</code>，间接调用是获取跳转地址存储的内容，然后调用；</p>
<p>以 CM 为例：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnysy0v08kj31eb0u0ads.jpg" alt="间接调用"></p>
<p>此处为间接调用，在选择行按下 Enter 键即可到调用位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyszz3dehj31ef0u00x0.jpg" alt="调用位置"></p>
<p>这里有很多跳转至输入函数的指令，也可以说是 IAT 吧（IAT 跳转表）；</p>
<p>IAT 是一块连续排列的数据，因此，可以向上滚动屏幕，直到没有跳转，就是 IAT 的起始位置；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyt7wfurwj318v0u079r.jpg" alt="IAT 的起始位置"></p>
<p>可以看到，当前地址之前的数据为 0，所以可以确定，这里就是 IAT 的起始位置；</p>
<p>既然起始位置是向上滚动，结束位置肯定是向下滚动：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyteiv2nrj31fq0u0n2f.jpg" alt="IAT 结束位置"></p>
<p>需要注意的是，IAT 中的 IID 结构数组以 NULL 确定数据的结尾，所以，IAT 的结尾不是最后一个跳转指向的地址，而是下一个 DWORD <code>00000000</code>；</p>
<p>为了更直观地观察，可以让数据窗口直接显示这些 API 函数，以确定 IAT 是否正确：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnytpedhm7j31ds0u0tde.jpg" alt="直观地观察"></p>
<p>设置数据窗口显示方式后，可以更直观地看到 IAT 的起始地址和结束地址；</p>
<h4 id="根据-IAT-重建输入表"><a href="#根据-IAT-重建输入表" class="headerlink" title="根据 IAT 重建输入表"></a>根据 IAT 重建输入表</h4><ol>
<li><p>使用 ASPACK 加密 CM，然后导入 OD；</p>
</li>
<li><p>使用栈平衡法定位并跳转至 OEP；</p>
</li>
<li><p>运行 LoadPE，将内存数据 Dump 出来并保存（Dump 过程中不能关闭 OD）：</p>
<p>Dump（转存）是指把内存指定地址的映像文件读出，用文件等形式将其保存下来的过程；</p>
<p>在程序到达 OEP 且没有运行时，Dump 是正确的，而程序运行后，由于一些变量已经初始化了，所以不适合 Dump；</p>
<p>在外壳处理过程中，外壳要把压缩后的全部代码数据释放到内存中，并初始化一些项目，因此，在此过程中也可以选择合适的位置进行 Dump；</p>
<p>常用的 Dump 软件有 LoadPE、PETool- 等，这类工具一般利用 Module32Next 来获取欲 Dump 进程的基本信息；</p>
<p>首先设置 LoadPE，勾选完整转存选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyu1ofv8cj30so0is74t.jpg" alt="设置 LoadPE"></p>
<p>设置完成后，在 LoadPE 的进程窗口中选择 CM 的进程，然后单击右键，在弹出的快捷菜单中执行“完整转存”命令，抓取并保存：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyu86qvv6j30ys0jaab0.jpg" alt="Dump"></p>
<p>注意保存文件的后缀，默认为 .dll 需要修改为 .exe；</p>
</li>
<li><p>运行 dumped.exe 发现不能运行：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyub982ydj30pe0eyq3b.jpg" alt="不能运行"></p>
<p>将 dumped.exe 导入 OD，在弹出错误弹窗后，程序并没有停在 OEP 位置，说明异常是在初始化时产生的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyuihwfs0j31e40u00vv.jpg" alt="异常是在初始化时产生的"></p>
<p>查看 log 窗口，发现创建进程后异常就发生了，程序都没有完成初始化；</p>
</li>
<li><p>回到反汇编窗口，goto 到 OEP，然后来到 IAT 表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyux7yeyaj318b0u00xf.jpg" alt="来到 IAT 表"></p>
<p>发现 PE 加载器在搜索 OriginalFirstThunk 数组时异常了；</p>
<p>这时，就需要修复了；</p>
</li>
<li><p>回到之前的 OD，通过查看 IAT 可以看到，CM 使用了 5 个 DLL，分别是：user32.dll、kernel32.dll、comctl32.dll、GDI32.dll、comdlg32.dll，它们分别对应一个 IAT，IAT 之间以一个 DWORD 类型的 0 隔开，整理 IAT 成员的函数：</p>
<table>
<thead>
<tr>
<th align="center">user32.dll</th>
<th align="center">kernel32.dll</th>
<th align="center">comctl32.dll</th>
<th align="center">GDI32.dll</th>
<th align="center">comdlg32.dll</th>
</tr>
</thead>
<tbody><tr>
<td align="center">KillTimer</td>
<td align="center">GetLocalTime</td>
<td align="center">InitCommonControls</td>
<td align="center">TextOutA</td>
<td align="center">GetSaveFileNameA</td>
</tr>
<tr>
<td align="center">GetSystemMetrics</td>
<td align="center">OpenFile</td>
<td align="center">CreateToolbarEx</td>
<td align="center">StartPage</td>
<td align="center">GetOpenFileNameA</td>
</tr>
<tr>
<td align="center">LoadCursorA</td>
<td align="center">GlobalFree</td>
<td align="center">CreateToolbar</td>
<td align="center">StartDocA</td>
<td align="center">PrintDlgA</td>
</tr>
<tr>
<td align="center">LoadAcceleratorsA</td>
<td align="center">GlobalAlloc</td>
<td align="center"></td>
<td align="center">GetTextMetricsA</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">MessageBeep</td>
<td align="center">lstrlenA</td>
<td align="center"></td>
<td align="center">GetStockObject</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetWindowRect</td>
<td align="center">CloseHandle</td>
<td align="center"></td>
<td align="center">EndPage</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">LoadStringA</td>
<td align="center">WriteFile</td>
<td align="center"></td>
<td align="center">EndDoc</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">LoadIconA</td>
<td align="center">GetModuleHandleA</td>
<td align="center"></td>
<td align="center">DeleteObject</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">LoadBitmapA</td>
<td align="center">ReadFile</td>
<td align="center"></td>
<td align="center">DeleteDC</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SetFocus</td>
<td align="center">ExitProcess</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">MessageBoxA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PostQuitMessage</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">WinHelpA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">InvalidateRect</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TranslateAcceleratorA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">MoveWindow</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TranslateMessage</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">LoadMenuA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ShowWindow</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SendMessageA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SetTimer</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SetWindowPos</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">UpdateWindow</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">RegisterClassA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">BeginPaint</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CreateWindowExA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DefWindowProcA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DialogBoxParamA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DispatchMessageA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DrawMenuBar</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">EndDialog</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">EndPaint</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FindWindowA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetDC</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetDlgItem</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetDlgItemTextA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetMessageA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>接下来就是修复了，使用 WinHex 打开 dumped.exe，在文件中找到一块空白空间，将表中的 DLL 名和函数名写进去：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnywqu2k84j31ue0h0qaq.jpg" alt="函数数据"></p>
<p>为了加深对输入表的理解，手动。。。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyx9ny4d8j318f0u00vz.jpg" alt="写进去"></p>
<p>写入数据时：</p>
<ul>
<li><p>每个函数前面要留 2 个字节来存放函数的序号，序号可以为 0；</p>
</li>
<li><p>每个函数后的 1 字节为 0，即以 0 结尾；</p>
</li>
<li><p>每个函数名或 DLL 名的起始位置必须按偶数对齐，空隙用 0 填充；</p>
</li>
</ul>
<p>因为 dumped.exe 是内存映像文件，所以文件偏移地址和相对虚拟地址（RVA）是相等的；</p>
<p>整理 DLL 名和 API 名所在的偏移地址：</p>
<table>
<thead>
<tr>
<th align="center">DLL 或 API 名称</th>
<th align="center">地址</th>
<th align="center">API 名称</th>
<th align="center">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user32.dll</td>
<td align="center">00002200</td>
<td align="center">user32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">KillTimer</td>
<td align="center">00002240</td>
<td align="center">GetSystemMetrics</td>
<td align="center">0000224C</td>
</tr>
<tr>
<td align="center">LoadCursorA</td>
<td align="center">00002260</td>
<td align="center">LoadAcceleratorsA</td>
<td align="center">0000226E</td>
</tr>
<tr>
<td align="center">MessageBeep</td>
<td align="center">00002282</td>
<td align="center">GetWindowRect</td>
<td align="center">00002290</td>
</tr>
<tr>
<td align="center">LoadStringA</td>
<td align="center">000022A0</td>
<td align="center">LoadIconA</td>
<td align="center">000022AE</td>
</tr>
<tr>
<td align="center">LoadBitmapA</td>
<td align="center">000022BA</td>
<td align="center">SetFocus</td>
<td align="center">000022C8</td>
</tr>
<tr>
<td align="center">MessageBoxA</td>
<td align="center">000022D4</td>
<td align="center">PostQuitMessage</td>
<td align="center">000022E2</td>
</tr>
<tr>
<td align="center">WinHelpA</td>
<td align="center">000022F4</td>
<td align="center">InvalidateRect</td>
<td align="center">00002300</td>
</tr>
<tr>
<td align="center">TranslateAcceleratorA</td>
<td align="center">00002312</td>
<td align="center">MoveWindow</td>
<td align="center">0000232A</td>
</tr>
<tr>
<td align="center">TranslateMessage</td>
<td align="center">00002338</td>
<td align="center">LoadMenuA</td>
<td align="center">000234C</td>
</tr>
<tr>
<td align="center">ShowWindow</td>
<td align="center">00002358</td>
<td align="center">SendMessageA</td>
<td align="center">00002366</td>
</tr>
<tr>
<td align="center">SetTimer</td>
<td align="center">00002376</td>
<td align="center">SetWindowPos</td>
<td align="center">00002382</td>
</tr>
<tr>
<td align="center">UpdateWindow</td>
<td align="center">00002392</td>
<td align="center">RegisterClassA</td>
<td align="center">000023A2</td>
</tr>
<tr>
<td align="center">BeginPaint</td>
<td align="center">000023B4</td>
<td align="center">CreateWindowExA</td>
<td align="center">000023C2</td>
</tr>
<tr>
<td align="center">DefWindowProcA</td>
<td align="center">000023D4</td>
<td align="center">DialogBoxParamA</td>
<td align="center">000023E6</td>
</tr>
<tr>
<td align="center">DispatchMessageA</td>
<td align="center">000023F8</td>
<td align="center">DrawMenuBar</td>
<td align="center">0000240C</td>
</tr>
<tr>
<td align="center">EndDialog</td>
<td align="center">0000241A</td>
<td align="center">EndPaint</td>
<td align="center">00002426</td>
</tr>
<tr>
<td align="center">FindWindowA</td>
<td align="center">00002432</td>
<td align="center">GetDC</td>
<td align="center">00002440</td>
</tr>
<tr>
<td align="center">GetDlgItem</td>
<td align="center">00002448</td>
<td align="center">GetDlgItemTextA</td>
<td align="center">00002456</td>
</tr>
<tr>
<td align="center">GetMessageA</td>
<td align="center">00002468</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">kernel32.dll</td>
<td align="center">0000220C</td>
<td align="center">kernel32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetLocalTime</td>
<td align="center">00002476</td>
<td align="center">OpenFile</td>
<td align="center">00002486</td>
</tr>
<tr>
<td align="center">GlobalFree</td>
<td align="center">00002492</td>
<td align="center">GlobalAlloc</td>
<td align="center">000024A0</td>
</tr>
<tr>
<td align="center">lstrlenA</td>
<td align="center">000024AE</td>
<td align="center">CloseHandle</td>
<td align="center">000024B8</td>
</tr>
<tr>
<td align="center">WriteFile</td>
<td align="center">000024C6</td>
<td align="center">GetModuleHandleA</td>
<td align="center">000024D2</td>
</tr>
<tr>
<td align="center">ReadFile</td>
<td align="center">000024E6</td>
<td align="center">ExitProcess</td>
<td align="center">000024F2</td>
</tr>
<tr>
<td align="center">comctl32.dll</td>
<td align="center">0000221A</td>
<td align="center">comctl32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">InitCommonControls</td>
<td align="center">00002500</td>
<td align="center">CreateToolbarEx</td>
<td align="center">00002516</td>
</tr>
<tr>
<td align="center">CreateToolbar</td>
<td align="center">00002528</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GDI32.dll</td>
<td align="center">00002228</td>
<td align="center">GDI32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TextOutA</td>
<td align="center">00002538</td>
<td align="center">StartPage</td>
<td align="center">00002544</td>
</tr>
<tr>
<td align="center">StartDocA</td>
<td align="center">00002550</td>
<td align="center">GetTextMetricsA</td>
<td align="center">0000255C</td>
</tr>
<tr>
<td align="center">GetStockObject</td>
<td align="center">0000256E</td>
<td align="center">EndPage</td>
<td align="center">00002580</td>
</tr>
<tr>
<td align="center">EndDoc</td>
<td align="center">0000258A</td>
<td align="center">DeleteObject</td>
<td align="center">00002594</td>
</tr>
<tr>
<td align="center">DeleteDC</td>
<td align="center">000025A4</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">comdlg32.dll</td>
<td align="center">00002232</td>
<td align="center">comdlg32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetSaveFileNameA</td>
<td align="center">000025B0</td>
<td align="center">GetOpenFileNameA</td>
<td align="center">000025C4</td>
</tr>
<tr>
<td align="center">PrintDlgA</td>
<td align="center">000025D8</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>接着，构造指向函数名地址的 IMAGE_THUNK_DATA 数组：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz01e8sjhj318c0u0q5p.jpg" alt="IMAGE_THUNK_DATA 数组"></p>
<p>位置随意，两个数组之间的间隔为 2 字节，用 0 填充（小端序构建）；</p>
<p>然后构建其 IID 数组：</p>
<table>
<thead>
<tr>
<th align="center">DLL</th>
<th align="center">OrignalFirstThunk</th>
<th align="center">TimeDateStamp</th>
<th align="center">ForwardChain</th>
<th align="center">Name</th>
<th align="center">FirstThunk</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user32.dll</td>
<td align="center">00290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">00220000</td>
<td align="center">84310000</td>
</tr>
<tr>
<td align="center">kernel32.dll</td>
<td align="center">98290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">0C220000</td>
<td align="center">1C320000</td>
</tr>
<tr>
<td align="center">comctl32.dll</td>
<td align="center">C4290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">1A220000</td>
<td align="center">48320000</td>
</tr>
<tr>
<td align="center">GDI32.dll</td>
<td align="center">D4290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">28220000</td>
<td align="center">58320000</td>
</tr>
<tr>
<td align="center">comdlg32.dll</td>
<td align="center">FC290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">32220000</td>
<td align="center">80320000</td>
</tr>
<tr>
<td align="center">（结束标志 ）</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
</tr>
</tbody></table>
<p>接下来，使用 LoadPE 修改输入表地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz7h6rl86j30n60lsdg9.jpg" alt="使用 LoadPE修改输入表地址"></p>
<p>修改完成后，运行程序，一切正确，这就完了吗？并没有；</p>
<p>将 dumped.exe 导入 OD：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz7m49balj313806sdg1.jpg" alt="弹出警告"></p>
<p>程序会弹出提示入口点超出代码段范围的警告，所以，还需要修改 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz7r455y1j31dw0u0n0a.jpg" alt="修改OEP"></p>
<p>修改 OEP 为正常数值，并保存修改到可执行文件；</p>
<p>将保存的文件导入 OD，然后检查 IAT，有数据才算正常：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz7ub6ct2j31jn0u0tb7.jpg" alt="检查IAT"></p>
</li>
<li><p>总结一下：</p>
<ul>
<li>构建 IMAGE_IMPORT_BY_NAME 结构体，用来存储 DLL 名和 API 名；</li>
<li>构建 IMAGE_THUNK_DATA 结构体，指向函数名对应的地址；</li>
<li>构建 IID 结构体，OrignalFirstThunk 指向 IMAGE_THUNK_DATA 对应的起始地址，Name 指向 IMAGE_IMPORT_BY_NAME 对应的地址，FirstThunk 指向原程序的 IAT 表；</li>
<li>构建过程中，每项的注意事项不再赘述；</li>
</ul>
</li>
<li><p>所有修改如下：</p>
<ul>
<li><p>IMAGE_IMPORT_BY_NAME：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8byl9soj31360sqq4g.jpg" alt="1"><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8c1acqcj312y0ti403.jpg" alt="2"><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8c43rquj31300gujs4.jpg" alt="3"></p>
</li>
<li><p>IMAGE_THUNK_DATA：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8fazzagj31340j43yq.jpg" alt="4"></p>
</li>
<li><p>IID：<br><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8gumd8lj313409omxd.jpg" alt="5"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>IAT</tag>
        <tag>ASPack</tag>
      </tags>
  </entry>
  <entry>
    <title>扫雷游戏</title>
    <url>/posts/2610596285/</url>
    <content><![CDATA[<p>从上微机课开始，在没有网而且啥也不会的情况下，扫雷成了打发时间的唯一乐趣，玩过没写过，今天来试试；</p>
<h4 id="需要实现的功能"><a href="#需要实现的功能" class="headerlink" title="需要实现的功能"></a>需要实现的功能</h4><ol>
<li>显示周围区域 💣 雷的个数；</li>
<li>周围没有雷则自动展开；</li>
<li>剩下的全部为雷则自动胜出；</li>
</ol>
<span id="more"></span>

<h4 id="游戏实现的思路"><a href="#游戏实现的思路" class="headerlink" title="游戏实现的思路"></a>游戏实现的思路</h4><h5 id="0-逻辑分析"><a href="#0-逻辑分析" class="headerlink" title="0. 逻辑分析"></a>0. 逻辑分析</h5><ol>
<li>布置雷，由于既需要存放布置雷的数据，又要展示隐藏雷后的数据给玩家，所以需要两个 char 数组，分别存放相应的数据；</li>
<li>排查雷，玩家输入坐标，如果是雷，结束游戏，如果不是雷，则显示周围雷的个数，如果周围区域都没有雷，则自动展开空白区域；</li>
<li>判定是否自动胜出；</li>
</ol>
<h5 id="1-main-函数"><a href="#1-main-函数" class="headerlink" title="1. main 函数"></a>1. main 函数</h5><p>在 main 函数中写出程序的整体框架，然后再具体实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; //输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;//随机数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;//随机数种子需要的时间</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要显示行和列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 9</span></span><br><span class="line"><span class="comment">//实际的行和列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS ROW + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLS COL + 2</span></span><br><span class="line"><span class="comment">//雷的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINES 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_menu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//游戏开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//存放布置雷的数据</span></span><br><span class="line">    <span class="keyword">char</span> mine[ROWS][COLS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//存放游戏数据</span></span><br><span class="line">    <span class="keyword">char</span> show[ROWS][COLS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//用户输入</span></span><br><span class="line">    <span class="keyword">int</span> input = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单至少会显示一次，do while 正合适</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//显示菜单</span></span><br><span class="line">        display_menu();</span><br><span class="line">        <span class="comment">//提示用户输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请选择:&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//获取用户输入</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据用户输入确定程序走向</span></span><br><span class="line">        <span class="keyword">switch</span> (input)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//输入 1 表示开始游戏</span></span><br><span class="line">            play_game(mine, show);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//输入 0 表示结束游戏</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出游戏！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">//非 0 非 1 不正确，重新输入</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误，请重新输入！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (input); <span class="comment">// 0 退出，非 0 为真，刚刚好</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里为什么要定义 ROW 和 ROWS 以及 COL 和 COLS 呢？以图为例：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp3de8lg0gj30j00gqt9b.jpg" alt="ROWS"></p>
<p>如图，在后面需要统计以玩家输入的坐标为中心的九宫格（绿色区域）中雷的数量时，如果按照真实展示的网格（红色区域）来计算的话，数组下标会越界，所以在行和列的周围各增加一行或一列，初始化时全部填充为默认内容，这样就不会产生下标越界的问题了；</p>
<h5 id="2-菜单"><a href="#2-菜单" class="headerlink" title="2. 菜单"></a>2. 菜单</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******** 1. play ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******** 0. exit ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>菜单简陋，聊胜于无；</p>
<h5 id="3-开始游戏"><a href="#3-开始游戏" class="headerlink" title="3. 开始游戏"></a>3. 开始游戏</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//随机布置雷的种子</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化布置雷的数组 - 存储雷盘</span></span><br><span class="line">    init_board(mine, ROWS, COLS, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">//初始化要显示的数组 - 展示雷盘</span></span><br><span class="line">    init_board(show, ROWS, COLS, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个数组打印到屏幕上</span></span><br><span class="line">    display_board(mine, ROW, COL);</span><br><span class="line">    display_board(show, ROW, COL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先初始化布置雷的数组：将数组的元素全部填充为字符<code>0</code>（不是数字 0），后面布置的雷则会填充字符<code>1</code>（不是数字 1）；</p>
<p>然后初始化展示给玩家的数组：将数组的元素全部填充为字符<code>*</code>；</p>
<p>这两步的意义是：当玩家输入坐标后，用坐标去存储雷盘中匹配信息，如果是雷，则退出游戏，如果不是雷，则根据返回信息，在展示雷盘中显示周围雷的个数，如果指定范围没有雷，则自动展开空白区域；</p>
<p>最后，为了方便调试，将两个数组的信息都输出到屏幕上；</p>
<h5 id="4-初始化存储雷盘和展示雷盘"><a href="#4-初始化存储雷盘和展示雷盘" class="headerlink" title="4. 初始化存储雷盘和展示雷盘"></a>4. 初始化存储雷盘和展示雷盘</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_board</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span> filler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][j] = filler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码没啥好说的，遍历数组，然后用给定的字符填充；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_board</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印列序号，从零开始是为了对齐</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= col; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印行序号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了输入坐标时更直观，这里打印行序号和列序号；</p>
<p>至此，就可以测试一下了，输出初始化后的雷盘：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp39qidldej30as0ng75c.jpg" alt="输出初始化后的雷盘"></p>
<p>工整的显示，完美，同时也说明了打印列序号为何要从 0 开始；</p>
<h5 id="5-布置雷"><a href="#5-布置雷" class="headerlink" title="5. 布置雷"></a>5. 布置雷</h5><p>雷盘有了，接下来就是布置雷了；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_mine</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取雷的数量</span></span><br><span class="line">    <span class="keyword">int</span> mines = MINES;</span><br><span class="line">    <span class="comment">//如果雷不为 0 则继续布置</span></span><br><span class="line">    <span class="keyword">while</span> (mines)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//求余 row 的范围为 0 ～ (row - 1)，加 1 之后范围为 1 ～ row，col 一样；</span></span><br><span class="line">        <span class="keyword">int</span> x = rand() % row + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = rand() % col + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//坐标合法则将 &#x27;0&#x27; 替换为 &#x27;1&#x27;，表示是布置的雷</span></span><br><span class="line">        <span class="keyword">if</span> (arr[x][y] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="comment">//每布置成功一次，雷的数量自减 1</span></span><br><span class="line">            mines--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布置雷很简单，生成随机数后，只要坐标合法，就将存储雷盘对应的坐标位置由字符<code>0</code>替换为字符<code>1</code>即可；</p>
<p>布置完成了，测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp3a2ml23fj30am0nkdgu.jpg" alt="布置完成测试一下"></p>
<p>数一数，刚好 10 个雷，与预定义的雷数量一致；</p>
<h5 id="6-开始玩游戏"><a href="#6-开始玩游戏" class="headerlink" title="6. 开始玩游戏"></a>6. 开始玩游戏</h5><p>获胜的规则很简单：雷盘中没有空白区域则获胜；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_mine</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取用户输入的坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计没有雷的坐标</span></span><br><span class="line">    <span class="keyword">int</span> win = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断输入越界</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">0</span> || x &gt; row || y &lt;= <span class="number">0</span> || y &gt; col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误，请重新输入！\n&quot;</span>);</span><br><span class="line">            display_board(show, row, col);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断是否是雷</span></span><br><span class="line">            <span class="keyword">if</span> (mine[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;踩到雷了，游戏结束！\n&quot;</span>);</span><br><span class="line">                <span class="comment">//提示的同时，输出存储雷盘，显示布置雷的位置，让玩家输得心服口服</span></span><br><span class="line">                display_board(mine, row, col);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获取以当前坐标为中心的 3 * 3 雷盘中雷的数量</span></span><br><span class="line">                <span class="keyword">int</span> count = get_mine_count(mine, x, y);</span><br><span class="line">                <span class="comment">//如果周围的 8 个坐标中都没有雷</span></span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//展开空白区域</span></span><br><span class="line">                    show_blank_space(mine, show, x, y, &amp;win);</span><br><span class="line">                    <span class="comment">//然后显示雷盘</span></span><br><span class="line">                    display_board(show, row, col);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *字符 &#x27;0&#x27; 的 ASCII 值为 48，字符 &#x27;1&#x27; 的 ASCII 值为 49，以此类推，</span></span><br><span class="line"><span class="comment">                     *用字符 &#x27;0&#x27; 加上指定数字，就是当前数字对应的字符值</span></span><br><span class="line"><span class="comment">                     *例如 &#x27;0&#x27; + 1 = &#x27;1&#x27;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">//如果周围 8 个区域中有雷，则在玩家输入的坐标中显示周围雷的数量</span></span><br><span class="line">                    show[x][y] = <span class="string">&#x27;0&#x27;</span> + count;</span><br><span class="line">                    <span class="comment">//统计不含雷的区域</span></span><br><span class="line">                    win++;</span><br><span class="line">                    display_board(show, row, col);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//每输入一次坐标，判断一次</span></span><br><span class="line">                <span class="comment">//如果不含雷坐标的数量 = 所有坐标 - 雷的数量，则说明已经没有空白区域，玩家自动胜出</span></span><br><span class="line">                <span class="keyword">if</span> (win == ROW * COL - MINES)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;排雷成功！\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    display_board(mine, row, col);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先，获取用户输入，然后判断输入是否越界，越界则重新输入；</p>
</li>
<li><p>判断用户输入的坐标是否是雷，是雷则结束游戏；</p>
</li>
<li><p>如果用户输入的坐标不是雷，则进行如下操作：</p>
<p>以当前坐标为中心，计算周围 3 * 3 的九宫格中雷的数量，规则如下：</p>
<ul>
<li>如果此范围中有雷，则将雷的数量写入展示雷盘对应的坐标中，游戏继续；</li>
<li>如果此范围中没有雷，则以当前九宫格的每个元素为中心，再次统计周围 3 * 3 的范围中雷的数量；</li>
<li>直到坐标周围有雷则结束展开空白区域；</li>
</ul>
</li>
</ol>
<h5 id="7-获取坐标周围雷的数量"><a href="#7-获取坐标周围雷的数量" class="headerlink" title="7. 获取坐标周围雷的数量"></a>7. 获取坐标周围雷的数量</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_mine_count</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count = count + mine[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符<code>0</code>的 ASCII 值为 48，字符<code>1</code>的 ASCII 值为 49，以此类推，用任意数字字符的值减去字符<code>0</code>就是这个字符的整型值，例如：’1’ - ‘0’ = 1；</p>
<h5 id="8-自动展开空白区域"><a href="#8-自动展开空白区域" class="headerlink" title="8. 自动展开空白区域"></a>8. 自动展开空白区域</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_blank_space</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS], <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下标从 -1 ～ 1，则有三种状态，x - 1, x + 0, x + 1</span></span><br><span class="line">    <span class="comment">//两个循环则有 9 种状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//由于同时为 0 表示的是 自身，没有意义，所以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> || j != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断坐标是否合法 1 ～ ROW 或 1 ～ COL</span></span><br><span class="line">                <span class="keyword">if</span> (x + i &gt;= <span class="number">1</span> &amp;&amp; x + i &lt;= ROW &amp;&amp; y + j &gt;= <span class="number">1</span> &amp;&amp; y + j &lt;= COL)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//当前坐标没有被自动展开，并且当前坐标不是雷的情况下，才进行统计，否则没有意义</span></span><br><span class="line">                    <span class="keyword">if</span> (show[x + i][y + j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; mine[x + i][y + j] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//判断以坐标为中心的九宫格是否有雷</span></span><br><span class="line">                        <span class="keyword">int</span> count = get_mine_count(mine, x + i, y + j);</span><br><span class="line">                        <span class="comment">//没有雷</span></span><br><span class="line">                        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//展开坐标</span></span><br><span class="line">                            show[x + i][y + j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                            <span class="comment">//统计没有雷的坐标数量</span></span><br><span class="line">                            (*p)++;</span><br><span class="line">                            show_blank_space(mine, show, x + i, y + j, p);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//有雷</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//显示雷的数量</span></span><br><span class="line">                            show[x + i][y + j] = count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                            (*p)++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="9-判断是否获胜"><a href="#9-判断是否获胜" class="headerlink" title="9. 判断是否获胜"></a>9. 判断是否获胜</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (win == ROW * COL - MINES)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排雷成功！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    display_board(mine, row, col);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚开始，写了一个计算胜出的函数，无非就是遍历数组的每个元素，判断是不是初始化时填充的字符（这里初始化时填充的是<code>*</code>），如果存储雷盘中有初始化时填充的字符，则游戏继续，否则玩家胜出；</p>
<p>但这种方法性能太低了，每输入一次就需要遍历整个数组，所以这里使用了指针，每次输入且输入有效时，统计不是雷的坐标，然后用坐标总数减去雷的数量与统计的数量进行比较，如果数量相同，则说明剩下的都是雷了，玩家自动胜出；</p>
<h5 id="10-试玩-测试"><a href="#10-试玩-测试" class="headerlink" title="10. 试玩 - 测试"></a>10. 试玩 - 测试</h5><p>为了方便测试后面的逻辑，将雷的数量设置为 80，也就是说只有一个不是雷：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp3cvs1hh3j30lm0ke76l.jpg" alt="80个雷"></p>
<p>自动胜出的逻辑正常，现在就差自动展开了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gp3cw0mn0ij30l40kagnl.jpg" alt="自动展开"></p>
<p>自动展开正常；</p>
<h5 id="11-完整代码"><a href="#11-完整代码" class="headerlink" title="11. 完整代码"></a>11. 完整代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS ROW + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLS COL + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINES 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_menu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//开始游戏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS])</span></span>;</span><br><span class="line"><span class="comment">//初始化两个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_board</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span> filler)</span></span>;</span><br><span class="line"><span class="comment">//显示雷盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_board</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//布置雷</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_mine</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//获取玩家输入并判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_mine</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">//获取某个坐标周围雷的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_mine_count</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="comment">//展开坐标周围空白区域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_blank_space</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS], <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> *p)</span></span>;</span><br><span class="line"><span class="comment">//排雷成功</span></span><br><span class="line"><span class="comment">// int is_win(char show[ROWS][COLS], int row, int col);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//埋雷</span></span><br><span class="line">    <span class="keyword">char</span> mine[ROWS][COLS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//显示雷</span></span><br><span class="line">    <span class="keyword">char</span> show[ROWS][COLS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> input = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        display_menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请选择:&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span> (input)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            play_game(mine, show);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出游戏！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误，请重新输入！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******** 1. play ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******** 0. exit ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play_game</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    init_board(mine, ROWS, COLS, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    init_board(show, ROWS, COLS, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    set_mine(mine, ROW, COL);</span><br><span class="line">    display_board(show, ROW, COL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    find_mine(mine, show, ROW, COL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_board</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span> filler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][j] = filler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_board</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= col; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_mine</span><span class="params">(<span class="keyword">char</span> arr[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mines = MINES;</span><br><span class="line">    <span class="keyword">while</span> (mines)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand() % row + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = rand() % col + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[x][y] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            mines--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_mine</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> win = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">0</span> || x &gt; row || y &lt;= <span class="number">0</span> || y &gt; col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误，请重新输入！\n&quot;</span>);</span><br><span class="line">            display_board(show, row, col);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mine[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;踩雷到了，游戏结束！\n&quot;</span>);</span><br><span class="line">                display_board(mine, row, col);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> count = get_mine_count(mine, x, y);</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    show_blank_space(mine, show, x, y, &amp;win);</span><br><span class="line">                    display_board(show, row, col);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    show[x][y] = <span class="string">&#x27;0&#x27;</span> + count;</span><br><span class="line">                    win++;</span><br><span class="line">                    display_board(show, row, col);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (win == ROW * COL - MINES)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;排雷成功！\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    display_board(mine, row, col);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_mine_count</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count = count + mine[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_blank_space</span><span class="params">(<span class="keyword">char</span> mine[ROWS][COLS], <span class="keyword">char</span> show[ROWS][COLS], <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> || j != <span class="number">0</span>) <span class="comment">//同时为 0 表示自身，则跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x + i &gt;= <span class="number">1</span> &amp;&amp; x + i &lt;= ROW &amp;&amp; y + j &gt;= <span class="number">1</span> &amp;&amp; y + j &lt;= COL)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (show[x + i][y + j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; mine[x + i][y + j] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> count = get_mine_count(mine, x + i, y + j);</span><br><span class="line">                        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            show[x + i][y + j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                            (*p)++;</span><br><span class="line">                            show_blank_space(mine, show, x + i, y + j, p);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            show[x + i][y + j] = count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                            (*p)++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>扫雷游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>PE 文件格式</title>
    <url>/posts/1876828466/</url>
    <content><![CDATA[<blockquote>
<p>记录<a href="https://reversecore.com/">逆向工程核心原理</a>、<a href="https://bbs.pediy.com/forum-99.htm">加密解密</a>、<a href="http://www.hzcourse.com/web/refbook/detail/4372/215">Windows PE 权威指南</a>等书中对 PE 文件格式的部分描述，眼过千遍不如手过一遍，加强学习，同时作为备忘，初始对很多内容理解不够深刻且容易忘记，日后需多加复习和练习；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><code>WinHex</code>来自互联网；</li>
<li>文中特殊数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<span id="more"></span>

<h3 id="PE-文件格式"><a href="#PE-文件格式" class="headerlink" title="PE 文件格式"></a>PE 文件格式</h3><p>PE 文件是 Windows 操作系统下的可执行文件格式；</p>
<p>是微软在 UNIX 平台的 COFF（Common Object File Format，通用对象文件格式）基础上制作而成的；</p>
<p>在 Win16 平台上，可执行文件格式是 NE；</p>
<p>在 Win32 平台上，可执行文件格式是 PE（Portable Executable File Format，可移植的执行体）；</p>
<p>PE 文件是指 32 位的可执行文件，也称为 PE32；</p>
<p>64 位的可执行文件称为 PE+ 或 PE32+，是 PE 文件的一种扩展形式，而不是 PE64；</p>
<blockquote>
<p>Tips：⚠️ 为当前参数列表需重点关注</p>
</blockquote>
<h4 id="PE-文件种类"><a href="#PE-文件种类" class="headerlink" title="PE 文件种类"></a>PE 文件种类</h4><table>
<thead>
<tr>
<th align="center">种类</th>
<th align="center">主扩展名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可执行系列</td>
<td align="center">EXE、SCR</td>
</tr>
<tr>
<td align="center">库系列</td>
<td align="center">DLL、OCX、CPL、DRV</td>
</tr>
<tr>
<td align="center">驱动程序系列</td>
<td align="center">SYS、VXD</td>
</tr>
<tr>
<td align="center">对象文件系列</td>
<td align="center">OBJ</td>
</tr>
</tbody></table>
<p>除 OBJ 文件之外的所有文件都是可执行的；</p>
<p>EXE 文件和 DLL 文件的区别完全是语义上的，它们使用完全相同的 PE 格式，唯一的区别就是用一个字段标识出这个文件是 EXE 还是 DLL；</p>
<p>DLL、SYS 文件等虽然不能直接在 Shell 中运行，但可以使用其它方法执行；</p>
<p>只有扩展名为 .DLL 的动态链接库才能被 Windows 操作系统自动加载；</p>
<p>如果文件有另外的扩展名，则必须明确地用 LoadLibrary 或 LoadLibraryEx 函数加载；</p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>PE 文件使用的是一个平面地址空间，所有代码和数据都合并在一起，组成一个很大的结构；</p>
<p>文件的内容被分割为不同的区块（Section，又称区段、节等）；</p>
<p>区块中包含代码或数据，各个区块按页边界对齐；</p>
<p>区块没有大小限制，是一个连续结构；</p>
<p>每个区块都有它自己在内存中的一套属性，如：是否包含代码、是否只读或可读/写等；</p>
<p>Windows 加载器（又称 PE 装载器）遍历 PE 文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移地址映射到较高的内存地址中；</p>
<p>磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的，但数据之间的相对位置可能会改变，某项的偏移地址可能区别于原始的偏移地址；</p>
<p>当 PE 文件通过 Windows 加载器载入内存后，内存中的版本称为模块（Module）；</p>
<p>映射文件的起始地址称为模块句柄（hModule），可以通过模块句柄访问内存中的其它数据结构，这个初始内存地址也称为基地址（ImageBase）；</p>
<p>基地址的值是由 PE 文件本身设定的，按照默认设置，用 Visual C++ 建立的 EXE 文件的基地址是 00400000，DLL 文件的基地址是 10000000；</p>
<p>从 DOS 头到节区头是 PE 头部分，称为 PE 头，下面的节区合称 PE 体；</p>
<p>文件中使用偏移（offset），内存中使用 VA（Virtual Address，虚拟地址）来表示位置；</p>
<p>文件加载到内存时，节区的大小、位置等会发生变化；</p>
<p>文件的内容一般可以分为代码（.text）、数据（.data）、资源（.src）节等，分别保存；</p>
<p>根据所用的不同开发工具与编译选项，节区的名称、大小、个数、存储的内容等都是不同的，它们按照不同的用途，分类保存到不同的节中；</p>
<p>各节区头定义了各节区在文件或内存中的大小、位置、属性等；</p>
<p>PE 头与各节区的尾部存在一个区域，称为 NULL 填充，也就是 PE 头与各节区以 NULL 分割；</p>
<p>计算机中，为了提高处理文件、内存、网络包的效率，使用“最小基本单位”这一概念，PE 文件也类似；</p>
<p>文件 / 内存中各节区的起始位置应该在各文件 / 内存的最小单位的倍数位置上，空白区域将用 NULL 填充；</p>
<h4 id="VA-amp-RVA"><a href="#VA-amp-RVA" class="headerlink" title="VA &amp; RVA"></a>VA &amp; RVA</h4><p>在 Windows 系统中，PE 文件将被系统加载器映射到内存中；</p>
<p>每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址（Virtual Address，VA）；</p>
<p>VA（Virtual Address，虚拟地址） 指的是进程虚拟内存的绝对地址；</p>
<p>RVA（Relative Virtual Address，相对虚拟地址）指的是从基准位置（ImageBase）开始的相对地址；</p>
<p>VA 与 RVA 之间的关系：虚拟地址（VA） = 相对虚拟地址（RVA） + 基地址（ImageBase）；</p>
<p>PE 头内部信息大多以 RVA 形式存在；</p>
<p>原因在于，PE 文件（主要是 DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其它 PE 文件（DLL）；</p>
<p>此时，必须通过重定位将其加载到其它空白的位置，若 PE 头信息使用的是 VA，则无法正常访问；</p>
<p>因此使用 RVA 来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题；</p>
<p>32 位 Windows 系统中，各进程分配有 4GB 的虚拟内存，因此进程中 VA 值的范围是 00000000 ～ FFFFFFFF；</p>
<h3 id="PE-头"><a href="#PE-头" class="headerlink" title="PE 头"></a>PE 头</h3><p>PE 头由许多结构体组成；</p>
<h4 id="DOS-头"><a href="#DOS-头" class="headerlink" title="DOS 头"></a>DOS 头</h4><p>每个 PE 文件都是以一个 DOS 程序开始的，有了它，一旦程序在 DOS 下执行，DOS 就能识别出这是一个有效的执行体，然后运行紧随 MZ Header 的 DOS stub（DOS 块）；</p>
<p>DOS stub（DOS 存根） 实际上是一个有效的 EXE，在不支持 PE 文件格式的操作系统中，它将简单的显示一个错误提示；</p>
<p>通常把 DOS MZ 头与 DOS stub 合并称为 DOS 头；</p>
<p>微软创建 PE 文件格式时，广泛使用的是 DOS 文件，考虑到 PE 文件对 DOS 文件的兼容性，在 PE 头的最前面添加了一个 IMAGE_DOS_HEADER 结构体，用来扩展已有的 DOS EXE 头；</p>
<p>IMAGE_DOS_HEADER 结构体的大小为 64 字节，在该结构体中必须知道 2 个重要的成员：</p>
<ul>
<li>e_magic：DOS 签名（Signature，5A4D，对应的 ASCII 值是“MZ”），也称为 DOS MZ 头；</li>
<li>e_lfanew：指示 NT 头的偏移（根据不同文件拥有可变值），是真正的 PE 文件头的相对偏移（RVA）位置，占用 4 个字节，位于从文件开始偏移 3C 字节处；</li>
</ul>
<p>所有 PE 文件在开始部分（e_magic）都有 DOS 签名（5A4D，“MZ”）；</p>
<p>一个名叫 Mark Zbikowski 的开发人员在微软设计了 DOS 可执行文件，MZ 取自其名字的首字母；</p>
<p>e_lfanew 值指向 NT 头所在位置（NT 头的名称为 IMAGE_NT_HEADERS）;</p>
<p>NOTEPAD.EXE 的 IMAGE_DOS_HEADER 结构体：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqc1thiodj316q0u0q5s.jpg" alt="IMAGE_DOS_HEADER"></p>
<p>文件开始的 2 个字节为 5A4D，e_lfanew 值为 000000E0（Intel x86 CPU，小端序标识法）；</p>
<h4 id="DOS-存根"><a href="#DOS-存根" class="headerlink" title="DOS 存根"></a>DOS 存根</h4><p>DOS 存根（stub）位于 DOS 头下方，是可选项，且大小不固定；</p>
<p>DOS 存根由代码与数据混合而成；</p>
<p>NOTEPAD.EXE 的 DOS 存根：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqcbjzm65j31360ai74r.jpg" alt="NOTEPAD.EXE 的 DOS 存根"></p>
<h4 id="NT-头（PE-Header，PE-头）"><a href="#NT-头（PE-Header，PE-头）" class="headerlink" title="NT 头（PE Header，PE 头）"></a>NT 头（PE Header，PE 头）</h4><p>NT 头的名称为 IMAGE_NT_HEADERS；</p>
<p>IMAGE_NT_HEADERS 结构体由 3 个成员组成，第一个成员为签名（Signature）结构体，其值为 50450000（“PE”00），另外两个成员分别为文件头（File Header）与可选头（Optional Header）结构体；</p>
<p>通常，标准 PE 文件的 MAGE_NT_HEADERS 结构体由 4 个字节的签名标识符和 20 个字节的基本信息头（文件头）以及 216 个字节的扩展信息头（可选头）组成；</p>
<p>IMAGE_NT_HEADERS 结构体：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqcqnwemej316p0u0go5.jpg" alt="IMAGE_NT_HEADERS 结构体"></p>
<p>IMAGE_NT_HEADERS 结构体的大小为 F8，相当大；</p>
<h4 id="NT-头：文件头-IMAGE-FILE-HEADER"><a href="#NT-头：文件头-IMAGE-FILE-HEADER" class="headerlink" title="NT 头：文件头 IMAGE_FILE_HEADER"></a>NT 头：文件头 IMAGE_FILE_HEADER</h4><p>文件头是表现文件大致属性的 IMAGE_FILE_HEADER 结构体，该结构在微软官方文档中被称为标准通用对象文件格式（Common Object File Format，COFF）头；</p>
<p>IMAGE_FILE_HEADER 结构体的成员：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqokc8tzsj31640dgq4k.jpg" alt="IMAGE_FILE_HEADER 结构体的成员"></p>
<p>以下成员的前 4 个非常重要，若设置不正确，将导致文件无法正常运行：（偏移量基于 PE 文件头 （IMAGE_NT_HEADERS））</p>
<table>
<thead>
<tr>
<th align="center">偏移量</th>
<th align="center">字段</th>
<th align="center">Size</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">Machine ⚠️</td>
<td align="center">WORD</td>
<td align="center">运行平台</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">NumberOfSections ⚠️</td>
<td align="center">WORD</td>
<td align="center">PE 中区块的数量</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">SizeOfOptionalHeader ⚠️</td>
<td align="center">WORD</td>
<td align="center">IMAGE_OPTIONAL_HEADER 结构体的长度</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">Characteristics ⚠️</td>
<td align="center">WORD</td>
<td align="center">文件属性</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">TimeDateStamp</td>
<td align="center">DWORD</td>
<td align="center">文件创建时间</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">PointerToSymbolTable</td>
<td align="center">DWORD</td>
<td align="center">指向符号表</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">NumberOfSymbols</td>
<td align="center">DWORD</td>
<td align="center">符号表中符号的数量</td>
</tr>
</tbody></table>
<ol>
<li><p>Machine：单字，每个 CPU 都拥有唯一的 Machine 码，兼容 32 位 Intel x86 芯片的 Machine 码为 14C，具体定义位于 winnt.h；</p>
<p>几种典型的机器类型标志：</p>
<table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">标志</th>
<th align="center">常量符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">适用于任何处理器</td>
<td align="center">0</td>
<td align="center">IMAGE_FILE_MACHINE_UNKNOWN</td>
</tr>
<tr>
<td align="center">Intel i386 处理器或后续兼容处理器</td>
<td align="center">14C</td>
<td align="center">IMAGE_FILE_MACHINE_I386</td>
</tr>
<tr>
<td align="center">x64 处理器</td>
<td align="center">8664</td>
<td align="center">IMAGE_FILE_MACHINE_AMD64</td>
</tr>
<tr>
<td align="center">MIPS 小尾处理器</td>
<td align="center">166</td>
<td align="center">IMAGE_FILE_MACHINE_R4000</td>
</tr>
<tr>
<td align="center">ARM 小尾处理器</td>
<td align="center">1C0</td>
<td align="center">IMAGE_FILE_MACHINE_ARM</td>
</tr>
<tr>
<td align="center">Power PC 小尾处理器</td>
<td align="center">1F0</td>
<td align="center">IMAGE_FILE_MACHINE_POWERPC</td>
</tr>
</tbody></table>
</li>
<li><p>NumberOfSections：单字，用来指出文件中存在的节区（Section）数量，该值一定要大于 0，且当定义的节区数量与实际数量不同时，将发生运行错误；</p>
<p>如果想在 PE 中增加或删除节，必须变更此处的值；</p>
</li>
<li><p>SizeOfOptionalHeader：单字，IMAGE_NT_HEADERS 结构体的最后一个成员为 IMAGE_OPTIONAL_HEADER 结构体，SizeOfOptionalHeader 成员用来指出 IMAGE_OPTIONAL_HEADER 结构体的长度，表示数据的大小；</p>
<p>Windows 的 PE 装载器需要查看 IMAGE_FILE_HEADER 的 SizeOfOptionalHeader 值，从而识别出 IMAGE_OPTIONAL_HEADER 结构体的大小；</p>
<p>PE32+ 格式的文件中使用的是 IMAGE_OPTIONAL_HEADER64 结构体，而不是 IMAGE_OPTIONAL_HEADER32 结构体；</p>
<p>IMAGE_OPTIONAL_HEADER64 与 IMAGE_OPTIONAL_HEADER32 两个结构体的尺寸不同，所以需要在 SizeOfOptionalHeader 成员中明确指出结构体的大小；</p>
<p>IMAGE_OPTIONAL_HEADER 的大小依赖于当前 PE 文件是 32 位还是 64 位；</p>
<p>对于 32 位 PE 文件，这个域通常是 00E0；<br>对于 64 位 PE 文件，这个域通常是 00F0；</p>
<p>用户可以自定义 SizeOfOptionalHeader 的值，不过需要注意两点：</p>
<ul>
<li>更改完成后，需要自行将文件中 IMAGE_OPTIONAL_HEADER32 的大小扩充为指定的值（一般以 0 填充）；</li>
<li>扩充完成后，要维持文件中的对齐特性（保证每个节区的起始位置不变）；</li>
</ul>
</li>
<li><p>Characteristics：单字，用于标识文件的属性，文件是否为可运行的形态、是否为 DLL 文件等信息，具体定义位于 winnt.h；</p>
<p>属性位字段的含义：</p>
<table>
<thead>
<tr>
<th align="center">特征值</th>
<th align="center">常量符号</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0001</td>
<td align="center">IMAGE_FILE_RELOCS_STRIPPED</td>
<td align="center">文件中不存在重定位信息</td>
</tr>
<tr>
<td align="center">0002</td>
<td align="center">IMAGE_FILE_EXECUTABLE_IMAGE</td>
<td align="center">文件可执行，如果为 0，一般是链接时出问题了 ⚠️</td>
</tr>
<tr>
<td align="center">0004</td>
<td align="center">IMAGE_FILE_LINE_NUMS_STRIPPED</td>
<td align="center">行号信息被移除</td>
</tr>
<tr>
<td align="center">0008</td>
<td align="center">IMAGE_FILE_LOCAL_SYMS_StRIPPED</td>
<td align="center">符号信息被移除</td>
</tr>
<tr>
<td align="center">0020</td>
<td align="center">IMAGE_FILE_LARGE_ADDREss_AWARE</td>
<td align="center">应用程序可以处理超过 2GB 的地址</td>
</tr>
<tr>
<td align="center">0080</td>
<td align="center">IMAGE_FILE_BYTES_REVERSED_LO</td>
<td align="center">处理机的低位字节是相反的</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">IMAGE_FILE_32BIT_MACHINE</td>
<td align="center">目标平台为 32 位机器</td>
</tr>
<tr>
<td align="center">0200</td>
<td align="center">IMAGE_FILE_DEBUG_STRIPPED</td>
<td align="center">.DBG 文件的调试信息被移除</td>
</tr>
<tr>
<td align="center">0400</td>
<td align="center">IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP</td>
<td align="center">如果映像文件位于可移动介质中，则先复制到交换文件中再运行</td>
</tr>
<tr>
<td align="center">0800</td>
<td align="center">IMAGE_FILE_NET_RUN_FROM_SWAP</td>
<td align="center">如果映像文件位于网络中，则复制到交换文件后才运行</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">IMAGE_FILE_SYSTEM</td>
<td align="center">系统文件</td>
</tr>
<tr>
<td align="center">2000</td>
<td align="center">IMAGE_FILE_DLL</td>
<td align="center">文件是 DLL ⚠️</td>
</tr>
<tr>
<td align="center">4000</td>
<td align="center">IMAGE_FILE_UP_SYSTEM_ONLY</td>
<td align="center">文件只能运行在单处理器上</td>
</tr>
<tr>
<td align="center">8000</td>
<td align="center">IMAGE_FILE_BYTES_REVERSED_HI</td>
<td align="center">处理机的高位字节是相反的</td>
</tr>
</tbody></table>
</li>
<li><p>TimeDateStamp：双字，用来记录编译器创建此文件的时间；</p>
</li>
<li><p>PointerToSymbolTable：双字，COFF 符号表的文件偏移位置，若没有符号表存在，将此值设置为 0；</p>
</li>
<li><p>NumberOfSymbols：双字，如果有符号表，它表示其中的符号数目；</p>
</li>
</ol>
<h4 id="NT-头：可选头-IMAGE-OPTIONAL-HEADER"><a href="#NT-头：可选头-IMAGE-OPTIONAL-HEADER" class="headerlink" title="NT 头：可选头 IMAGE_OPTIONAL_HEADER"></a>NT 头：可选头 IMAGE_OPTIONAL_HEADER</h4><p>IMAGE_OPTIONAL_HEADER 是 PE 头结构体中最大的；</p>
<p>可选头又分为两部分，前 10 个字段属于 COFF，用来加载和运行一个可执行文件，后 21 个字段则是通过链接器追加的，作为 PE 扩展部分，用于描述可执行文件的一些信息，供 PE 加载器加载使用；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrfb7n93aj316u0u00vu.jpg" alt="IMAGE_OPTIONAL_HEADER32"></p>
<p>首先在 DOS 头中找到 PE 头（NT 头）的偏移量，然后黄色表示的是签名（IMAGE_NT_SIGNATURE）结构体，红色表示 IMAGE_FILE_HEADER 结构体，黑色和蓝色表示 IMAGE_OPTIONAL_HEADER32 结构体，其中，黑色为 IMAGE_OPTIONAL_HEADER32 结构体中需要重点关注的部分（DataDirectory 成员未标注）；</p>
<p>在 IMAGE_OPTIONAL_HEADER32 结构体中需要关注下列成员，这些成员是文件运行必需的，设置错误将导致文件无法正常运行：（偏移量基于 PE 文件头 （IMAGE_NT_HEADERS））</p>
<table>
<thead>
<tr>
<th align="center">偏移量</th>
<th align="center">字段</th>
<th align="center">Size</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">18</td>
<td align="center">Magic</td>
<td align="center">WORD</td>
<td align="center">标志字</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">AddressOfEntryPoint</td>
<td align="center">DWORD</td>
<td align="center">程序执行入口 RVA</td>
</tr>
<tr>
<td align="center">34</td>
<td align="center">ImageBase</td>
<td align="center">DWORD</td>
<td align="center">程序默认载入基地址</td>
</tr>
<tr>
<td align="center">38</td>
<td align="center">SetionAlignment</td>
<td align="center">DWORD</td>
<td align="center">内存中区块的对齐值</td>
</tr>
<tr>
<td align="center">3C</td>
<td align="center">FileAlignment</td>
<td align="center">DWORD</td>
<td align="center">文件中区块的对齐值</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">SizeOfImage</td>
<td align="center">DWORD</td>
<td align="center">内存中的整个 PE 映像尺寸</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">SizeOfHeaders</td>
<td align="center">DWORD</td>
<td align="center">整个 PE 头的大小</td>
</tr>
<tr>
<td align="center">5C</td>
<td align="center">Subsystem</td>
<td align="center">WORD</td>
<td align="center">文件子系统</td>
</tr>
<tr>
<td align="center">74</td>
<td align="center">NumberOfRvaAndSizes</td>
<td align="center">DWORD</td>
<td align="center">数据目录表的项目数量</td>
</tr>
<tr>
<td align="center">78</td>
<td align="center">DataDirectory</td>
<td align="center"></td>
<td align="center">数据目录表</td>
</tr>
</tbody></table>
<ol>
<li><p>Magic：单字，为 IMAGE_OPTIONAL_HEADER32 结构体时，Magic 码为 10B；为 IMAGE_OPTIONAL_HEADER64 结构体时，Magic 码为 20B，文件为 ROM 映像时，Magic 码为 107；</p>
</li>
<li><p>AddressOfEntryPoint：双字，持有 EP 的 RVA 值，该值指出程序最先执行的代码的起始地址，非常重要；</p>
</li>
<li><p>ImageBase：双字，进程的虚拟内存范围是 00000000 ～ FFFFFFFF（32 位系统），PE 文件被加载到如此大的内存中时，ImageBase 指出文件的优先装载地址，而 ImageBase 就是文件在内存中的首选载入地址， 如果 PE 文件是在这个地址载入的，那么加载器将跳过应用基址重定位的步骤；</p>
<ul>
<li><p>EXE、DLL 文件被装载到用户内存的 00000000 ～ 7FFFFFFF 中；</p>
</li>
<li><p>SYS 文件被装载到内核内存的 80000000 ～ FFFFFFFF 中；</p>
</li>
<li><p>一般而言，使用开发工具创建的 EXE 文件，其默认 ImageBase 值为 00400000，DLL 文件的 ImageBase 值为 10000000；（可以指定为其它值）<br>用户可以自定义 ImageBase 的值，但取值有限：</p>
<ul>
<li>取值不能超出边界，即取的值必须在进程地址空间中；</li>
<li>该值必须是 64KB 的整数倍；</li>
</ul>
</li>
<li><p>执行 PE 文件时，PE 装载器先创建进程，再将文件载入内存，然后把 EIP 寄存器的值设置为 <code>ImageBase + AddressOfEntryPoint</code>；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnymrkwex8j31e90u0wj0.jpg" alt="ImageBase + AddressOfEntryPoint"></p>
<p>如图所示，AddressOfEntryPoint 为 0000739D，ImageBase 为 01000000，则 EIP 的值（也就是 EP）为：0100739D；</p>
<blockquote>
<p>勘误：<code>#### NT 头：可选头 IMAGE_OPTIONAL_HEADER</code> 开始位置，图中的签名（IMAGE_NT_SIGNATURE）结构体标注错了，有发现的小伙伴吗？</p>
</blockquote>
</li>
</ul>
</li>
<li><p>SetionAlignment / FileAlignment</p>
<p>PE 体，也就是 PE 的 Body 部分划分为若干个节区，这些节区存储着不同类别的数据；</p>
<p>SetionAlignment 双字，指定了节区在内存中的最小单位，每个节区被载入的地址必定是此字段指定数值的整数倍；</p>
<p>SetionAlignment 默认的对齐尺寸是目标 CPU 的页尺寸，对于 32 位操作系统来说，这个值是 4KB（16 进制表示为 1000），对于 64 位操作系统来说，这个值是 8KB（16 进制表示为 2000）；</p>
<p>FileAlignment 双字，指定了节区在磁盘文件中的最小单位，组成块的原始数据必须保证从本字段的倍数地址开始；</p>
<p>通常情况下，Windows 会选择使用 512 字节（最大为 4KB）的簇大小（一个物理扇区的大小）来格式化分区，用 16 进制表示为 200，这就是常见的代码段、数据段等起始地址是 200 的倍数的原因；</p>
<p>SetionAlignment 必须大于或等于 FileAlignment，如果 SetionAlignment 被定义为小于操作系统页的大小，则 SetionAlignment 和 FileAlignment 的值必须相等；</p>
</li>
<li><p>SizeOfImage：双字，加载 PE 文件到内存时，SizeOfImage 指定了 PE 映像在虚拟内存中所占空间的大小；</p>
<p>映像载入内存后的总尺寸，是指载入文件从 ImageBase 到最后一个块的大小，最后一个块根据其大小向上取整；</p>
<p>一般而言，文件的大小与加载到内存中的大小是不同的（节区头中定义了各节装载的位置与占有内存的大小），SizeOfImage 可以比实际的值大，但不能比它小，且 SizeOfImage 必须是 SetionAlignment 的整数倍；</p>
</li>
<li><p>SizeOfHeaders：双字，用来指出整个 PE 头的大小，该值必需是 FileAlignment 的整数倍；</p>
<p>MS-DOS 头部、PE 文件头、节表的总尺寸，是按照文件对齐粒度对齐后的大小（含补足的 0）；</p>
<p>第 1 节区所在位置与 SizeOfHeaders 距文件开始偏移的量相同；</p>
</li>
<li><p>Subsystem：单字，用来区分系统驱动文件（*.sys）与普通的可执行文件（*.exe，*.dll）；</p>
<p>一个标明可执行文件所期望的子系统（用户界面类型）的枚举值，这个值只对 EXE 重要；</p>
<p>成员值如下：</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">常量符号</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">IMAGE_SUBSYSTEM_UNKNOWN</td>
<td align="center">未知的子系统</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">IMAGE_SUBSYSTEM_NATIVE</td>
<td align="center">设备驱动和 Native Windows 进程</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">IMAGE_SUBSYSTEM_WINDOWS_GUI</td>
<td align="center">图形接口子系统，Windows 图形用户界面</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">IMAGE_SUBSYSTEM_WINDOWS_CUI</td>
<td align="center">字符子系统，Windows 字符模式（控制台）</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">IMAGE_SUBSYSTEM_POSIX_CUI</td>
<td align="center">POSIX 字符子系统 （控制台）</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">IMAGE_SUBSYSTEM_WINDOWS_CE_GUI</td>
<td align="center">Windows CE 图形界面</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">IMAGE_SUBSYSTEM_EFI_APPLICATION</td>
<td align="center">可扩展固件接口（EFI）应用程序</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER</td>
<td align="center">带引导服务的 EFI 驱动程序</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER</td>
<td align="center">带运行时服务的 EFI 驱动程序</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">IMAGE_SUBSYSTEM_EFI_ROM</td>
<td align="center">EFI ROM 映像</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">IMAGE_SUBSYSTEM_XBOX</td>
<td align="center">XBOX</td>
</tr>
</tbody></table>
</li>
<li><p>NumberOfRvaAndSizes：双字，用来指定 DataDirectory 数组的个数；</p>
<p>数据目录表（DataDirectory）的项数，这个字段的值从 Windows NT 发布以来一直是 16（10），实际应用中可以取 2 ～ 16 的值；</p>
<p>PE 装载器通过查看 NumberOfRvaAndSizes 的值来识别数组大小；</p>
</li>
<li><p>DataDirectory：是由 IMAGE_DATA_DIRECTORY 结构体组成的数组，数组的每项都有被定义的值，指向输出表、输入表、资源块等数据；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrfz6q5lqj316w0u0mzs.jpg" alt="DataDirectory"></p>
<p>数据目录表的每个成员占 8 个字节，分别指向相关的结构体，前 4 个字节表示地址，后 4 个字节表示大小，最后一个成员必须为 0；</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">成员</th>
<th align="left">结构</th>
<th align="center">偏移量（PE / PE32+）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="left">Export Table ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_EXPORT</td>
<td align="center">78 / 88</td>
<td align="center">导出表</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">Import Table ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_IMPORT</td>
<td align="center">80 / 90</td>
<td align="center">导入表</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">Resources Table ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_RESOURCE</td>
<td align="center">88 / 98</td>
<td align="center">资源表</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">Exception Table</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_EXCEPTION</td>
<td align="center">90 / A0</td>
<td align="center">异常表</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">Security Table</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_SECURITY</td>
<td align="center">98 / A8</td>
<td align="center">属性证书表</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">Base relocation Table</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_BASERELOC</td>
<td align="center">A0 / B0</td>
<td align="center">基地址重定位表</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">Debug</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_DEBUG</td>
<td align="center">A8 / B8</td>
<td align="center">调试信息表</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">Copyright</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_COPYRIGHT</td>
<td align="center">B0 / C0</td>
<td align="center">版权表</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">Global Ptr</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td>
<td align="center">B8 / C8</td>
<td align="center">全局指针表</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">Thread local storage (TLS) ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_TLS</td>
<td align="center">C0 / D0</td>
<td align="center">线程本地存储</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">Load configuration</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td>
<td align="center">C8 / D8</td>
<td align="center">加载配置表</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">Bound Import</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td>
<td align="center">D0 / E0</td>
<td align="center">绑定导入表</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">Import Address Table (IAT) ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_IAT</td>
<td align="center">D8 / E8</td>
<td align="center">导入函数地址表</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">Delay Import</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td>
<td align="center">E0 / F0</td>
<td align="center">延迟导入表</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">COM descriptor</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td>
<td align="center">E8 / F8</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">保留，必须为 0</td>
<td align="left"></td>
<td align="center">F0 / 100</td>
<td align="center">系统保留</td>
</tr>
</tbody></table>
<p>PE 文件在定位输出表、输入表和资源表等重要数据时，就是从 IMAGE_DATA_DIRECTORY 结构体开始的；</p>
</li>
</ol>
<h4 id="节区头-IMAGE-SECTION-HEADER-结构体数组"><a href="#节区头-IMAGE-SECTION-HEADER-结构体数组" class="headerlink" title="节区头 IMAGE_SECTION_HEADER 结构体数组"></a>节区头 IMAGE_SECTION_HEADER 结构体数组</h4><p>PE 文件中的 code（代码）、data（数据）、resource（资源）等按照属性分类存储在不同节区；</p>
<p>节区头中定义了各节区属性；</p>
<p>节区属性中有文件/内存的起始位置、大小、访问权限等；</p>
<p>不同内存属性的访问权限：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">访问权限</th>
</tr>
</thead>
<tbody><tr>
<td align="center">code</td>
<td align="center">执行，读取权限</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">非执行，读写权限</td>
</tr>
<tr>
<td align="center">resource</td>
<td align="center">非执行，读取权限</td>
</tr>
</tbody></table>
<p>节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组，每个结构体对应一个节区，每个结构体包含它所关联区块的信息，如位置、长度、属性等，该数组的数目由 IMAGE_NT_HEADERS.IMAGE_FILE_HEADER.NumberOfSections 指出；</p>
<p>IMAGE_SECTION_HEADER 结构体中的重要成员：偏移量基于节区头（当前 IMAGE_SECTION_HEADER 结构体）</p>
<table>
<thead>
<tr>
<th align="center">偏移量</th>
<th align="center">项目</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8</td>
<td align="center">VirtualSize</td>
<td align="center">内存中节区所占大小</td>
</tr>
<tr>
<td align="center">0C</td>
<td align="center">VirtualAddress</td>
<td align="center">内存中节区起始位置（RVA）</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">SizeOfRawData</td>
<td align="center">磁盘文件中节区所占大小</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">PointerToRawData</td>
<td align="center">磁盘文件中节区起始位置</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">Characteristics</td>
<td align="center">节区属性（bit OR）</td>
</tr>
</tbody></table>
<ol>
<li><p>VirtualSize：双字，指出实际被使用的区块的大小，是在进行对齐处理前区块的实际大小；</p>
</li>
<li><p>VirtualAddress：双字，该块装载到内存中的 RVA，这个地址是按照内存页对齐的，它的数值总是 SectionAlignment 的整数倍；</p>
</li>
<li><p>SizeOfRawData：双字，该块在磁盘中所占的空间，在可执行文件中，该字段包含经 FileAlignment 调整的块的大小；</p>
</li>
<li><p>PointerToRawData：双字，该块在磁盘文件中的偏移，程序经编译或汇编后生成原始数据，这个字段用于给出原始数据在文件中的偏移；</p>
<p>如果程序装载自 PE 或 COFF 文件（而不是由操作系统载入的），这一字段将比 VirtualAddress 还重要，在这种情况下，必须完全使用线性映像的方法载入文件，所以需要在该偏移处找到块的数据，而不是 VirtualAddress 字段中的 RVA 地址；</p>
</li>
<li><p>Characteristics：双字，块属性，该字段是一组指出块属性的标志，多个标志值求或即为 Characteristics 的值；</p>
<p>Characteristics 的值由下列值组合而成：</p>
<table>
<thead>
<tr>
<th align="center">定义</th>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IMAGE_SCN_CNT_CODE</td>
<td align="center">00000020</td>
<td align="center">包含代码，常与 10000000 一起设置</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_CNT_INITIALIZED_DATA</td>
<td align="center">00000040</td>
<td align="center">该块包含已初始化的数据</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_CNT_UNINITIALIZED_DATA</td>
<td align="center">00000080</td>
<td align="center">该块包含未初始化的数据</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_DISCARDABLE</td>
<td align="center">02000000</td>
<td align="center">该块可被丢弃，因为它一旦被载入，进程就不再需要它了 <br/> 常见的可丢弃块是 .reloc（重定位块）</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_SHARED</td>
<td align="center">10000000</td>
<td align="center">该块为共享块</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_EXECUTE</td>
<td align="center">20000000</td>
<td align="center">该块可执行，通常当 00000020 标志被设置时，该标志也被设置</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_READ</td>
<td align="center">40000000</td>
<td align="center">该块可读，可执行文件中的块总是设置该标志</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_WRITE</td>
<td align="center">80000000</td>
<td align="center">该块可写，如果 PE 文件中没有设置该标志，装载程序就会将内存映像页标记为可读或可执行</td>
</tr>
</tbody></table>
</li>
</ol>
<p>VirtualAddress 与 PointerToRawData 不带有任何值，分别由定义在 IMAGE_OPTIONAL_HEADER32 中的 SectionAlignment 与 FileAlignment 确定；</p>
<p>VirtualSize 与 SizeOfRawData 一般具有不同的大小，即磁盘文件中节区的大小与加载到内存中的节区的大小是不同的；</p>
<p>如果 VirtualSize 的值大于 SizeOfRawData 的值，那么 SizeOfRawData 表示来自可执行文件初始化数据的大小，与 VirtualSize 相差的字节用 0 填充；</p>
<p>最后，PE 规范未明确规定节区的 Name，所以可以向其中放入任何值，甚至可以填充 NULL 值，因此，节区的 Name 字段仅供参考，不能保证其百分百的用作某种信息（节区的名称）；</p>
<h3 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h3><p>PE 文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的映射，这种映射一般称为 RVA to RAW；</p>
<p>方法如下：</p>
<ol>
<li><p>查找 RVA 所在节区；</p>
</li>
<li><p>使用简单的公式计算文件偏移（RAW）</p>
<p>根据 IMAGE_SECTION_HEADER 结构体，换算公式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RAW - PointerToRawData = RVA - VirtualAddress</span><br><span class="line">                  RAW = RVA - VirtualAddress + PointerToRawData</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IAT（Import-Address-Table，导入地址表）"><a href="#IAT（Import-Address-Table，导入地址表）" class="headerlink" title="IAT（Import Address Table，导入地址表）"></a>IAT（Import Address Table，导入地址表）</h3><p>在 PE 文件内有一组数据结构，它们分别对应于被输入的 DLL，每一个这样的结构体都给出了被输入的 DLL 的名称并指向一组函数指针，这组函数指针称为输入地址表（IAT）；</p>
<p>每一个被引入的 API 在 IAT 里都有保留的位置，在那里它将被 Windows 加载器写入输入函数的地址，也就是调用位置；</p>
<p>一旦模块被载入，IAT 中将包含所要输入函数的地址；</p>
<p>把所有输入函数放在 IAT 中，这样，无论代码中多用一个输入函数多少次，都会通过 IAT 中的同一个函数指针来完成；</p>
<h4 id="DLL（Dynamic-Link-Library，动态链接库）"><a href="#DLL（Dynamic-Link-Library，动态链接库）" class="headerlink" title="DLL（Dynamic Link Library，动态链接库）"></a>DLL（Dynamic Link Library，动态链接库）</h4><p>16 位的 DOS 时代不存在 DLL 这一概念，只有“库”一说，比如在 C 语言中使用 printf() 函数时，编译器会从 C 语言库中读取相应函数的二进制代码，然后插入应用程序的源代码中，也就是说，可执行文件中包含着 printf() 函数的二进制代码；</p>
<p>Windows 系统支持多任务，如果同时运行多个程序，而每个程序包含相同的库，将造成严重的内存浪费和磁盘浪费，因此，Windows 引入了 DLL 这一概念，描述如下：</p>
<ol>
<li>不要把库包含到程序中，单独组成 DLL 文件，需要时调用即可；</li>
<li>内存映射技术使加载后的 DLL 代码、资源在多个进程中实现共享；</li>
<li>更新库时，只要替换相关的 DLL 文件即可，简单易行；</li>
</ol>
<p>加载 DLL 的方式有两种：</p>
<ol>
<li>“显式链接”（Explicit Linking），程序使用 DLL 时加载，使用完毕后释放内存，必须确定目标 DLL 已经被加载，然后才寻找 API 的地址，这几乎总是通过调用 LoadLibrary 和 GetProcAddress 完成的；</li>
<li>“隐式链接”（Implicit Linking），程序开始时即同时加载 DLL，程序终止时再释放占用的内存，Windows 加载器保证 PE 文件所需的任何附加的 DLL 都被载入，调用 LoadLibrary 和 GetProcAddress 的过程由 Windows 加载器完成；</li>
</ol>
<p>IAT 提供的机制与隐式链接有关；</p>
<p>大多程序在调用 API 时，都并非直接调用，而是通过获取指定地址处的值来实现调用，为什么不直接调用呢？</p>
<p>这是由于，程序的制作者编译程序时，无法确定程序的运行环境（XP、Vista、7、10）、语言（ENG、CHS、JPN、KOR）、服务包（Service Pack），不同环境中，使用的 DLL 版本各不相同，指定的 API 的实际位置也会不同；</p>
<p>为了确保能在所有环境中都能正常调用 API，编译器准备并记录要保存 API 的实际地址，执行文件时，PE 装载器会将 API 的地址写入到这个实际地址；</p>
<p>编译器不使用直接指令调用 API 的另一个原因在于 DLL 重定向。</p>
<p>DLL 文件的 ImageBase 值一般为 10000000，比如程序使用了 a.dll 和 b.dll，PE 装载器先将 a.dll 装载到内存的 10000000 处，然后尝试将 b.dll 也装载到该处，但由于该地址已经装载了 a.dll，所以，PE 装载器会查找其它空白的内存空间，然后将 b.dll 装载进去，这就是 DLL 重定向，这就使得无法对实际地址进行硬编码；</p>
<p>还有一个原因在于：PE 头中表示地址时使用 RVA，而不是 VA；</p>
<p>实际操作中，无法保证 DLL 一定会被加载到 PE 头指定的 ImageBase 处，但是 EXE 文件（生成进程的主体）却能准确的加载到自身的 ImageBase 中，这是因为它拥有自己的虚拟空间；</p>
<h4 id="输入函数的调用"><a href="#输入函数的调用" class="headerlink" title="输入函数的调用"></a>输入函数的调用</h4><p>输入函数就是被程序调用但其执行代码不在程序中的函数，这些函数的代码位于相关的 DLL 中，在调用程序中只保留相关的函数信息，如函数名、DLL 文件名等；</p>
<p>对磁盘上的 PE 文件来说，它无法得知这些输入函数在内存中的地址；</p>
<p>只有当 PE 文件载入内存后，Windows 加载器才会将相关 DLL 载入，并将调用输入函数的指令和函数实际所处的地址联系起来；</p>
<p>当应用程序调用一个 DLL 的代码和数据时，它正在被隐式链接到 DLL，这个过程完全由 Windows 加载器完成；</p>
<h4 id="IMAGE-IMPORT-DESCRIPTOR-导入表描述符"><a href="#IMAGE-IMPORT-DESCRIPTOR-导入表描述符" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR 导入表描述符"></a>IMAGE_IMPORT_DESCRIPTOR 导入表描述符</h4><p>IMAGE_IMPORT_DESCRIPTOR 结构体中记录着 PE 文件要倒入哪些库文件；</p>
<p>可执行文件使用来自其它 DLL 的代码或数据的动作称为输入（import）；</p>
<p>当 PE 文件被载入时，Windows 加载器的工作之一就是定位所有被输入的函数和数据，并让正在载入的文件可以使用这些地址，这个过程是通过 PE 文件的输入表（Import Table，简称“IT”，也称导入表）完成的；</p>
<p>输入表中保存的是函数名和其驻留的 DLL 名等动态链接库所需的信息；</p>
<p>在 PE 文件头的可选映像头中，数据目录表的第 2 个成员指向输入表，即 IMAGE_NT_HEADERS.IMAGE_OPTIONAL_HEADER.DataDirectory[1]，也就是 IMAGE_DIRECTORY_ENTRY_IMPORT；</p>
<p>输入表（数组）以 IMAGE_IMPORT_DESCRIPTOR（IID） 结构体开始，每个被 PE 文件隐式链接的 DLL 都有一个 IID，这个数组中，没有字段指出该结构体数组的项数，但它的最后一个单元是 NULL，由此可以计算出该数组的项数；</p>
<p>执行一个普通程序时，往往需要导入多个库，导入多少个库就存在多少个 IMAGE_IMPORT_DESCRIPTOR 结构体，这些结构体形成了数组，且结构体数组最后以 NULL 结构体结尾；</p>
<p>IMAGE_IMPORT_DESCRIPTOR 结构体的成员：</p>
<table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OriginalFirstThunk（Characteristics）⚠️</td>
<td align="center">INT 的地址（RVA）</td>
</tr>
<tr>
<td align="center">TimeDateStamp</td>
<td align="center">一个 32 位的时间标志，可忽略</td>
</tr>
<tr>
<td align="center">ForwarderChain</td>
<td align="center">第 1 个被转向的 API 的索引，一般为 0</td>
</tr>
<tr>
<td align="center">Name ⚠️</td>
<td align="center">库名称字符串的地址（RVA）</td>
</tr>
<tr>
<td align="center">FirstThunk ⚠️</td>
<td align="center">IAT 的地址（RVA）</td>
</tr>
</tbody></table>
<blockquote>
<p>INT：输入名称表（Import Name Table）；</p>
<p>IAT：输入地址表（Import Address Table）；</p>
</blockquote>
<ol>
<li>OriginalFirstThunk（INT）：双字，包含指向输入名称表（INT）的 RVA；<br>INT 是一个包含导入函数信息（Ordinal，Name）的结构体指针数组，只有获得了这些信息，才能在加载到进程内存的库中准确求得相应函数的起始地址；<br>INT 是一个 IMAGE_THUNK_DATA 结构的数组，数组中的每个 IMAGE_THUNK_DATA 结构都指向 IMAGE_IMPORT_BY_NAME 结构，数组尾部以 NULL 结束，即数组以一个内容为 0 的 IMAGE_THUNK_DATA 结构体结束；</li>
<li>TimeDateStamp：双字，一个 32 位的时间标志，可忽略；</li>
<li>ForwarderChain：双字，这是第 1 个被转向的 API 的索引，一般为 0，在程序中引用一个 DLL 中的 API，而这个 API 又在引用其它 DLL 的 API 时使用；</li>
<li>Name：双字，DLL 名字的指针，是一个以 “00” 结尾的 ASCII 字符的 RVA 地址，该字符包含输入 DLL 的名称；<br>Name 是一个字符串指针，它指向导入函数所属的库文件的名称；</li>
<li>FirstThunk（IAT）：双字，包含指向输入地址表（IAT）的 RVA；</li>
</ol>
<p>OriginalFirstThunk 与 FirstThunk 相似，它们分别指向两个本质上相同的数组 IMAGE_THUNK_DATA 结构；</p>
<p>两个数组中都有 IMAGE_THUNK_DATA 结构类型的元素，它是一个指针大小的联合（union）；</p>
<p>每个 IMAGE_THUNK_DATA 元素对应与一个从可执行文件输入的函数；</p>
<p>两个数组的结束都是由一个值为 0 的 IMAGE_THUNK_DATA 元素表示；</p>
<p>IMAGE_THUNK_DATA 结构实际上是一个双字，该结构在不同时刻有不同的含义，定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IMAGE_THUNK_DATA STRUCT</span><br><span class="line">    union ul</span><br><span class="line">        ForwarderString     DWORD   ?       ; 指向一个转向者字符串的 RVA</span><br><span class="line">        Function            DWORD   ?       ; 被输入的函数的内存地址</span><br><span class="line">        Ordinal             DWORD   ?       ; 被输入的 API 的序数值</span><br><span class="line">        AddressOfData       DWORD   ?       ; 指向 IMAGE_IMPORT_BY_NAME</span><br><span class="line">    ends</span><br><span class="line">IMAGE_THUNK_DATA ENDS</span><br></pre></td></tr></table></figure>

<p>当 IMAGE_THUNK_DATA 值的最高位（双字的最高位）为 1 时，表示函数以序号方式输入，这时低 31 位（或者 64 位可执行文件的低 63 位）被看成一个函数序号；</p>
<p>当 IMAGE_THUNK_DATA 值的最高位（双字的最高位）为 0 时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个 RVA，指向一个 IMAGE_IMPORT_BY_NAME 结构；</p>
<p>IMAGE_IMPORT_BY_NAME 结构仅有 1 个字大小，存储了一个输入函数的相关信息，定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IMAGE_IMPORT_BY_NAME STRUCT</span><br><span class="line">    Hint     WORD   ?      ; 函数编号</span><br><span class="line">    Name     BYTE   ?      ; 表示函数名称的字符串</span><br><span class="line">IMAGE_IMPORT_BY_NAME ENDS</span><br></pre></td></tr></table></figure>

<ol>
<li>Hint：本函数在其所驻留 DLL 的输入表中的序号，该域被 PE 装载器用来在 DLL 的输出表里快速查询函数；<br>该值不是必需的，一些链接器将它设为 0；</li>
<li>Name：含有输入函数的函数名，函数名是一个 ASCII 字符串，以 NULL 结尾；<br>这里虽然将 Name 的大小以字节为单位进行定义，但其实它是一个可变尺寸域，由于没有更好的表示方式，只好在定义中写成 BYTE；</li>
</ol>
<p>PE 装载器把导入函数输入至 IAT 的顺序：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 读取 IID 的 Name 成员，获取库名称字符串；</span><br><span class="line">2. 装载相应库：LoadLibrary(&quot;库名称.dll&quot;)</span><br><span class="line">3. 读取 IID 的 OriginalFirstThunk 成员，获取 INT 地址；</span><br><span class="line">4. 逐一读取 INT 数组中的值，获取相应的 IMAGE_IMPORT_BY_NAME（RVA）；</span><br><span class="line">5. 使用 IMAGE_IMPORT_BY_NAME 的 Hint 项或 Name 项，获取相应函数的起始位置；</span><br><span class="line">6. 读取 IID 的 FirstThunk 成员，获得 IAT 地址；</span><br><span class="line">7. 将上面获得的函数地址输入相应 IAT 数组中；</span><br><span class="line">8. 重复以上步骤 4～7，直到 INT 表结束（遇到 NULL）；</span><br></pre></td></tr></table></figure>

<h4 id="以-NOTEPAD-EXE-为例，梳理思路，强化学习"><a href="#以-NOTEPAD-EXE-为例，梳理思路，强化学习" class="headerlink" title="以 NOTEPAD.EXE 为例，梳理思路，强化学习"></a>以 NOTEPAD.EXE 为例，梳理思路，强化学习</h4><ol>
<li><p>在 PE 文件头的可选映像头中，数据目录表的第 2 个成员指向输入表；</p>
</li>
<li><p>数据目录表是 IMAGE_DIRECTORY_ENTRY_IMPORT，位于 IMAGE_OPTIONAL_HEADER32.DataDirectory[1]；</p>
</li>
<li><p>而 IMAGE_OPTIONAL_HEADER32 位于 IMAGE_NT_HEADERS，也就是 PE 头；</p>
</li>
<li><p>使用 WinHex 打开 NOTEPAD.EXE，找到 PE 头的偏移位置（位于从文件开始偏移 3C 字节处）；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsqzcsjsnj316r0u041k.jpg" alt="PE头的偏移位置"></p>
</li>
<li><p>找到 PE 头后，IMAGE_OPTIONAL_HEADER32 是其的第 3 个成员，所以，直接定位到第 3 个成员，然后找到 DataDirectory：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsrf4o9j1j316q0u0dih.jpg" alt="IMAGE_DIRECTORY_ENTRY_IMPORT"></p>
<p>绿色是 IMAGE_NT_SIGNATURE；</p>
<p>黄色是 IMAGE_FILE_HEADER；</p>
<p>蓝色是 IMAGE_OPTIONAL_HEADER32 的其它成员，从 158 位置开始，是 DataDirectory 数组成员，也就是数据目录表成员，最后的红色则表示 DataDirectory[1]；</p>
<p>数据目录表的每个成员占 8 个字节，分别指向相关的结构体，前 4 个字节表示地址，后 4 个字节表示大小；</p>
<p>所以在这里，IMAGE_DIRECTORY_ENTRY_IMPORT 的相对虚拟地址是<code>7604</code>;</p>
</li>
<li><p>由于得到的地址是 RVA，所以还需要转换为 RAW，先来看看 RAW 的计算公式：RAW = RVA - VirtualAddress + PointerToRawData，这其中的 RVA 是已知的，也就是 <code>7604</code>，而 VirtualAddress 和 PointerToRawData 如何得知呢？</p>
<p>VirtualAddress 和 PointerToRawData 位于 IMAGE_SECTION_HEADER 结构体；</p>
<p>IMAGE_SECTION_HEADER 结构体在 PE 头的下方，所以 DataDirectory 数组之后就是 IMAGE_SECTION_HEADER 结构体，也就是 节区表（区块表）；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsypkauskj316x0u0wgw.jpg" alt="节区表（区块表）"></p>
<p>图中选中部分是 DataDirectory 数组；</p>
<p>红色是第 1 个节区的部分参数，第 3 个参数说明，此节区（.text）在内存中的起始位置（VirtualAddress）是 00001000，第 5 个参数说明，此节区在磁盘文件中的偏移（PointerToRawData）是 00000400；</p>
<p>绿色是第 2 个节区的部分参数，第 3 个参数说明，此节区（.data）在内存中的起始位置（VirtualAddress）是 00009000，这里为什么要看第 2 节区的 VirtualAddress 呢？因为确定了第 2 节区的起始位置，也就确定了第 1 节区的结束位置，也就是范围，很显然，1000 &lt; 7604 &lt; 9000，位于第 1 节区（.text）；</p>
<p>根据公式计算，第 1 节区的 RAW = 7604 - 1000 + 400，结果是<code>6A04</code>；</p>
</li>
<li><p>既然已知第 1 节区的 RAW，按下<code>ALT + G</code>或者菜单栏选择<code>位置 &gt;&gt; 转到偏移位置</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsz701irwj316u0u0tbj.jpg" alt="第 1 节区的 RAW"></p>
<p>图中所示就是第 1 节区 IID，共有 5 个成员，分别来看一下：</p>
<ul>
<li><p>第 1 个成员是 OriginalFirstThunk：INT 的地址（RVA）；根据计算，其 RAW 是<code>6D90</code>；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnszcrj5gij316x0u00vr.jpg" alt="OriginalFirstThunk"></p>
<p>跳转到<code>6D90</code>可以看到输入名称表数组，最后一个单元为 NULL，跟随第 1 个成员，查看其名称，RVA：7A7A -&gt; RAW：6E7A</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsznj6kkfj316m0u041z.jpg" alt="跟随第 1 个成员"></p>
<p>初始的 2 个字节为 Ordinal，是库中函数的固有编号，Ordinal 后面是导入函数的名称字符串<code>PageSetupDlgW</code>（末尾以 Terminating NULL[‘\0’]结尾）；</p>
</li>
<li><p>第 2 个成员是 TimeDateStamp，由于这里的值为 0，故忽略；</p>
</li>
<li><p>第 3 个成员是 ForwarderChain，其值也为 0，忽略；</p>
</li>
<li><p>第 4 个成员是 Name：DLL 名字的指针；RVA：7AAC -&gt; RAW：6EAC；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnt02pzailj316s0u0n09.jpg" alt="DLL 名字的指针"></p>
<p>可以看到，包含<code>PageSetupDlgW</code>的库文件是<code>comdlg32.dll</code>；</p>
</li>
<li><p>第 5 个成员是 FirstThunk（IAT）：包含指向输入地址表（IAT）的 RVA；RVA：12C4 -&gt; RAW：6C4；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnt0aevkwrj316s0u0dim.jpg" alt="FirstThunk（IAT）"></p>
<p>选中区域即为 IAT 数组区域，对应于 cmdlg32.dll 库，与 INT 类似，由结构体指针组成，且以 NULL 结尾；</p>
</li>
</ul>
</li>
</ol>
<h3 id="EAT（Export-Address-Table，导出地址表）"><a href="#EAT（Export-Address-Table，导出地址表）" class="headerlink" title="EAT（Export Address Table，导出地址表）"></a>EAT（Export Address Table，导出地址表）</h3><p>在 Windows 系统中，“库”是为了方便其它程序调用而集中包含相关函数的文件（DLL / SYS）；</p>
<p>创建 DLL 时，实际上创建了一组能让 EXE 或其它 DLL 调用的函数；</p>
<p>程序运行时， PE 装载器会根据 DLL 文件中输出的信息修正被执行文件的 IAT；</p>
<p>当一个 DLL 函数能够被 EXE 或其它 DLL 文件使用时，它就被“输出了（Exported）”；</p>
<p>输出信息被保存在输出表中，DLL 文件通过输出表向系统提供输出函数名、序号和入口地址等信息；</p>
<p>EAT 是一种核心机制，它使不同的应用程序可以调用库文件中提供的函数，也就是说，只有通过 EAT 才能准确获得从相应库中导出函数的起始地址；</p>
<h4 id="IMAGE-EXPORT-DESCRIPTOR"><a href="#IMAGE-EXPORT-DESCRIPTOR" class="headerlink" title="IMAGE_EXPORT_DESCRIPTOR"></a>IMAGE_EXPORT_DESCRIPTOR</h4><p>与 IAT 一样，PE 文件内特定结构体（IMAGE_EXPORT_DESCRIPTOR）保存着导出信息，且 PE 文件中仅有一个用来说明库 EAT 的 IMAGE_EXPORT_DESCRIPTOR 结构体；</p>
<p>输出表的主要内容是一个表格，其中包括函数名称、输出序数等，序数是指 DLL 中某个函数的 16 位数字，在所指向的 DLL 中是独一无二的；<br>输出表是数据目录表的第 1 个成员，指向 IMAGE_EXPORT_DESCRIPTOR（简称 IED）结构；</p>
<p>IMAGE_EXPORT_DESCRIPTOR 结构体的重要成员：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">Size</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Name</td>
<td align="center">DWORD</td>
<td align="center">模块（DLL）的真实名称</td>
</tr>
<tr>
<td align="center">NumberOfFunctions ⚠️</td>
<td align="center">DWORD</td>
<td align="center">实际 Export 函数的个数</td>
</tr>
<tr>
<td align="center">NumberOfNames ⚠️</td>
<td align="center">DWORD</td>
<td align="center">Export 函数中具名函数的个数（ENT）</td>
</tr>
<tr>
<td align="center">AddressOfFunctions ⚠️</td>
<td align="center">DWORD</td>
<td align="center">Export 函数地址数组（数组元素个数 = NumberOfFunction）</td>
</tr>
<tr>
<td align="center">AddressOfNames ⚠️</td>
<td align="center">DWORD</td>
<td align="center">函数名称地址数组（数组元素个数 = NumberOfNames）</td>
</tr>
<tr>
<td align="center">AddressOfNameOrdinals ⚠️</td>
<td align="center">DWORD</td>
<td align="center">序号地址数组（数组元素个数 = NumberOfNames）</td>
</tr>
</tbody></table>
<blockquote>
<p>ENT：输出函数名称表（Export Name Table）；</p>
<p>EAT：输出地址表（Export Address Table）；</p>
</blockquote>
<ol>
<li>Name：指向一个 ASCII 字符串的 RVA，这个字符串是与输出函数相关联的 DLL 的名字；</li>
<li>NumberOfFunctions： EAT 中的条目数量，0 表示没有代码或数据被输出；</li>
<li>NumberOfNames：输出函数名称表（Export Name Table，ENT），NumberOfNames 的值总是小于或等于 NumberOfFunctions 的值；</li>
<li>AddressOfFunctions：EAT 的 RVA，EAT 是一个 RVA 数组，数组中的每一个非零 RVA 都对应于一个被输出的序号；</li>
<li>AddressOfNames：ENT 的 RVA，ENT 是一个指向 ASCII 字符串的 RVA 数组，每一个 ASCII 字符串对应于一个通过名字输出的序号；</li>
<li>AddressOfNameOrdinals：输出序数表的 RVA，这个表是字（WORD）的数组，这个表将 ENT 中的数组索引映射到相应的输出地址表条目；</li>
</ol>
<p>设计输出表是为了方便 PE 装载器工作；</p>
<p>模块必须保存所有输出函数的地址，供 PE 装载器查询；</p>
<p>模块将这些信息保存在 AddressOfFunctions 域指向的数组中，而数组元素的数量存放在 NumberOfFunctions 域中；</p>
<p>如果有些函数是通过名字引出的，这些名字的 RVA 值会存放在 AddressOfNames 域指向的数组中，数组元素的数量存放在 NumberOfNames 域中，以供 PE 装载器查询；</p>
<p>AddressOfNames 域指向的数组中仅包含函数名，并不包含函数的地址；</p>
<p>AddressOfNameOrdinals 域指向的数组中包含（AddressOfNames 数组中）函数名对应的（在 AddressOfFunctions 数组中的）索引，所以，序数表和名称表的元素数量相同；</p>
<p>PE 装载器会通过 AddressOfNameOrdinals 域指向的数组获取 AddressOfNames 域指向的数组中的函数名在 AddressOfFunctions 域指向的数组中对应的索引，从而获取函数地址；</p>
<h4 id="以-KERNEL32-DLL-为例，梳理思路，强化学习"><a href="#以-KERNEL32-DLL-为例，梳理思路，强化学习" class="headerlink" title="以 KERNEL32.DLL 为例，梳理思路，强化学习"></a>以 KERNEL32.DLL 为例，梳理思路，强化学习</h4><ol>
<li><p>使用 WinHex 打开 KERNEL32.DLL，找到 IMAGE_EXPORT_DESCRIPTOR，位于 IMAGE_OPTIONAL_HEADER32.DataDirectory[0]；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntuzfk614j316s0u0q5d.jpg" alt="IMAGE_EXPORT_DESCRIPTOR"></p>
<p>可以看到，IMAGE_EXPORT_DESCRIPTOR 的 RVA 为<code>262C</code>，则 RAW 为<code>1A2C</code>;</p>
</li>
<li><p>跳转到<code>1A2C</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntv12k5gvj316i0u0773.jpg" alt="`1A2C`"></p>
<p>选中部分为 IMAGE_EXPORT_DESCRIPTOR 所有成员，红色部分依次是 Name、AddressOfFunctions、AddressOfNames 以及 AddressOfNameOrdinals；</p>
</li>
<li><p>首先，查看 Name，RVA：4B98 -&gt; RAW：3F98：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntv5oue9xj316t0u0diu.jpg" alt="3F98"></p>
<p>可以看到，库名称为<code>KERNEL32.dll</code>（以’\0’结尾）；</p>
</li>
<li><p>返回<code>1A2C</code>，然后查看 AddressOfFunctions，RVA：2654 -&gt; RAW：1A54：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvbhgjx1j316q0u0n00.jpg" alt="1A54"></p>
<p>可以看到，第 1 个输出函数的 RAV 为：A6E4；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvei6fjpj316q0u0acp.jpg" alt="ImageBase"></p>
<p>KERNEL32.DLL 的 ImageBase 为：7C800000，故第 1 个输出函数的实际地址（VA）为：7C800000 + A6E4 = 7C80A6E4；</p>
<p>使用<code>OD</code>打开 KERNEL32.DLL：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvlbcvxfj31b40u0tbx.jpg" alt="使用`OD`打开 KERNEL32.DLL"></p>
<p>发现 7C80A6E4 对应的函数名为<code>ActivateActCtx</code>；</p>
</li>
<li><p>返回<code>1A2C</code>，接着查看 AddressOfNames，RVA：353C -&gt; RAW：293C：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvp6hfftj316j0u00vk.jpg" alt="293C"></p>
<p>指向函数名字符串的指针是：4BA5，则 RAW 为：3FA5：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvr1cbzqj316s0u041i.jpg" alt="3FA5"></p>
<p>对应的函数名为<code>ActivateActCtx</code>，与查看 AddressOfFunctions 时获取的函数名一致；</p>
</li>
<li><p>返回<code>1A2C</code>，最后来看 AddressOfNameOrdinals，RVA：4424 -&gt; RAW：3824：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvuyl8g5j316x0u0acs.jpg" alt="3824"></p>
<p>对应的索引值为 0，没问题；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>文章资料</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
</search>
