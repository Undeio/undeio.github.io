<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 添加 Utterance 评论功能</title>
    <url>/post/3357819964/</url>
    <content><![CDATA[<blockquote>
<p>每逢看到大佬们的精彩文章，感慨甚多之际，不能留言把欢甚是遗憾。<br>缺少了留言支持、请教解惑、互相探讨，总感觉博客没有灵魂。</p>
</blockquote>
<hr>
<h4 id="最新版本Next主题已集成Utterance，So，此方法已弃用-❕❕❕"><a href="#最新版本Next主题已集成Utterance，So，此方法已弃用-❕❕❕" class="headerlink" title="最新版本Next主题已集成Utterance，So，此方法已弃用 ❕❕❕"></a>最新版本<code>Next</code>主题已集成<code>Utterance</code>，So，此方法已弃用 ❕❕❕</h4><hr>
<a id="more"></a>

<h4 id="废话连篇"><a href="#废话连篇" class="headerlink" title="废话连篇"></a>废话连篇</h4><p>曾记得，2016 年端午节，在<code>Github Pages</code>上写下了人生中的第一篇博客，那时就用的<code>Hexo + Next</code>主题，时至今日，一直对<code>Hexo + Next</code>甚是喜爱，感谢大佬，感谢开源 🙏 。</p>
<p>期间，经历了换工作、换电脑、换域名、换托管，诸多原因导致博客遗失，不过也是甚好，不能守着过去，要拥抱现在和未来（不应该是拥抱开源吗？）。</p>
<p>之前使用过<code>网易云跟帖</code>，大家都戏称灌水专用，现在业已关闭。</p>
<p>接着使用了<code>来必力</code>，一个来自韩国的评论插件，国内访问甚是感人，至于大佬们的反向代理，那时心有余而力不足，遂卒。</p>
<p>后来使用了<code>valine</code>，依托于<a href="https://www.leancloud.cn/">LeanCloud</a>在国内运营，对用户甚是友好，界面也是简洁清新，让人看一眼就喜爱，而且支持阅读统计等诸多功能，之后便一直使用。</p>
<p>偶然间，在<code>知乎</code>上闲逛时，发现了一位大兄关于评论插件的分析和感想，现在依稀记得的一句话就是“无论第三方插件的使用有多友好，数据都存在第三方，哪天他们歇业停工了，数据一样丢失。”，之后就对此耿耿于怀（当然不是对说这句话的仁兄耿耿于怀）。</p>
<p>重建博客之际，对评论插件抱着谨慎的态度选之又选，决定将数据存在<code>Github</code>上，至于歇业停工，既然博客数据都不存在了，还留着评论数据作甚，就让他们同生共死吧。</p>
<p><code>Gitalk</code>和<code>Gitment</code>最先映入眼帘，之后在<code>Github</code>上发现<code>Gitment</code>好久没有更新了，只剩下一个选择。</p>
<p><code>Hexo</code>官方集成了<code>Gitalk</code>，轻车熟路的做好设置，<code>hexo clean | g | s</code>三部曲之后，熟悉的框框出现，然鹅，发现每篇文章都要手动初始化，翻阅<a href="https://github.com/gitalk/gitalk/wiki/%E8%AF%84%E8%AE%BA%E5%88%9D%E5%A7%8B%E5%8C%96">官方 Wiki</a>发现了自动初始化的脚本，底部有<a href="https://draveness.me/git-comments-initialize/">原作者</a> 的链接，遂前往，准备学习膜拜一番，看了大佬的思路解析，大呼过瘾之际也感落寞，原因无他，就是自己不会<code>Ruby</code>。在准备留言评论之际，发现又有<a href="https://www.lshell.com/post/use-github-action-and-python-to-automatically-initialize-gitalk-comments/">大佬</a>给出了使用<code>Python</code>初始化的思路，用轮子不是目的，读懂造轮子的思路学习造轮子，岂不快哉。</p>
<p>进入文章，阅读之际，大佬既感且叹地推荐了一个新的评论插件<code>utterances</code>，揣着疑惑的心去<a href="https://utteranc.es/">官网</a>，去<a href="https://github.com/utterance/utterances">官方仓库</a>查看了一番，发现没有 Wiki，也没有文档，善用搜索引擎的我，搜索一番之后发现，似乎<code>Next</code>主题之前的某个版本集成过，但翻阅了现在的版本又毫无所获，教程都是根据集成时的方法写的，对我无用。</p>
<p>在这里，不得不提的是<code>Hexo</code>的一项前瞻性功能<code>代替配置文件</code>和<code>代替主题配置文件</code>，再也不用像之前一样，想要实现某个功能就去修改官方文件，它不破坏官方文件的完整性，可以无痛更新，之前最头疼的一件事儿就是<code>拉取官方更新之后合并冲突</code>。</p>
<p>这次重建博客，所有非官方功能，如 404、音乐、footer，都使用<code>注入</code>实现，我对这项功能的称呼，暂且这么叫吧。</p>
<p>以上都是废话，下面进入正题：</p>
<h4 id="首先，需要一个用来存储评论的仓库"><a href="#首先，需要一个用来存储评论的仓库" class="headerlink" title="首先，需要一个用来存储评论的仓库"></a>首先，需要一个用来存储评论的仓库</h4><ul>
<li>你可以新建一个仓库；</li>
<li>当然，也可以像我一样，存放在博客仓库的 Issues 中，毕竟我已经承诺了它们同生共死，说到就要做到；</li>
<li>Issues 无法删除，请谨慎选择，防止过多的无用 Issues 带来烦恼（设置 utterances 的时候，这句话依然有效！）；</li>
</ul>
<h4 id="安装-utterances"><a href="#安装-utterances" class="headerlink" title="安装 utterances"></a>安装 utterances</h4><ul>
<li><p>点击<a href="https://github.com/apps/utterances">这里</a>打开安装页面，然后点击右上角的<code>安装</code>；</p>
</li>
<li><p>按下安装按钮，（不不不，不够严谨，按下是 201，抬起才是 202），你会跳转到：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giukvthjlpj30fy0oqtbi.jpg" alt="第二步"></p>
<p>如图所示的页面，选择第一步中创建的仓库或已有的仓库，然后点击<code>安装</code>，请记住仓库名，因为接下来要用；</p>
</li>
<li><p>接下来，会跳转到设置页面；</p>
</li>
</ul>
<h4 id="设置-utterances"><a href="#设置-utterances" class="headerlink" title="设置 utterances"></a>设置 utterances</h4><ul>
<li><p>在这里，请务必填写你在上一步中选择的仓库，并在前面加上仓库的所有者：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giul8ahfszj30k60bfwfv.jpg" alt="第三步"></p>
</li>
<li><p>当然，如果你比较调皮，没有填写上一步中选择的仓库，还是有补救办法的，点击<a href="https://github.com/apps/utterances">这里</a>，其实就是安装页面，你会跳转到安装页面，你发现右上角的<code>安装</code>不见了，取而代之的是<code>配置</code>，就是它了，去配置页面修改吧；</p>
</li>
<li><p>至于这里，是配置 utterances 创建新的 Issues 时，给 Issues 起的名儿：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giullxjlwfj30jo0i2q65.jpg" alt="配置"></p>
<p>请自由发挥，因为使用了<a href="https://github.com/rozbo/hexo-abbrlink">abbrlink</a>，链接并不显示文章名称，所以我就选图中所示的选项了，自由发挥的同学，玩的开心；</p>
</li>
<li><p>这里是选填选项，给 utterances 创建的 Issues 设置标签：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giulsj64dxj30jt072dgf.jpg" alt="设置标签"></p>
</li>
<li><p><code>Theme</code>就不用说了吧，主题选自己喜欢的，没喜欢的？给官方提交一个新主题；</p>
</li>
<li><p>接下来就是重头戏了，上面所有的选项都是为它服务的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giulyonf3xj30jz09lq41.jpg" alt="script"></p>
<p>复制 script 并添加到你想要评论出现的地方，bingo！</p>
</li>
</ul>
<h4 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h4><p>因为要用<code>注入</code>来实现评论功能，那就不能修改官方的模板，自己撸了个 js 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* utterances 评论插件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  query2add();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pjax 使用 pushState() 不会触发 hashchange 事件，需要拦截</span></span><br><span class="line"><span class="keyword">var</span> _wr = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> orig = history[type];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="keyword">new</span> Event(type);</span><br><span class="line">    e.arguments = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">window</span>.dispatchEvent(e);</span><br><span class="line">    <span class="comment">// 注意事件监听在url变更方法调用之前 也就是在事件监听的回调函数中获取的页面链接为跳转前的链接</span></span><br><span class="line">    <span class="keyword">var</span> rv = orig.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState = _wr(<span class="string">&quot;pushState&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 change 事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;pushState&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e &amp;&amp; e.arguments.length &gt; 2 &amp;&amp; e.arguments[2]</span></span><br><span class="line">  query2add();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 utterance 插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadUtterance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> js = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  <span class="comment">/* 以下内容改成第三步生成的配置 */</span></span><br><span class="line">  js.setAttribute(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;https://utteranc.es/client.js&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;repo&quot;</span>, <span class="string">&quot;Undeio/undeio.github.io&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;issue-term&quot;</span>, <span class="string">&quot;title&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;theme&quot;</span>, <span class="string">&quot;github-light&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;crossorigin&quot;</span>, <span class="string">&quot;anonymous&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;async&quot;</span>, <span class="string">&quot;async&quot;</span>);</span><br><span class="line">  <span class="comment">/* 以上内容需要修改 */</span></span><br><span class="line">  <span class="comment">// 添加到主体部分的末尾</span></span><br><span class="line">  <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;main-inner&quot;</span>)[<span class="number">0</span>].appendChild(js);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已存在组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query2add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有正文页面才有 post-copyright，也就是最后的版权声明</span></span><br><span class="line">  <span class="comment">// 当然，你也可以找一个自己正文才有的标识进行判断</span></span><br><span class="line">  <span class="keyword">let</span> postCopyRight = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;post-copyright&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (postCopyRight &amp;&amp; postCopyRight[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="comment">// 存在评论就放弃添加</span></span><br><span class="line">    <span class="keyword">let</span> utterances = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;utterances&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (utterances &amp;&amp; utterances[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loadUtterance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无图无真相</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giumvnbuw0j30gu0hm0vd.jpg" alt="真相"></p>
<p>最终效果</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giun047pynj30w10admy8.jpg" alt="效果"></p>
<blockquote>
<p>才疏学浅，实现比较粗糙，如果你有更好的实现，请给我留言。</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Utterance</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之 P-Code 寻找操作码</title>
    <url>/post/3657232687/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li>VB 静态分析工具<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-8">exdec</a>来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-20">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><h5 id="方法一：手动寻找"><a href="#方法一：手动寻找" class="headerlink" title="方法一：手动寻找"></a>方法一：手动寻找</h5><ol>
<li><p>将<code>CrackMe</code>倒入<code>OD</code>，会停留在程序的入口点，向上滚动代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmu1cuo5wj31b40u0q6o.jpg" alt="程序入口"></p>
<p>会发现一个 API <code>MethCallEngine</code>是用来初始化<code>P-Code</code>的，不过<code>P-Code</code>的初始化和常见的程序相反，一般，程序在运行时，会初始化所有资源以供调用，而<code>P-Code</code>却是在调用时才会初始化；</p>
</li>
<li><p>在<code>MethCallEngine</code>上右键菜单选择跟随或者在<code>MethCallEngine</code>上按下<code>Enter</code>，进入函数内部：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmu8fdabdj31b30u0n0r.jpg" alt="函数内部"></p>
<p>双击行首或按下<code>F2</code>设置断点并做好备注；</p>
</li>
<li><p>接着运行程序，发现程序主窗体已经出现，但并没有中断在设置的断点位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmuif7y2nj31b50u0jv1.jpg" alt="没有中断在断点位置"></p>
<p>然后输入随机注册码，点击<code>Registrar</code>后，程序才会中断在断点位置，这也从侧面说明了<code>P-Code</code>是先调用，后初始化；</p>
</li>
<li><p>来到<code>内存窗口</code>，在代码段设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmuonz3vuj31b20u076z.jpg" alt="内存访问断点"></p>
<p>虽然<code>P-Code</code>使用的是操作码，但它依然会存储在代码段；</p>
</li>
<li><p>接下来就是寻找操作码了，操作码的格式是<code>MOVE AL, BYTE PTR DS:[ESI]</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmuyuyqyzj31b40u0jvu.jpg" alt="第1操作码"></p>
<p>多次中断后会停留在预期的指令上，而这条指令的作用就是获取操作码，数据窗口查看<code>ESI</code>会得到具体的操作码；</p>
</li>
</ol>
<h5 id="方法二：工具分析"><a href="#方法二：工具分析" class="headerlink" title="方法二：工具分析"></a>方法二：工具分析</h5><ol>
<li><p>使用<code>exdec</code>工具分析程序，会得到程序的静态分析结果：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmv9f05wgj31b20u0td9.jpg" alt="静态分析"></p>
<p>可以看到，分析的结果和手动寻找的结果一致，地址相同，操作码相同；</p>
</li>
<li><p>测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmvhn1zp8j31b60u0af0.jpg" alt="设置内存访问断点"></p>
<p>重载程序，在数据窗口跟随分析结果第 1 操作码的地址，然后在第 1 操作码上设置内存访问断点；</p>
</li>
<li><p>运行程序，输入注册码，点击 Registrar：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnmvo4idw0j31b50u0435.jpg" alt="中断在操作码位置"></p>
<p>程序中断在第 1 操作码的位置；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>VB</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之 P-Code 替换操作码</title>
    <url>/post/3307503664/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-22">CrackMe 和 opcode.txt</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>运行程序，程序会先弹出一个 NAG 窗口，点击确定后弹出主窗体：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuyri1qyhj30sy0lcaau.jpg" alt="运行程序"></p>
</li>
<li><p>导入<code>OD</code>开始分析，首先按照常规思路，既然有弹窗，肯定会使用 API：<code>rtcMsgBox</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuyuvjmrpj31dv0u0tcb.jpg" alt="查找API"></p>
<p>查看 API 列表，找到<code>rtcMsgBox</code>设置断点，然后运行程序；</p>
</li>
<li><p>程序中断后，在栈窗口<code>反汇编窗口跟随</code>到返回位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuywuticyj31dv0u0q6f.jpg" alt="反汇编窗口跟随"></p>
<p>在调用位置设置断点，然后重载并运行程序；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv2fpugyyj31dx0u078s.jpg" alt="在调用位置设置断点"></p>
</li>
<li><p>调用指令是<code>CALL EAX</code>，当前 EAX 值为 401000，<code>Ctrl + G</code> 跳转到 401000，正是<code>rtcMsgBox</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuz7bgembj31dr0u00wd.jpg" alt="401000"></p>
<p>按下<code>-</code>减号键，回到断点位置，既然是调用函数，CALL 上面的指令就是它的参数，这种传参方式在 P-Code 中很常见，还没有完，继续；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuznpzrsjj31dv0u0n28.jpg" alt="CALL的参数"></p>
<p>CALL 的参数到底是什么呢？</p>
<p>根据上面的代码逻辑，获取一个操作码后无条件跳转了，所以，<code>JMP</code>以上的代码与 CALL 无关；</p>
<p>因此，CALL 的参数应该是<code>JMP</code>向下，直到<code>CALl</code>；</p>
<p>给参数起始位置设置断点，因为中间包含<code>JE</code>跳转，为了防止跳转，同时给<code>JE</code>也设置断点，重载并运行程序；</p>
</li>
<li><p>这里的戏就很精彩了，程序中断在参数位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnuzxxlr7hj31dy0u0tcz.jpg" alt="程序中断在参数位置"></p>
<p>然后按下<code>Ctrl + A</code>分析程序，在信息窗口发现跳转至此处的位置太多，如果挨个儿去跟，那就相等精彩了；</p>
<p>同时，EAX 中有一个操作码<code>OA</code>，为啥它是操作码？因为根据 P-Code 的惯例，接下来既然要获取参数了，且代码没有执行，那 EAX 中存放的就是上一步的结果，而 P-Code 的逻辑就是先获取操作码，紧接着就是获取参数，那就说明，接下来获取的参数既是 CALL 的参数，也是<code>OA</code>操作码的参数，So，<code>OA</code>肯定是一个操作码；</p>
<p>数据窗口跟随 ESI，发现<code>OA</code>位于当前 ESI 之前，地址是：401AD2；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv0ahg84qj31e00u0n1p.jpg" alt="数据窗口跟随 ESI"></p>
<p>既然接下来要执行 CALL 也就是<code>rtcMsgBox</code>函数了，那么<code>OA</code>在 P-Code 中是否就是<code>rtcMsgBox</code>呢？</p>
</li>
<li><p>继续运行程序，直到将要获取下一个操作码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv0jiz60tj31dw0u0q6r.jpg" alt="将要获取下一个操作码"></p>
<p>标志性的获取操作码的语句，接下来要获取的操作码是<code>36</code>，同时也反向说明，在这行代码之前，<code>OA</code>操作码是一直有效的；</p>
<p>而且，<code>OA</code>的参数是两个：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv10zic33j31e00u0q8d.jpg" alt="OA 的参数是两个"></p>
<p>因为操作了两次 ESI，同时，位于<code>OA</code>和<code>36</code>之间的数据被分别放入了 ECX 和 EDI；</p>
</li>
<li><p>大胆的猜测一下，如果<code>OA</code>就是<code>rtcMsgBox</code>，那么替换它是否就能跳过弹窗呢？</p>
</li>
<li><p>重载程序，在数据窗口 goto 到<code>OA</code>，也就是 401AD2：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv0sw66o4j31dz0u0n0r.jpg" alt="goto 到 OA"></p>
</li>
<li><p>打开<code>opcode.txt</code>，发现<code>07</code>与<code>OA</code>参数数量和参数大小都相同，且<code>07</code>没有副作用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv20byaqvj312e0e20sz.jpg" alt="opcode.txt"></p>
<p>如上图所示：</p>
<ul>
<li><code>OA</code>表示调用指针（ptr）指向的函数，且没有返回值，4 字节大小，有 2 个参数，参数一 2 字节，参数二 2 字节（4 2 2 2）；</li>
<li><code>07</code>表示 PUSH 值到堆栈，4 字节大小，有 2 个参数，参数一 2 字节，参数二 2 字节（4 2 2 2）；</li>
</ul>
<p>这里不用 <code>0B</code>替换<code>OA</code>的原因是：CALL 的副作用要比 PUSH 大的多；</p>
<p>所以，替换<code>0A</code>为<code>07</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv18ioilnj31dz0u0wiv.jpg" alt="替换 OA"></p>
<p>需要注意的是：替换操作码时，两个操作码的参数数量和参数大小必须相同，且替换的操作码对程序的运行没有副作用；</p>
<p>这里再次感谢<a href="http://xuepojie.com/">恒大</a>提供的<code>opcode.txt</code>文件；</p>
</li>
<li><p>然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv1e58hd6j31dz0u0n10.jpg" alt="然后运行程序"></p>
<p>没有出现 NAG 窗口，直接显示程序主窗体；</p>
</li>
<li><p>保存修改到可执行文件，运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv1hpnkpqj30wa0k23z2.jpg" alt="保存修改到可执行文件"></p>
<p>修改依然没有问题，完工！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>VB</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之优先创建窗体</title>
    <url>/post/3326045461/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-18">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先运行软件，了解一下程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxg8pjn3fg30mw0i4qit.gif" alt="运行程序"></p>
<ul>
<li>运行程序后，首先出现一个倒计时 5 秒的窗体；</li>
<li>同时 Continue 按钮处于禁用状态；</li>
<li>倒计时结束后，Continue 按钮启用，并在点击后可进入主窗体；</li>
</ul>
</li>
<li><p>将<code>CrackMe</code>倒入<code>OD</code>，开始分析：</p>
<ul>
<li><p>这里的倒计时窗体可以算得上是<code>NAG</code>窗口了，很是烦人啊有木有；</p>
</li>
<li><p>如何跳过<code>烦人的窗口</code>直接进入主程序呢？</p>
<ol>
<li><p>倒计时结束后，点击 Continue ，程序跳转进入主程序；</p>
</li>
<li><p>程序的跳转肯定发生在<code>CODE</code>段；</p>
</li>
<li><p>在倒计时结束后，到<code>内存窗口</code>给<code>CODE</code>段设置内存访问断点，然后在程序界面点击 Continue：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxj7a5ioxj31a40u0tf3.jpg" alt="内存访问断点"></p>
</li>
<li><p>程序中断，可以看到接下来要执行 JMP，根据程序的逻辑可以确定，这个 JMP 就是跳转到主窗体的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxjcnfvr5j319s0u0gpl.jpg" alt="跳转到主窗体"></p>
<p>相邻的还有 3 个 JMP，给它们全部设置断点，看看它们分别要做的事情；</p>
</li>
<li><p>重载并运行程序，程序中断在第三个 JMP，根据程序逻辑，程序初始运行后，会先展示一个<code>NAG</code>窗口，<code>F9</code>运行程序，果然不出所料；</p>
</li>
<li><p>接着运行程序，程序中断在第四个 JMP，共计中断 5 次，不用说，这个是倒计时跳转，同时，最后一次中断后，Continue 按钮启用；</p>
</li>
<li><p>点击 Continue 按钮，程序中断在第一个 JMP 位置，四个跳转已知其三，第二个 JMP 肯定是 Exit，最后，分析结果如图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxjzjje22j319x0u0q60.jpg" alt="分析"></p>
</li>
<li><p>既然已经知道了第一个 JMP 是跳转至程序主窗体的，那能否让程序刚运行就跳转到主窗体，这样是不是就绕过了<code>NAG</code>窗口？值得一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxk4ry1mij30mu0meq6g.jpg" alt="NoNAG"></p>
<p>将修改保存到文件，保存方法不再赘述，然后运行程序，Perfect！</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>4C 法</p>
<blockquote>
<p>4C 法对于单纯的本地验证应该比较好用，但是基于网络验证可能就不是很好用了，尽管可以到达程序主窗口，但功能也许还是不可用；</p>
</blockquote>
<p>还是这个<code>CrackMe</code>，将<code>CrackMe</code>倒入<code>OD</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxlfn0d4cj319r0u0tbr.jpg" alt="第一行"></p>
<blockquote>
<p>VB 程序有个特点：入口处都是一个 PUSH 指令，然后一个 CALL 指令；</p>
</blockquote>
<p>发现第一行是一个 PUSH 指令，4C 法就是将 PUSH 的地址加上<code>4C</code>，然后在数据窗口中跟随这个地址；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxlkobm9sj31a80u0tcv.jpg" alt="加上 4C"></p>
<p><code>Ctrl + G</code>跟随地址后，发现这个地址中存储着另外一个地址，选择存储的地址，然后右键选择<code>数据窗口中跟随（DWORD）</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxlsfxheaj319s0u00xh.jpg" alt="跟随 4 字节地址"></p>
<p>跟踪地址来到数据窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxp8l5p0lj31a00u0goo.jpg" alt="结构类似"></p>
<p>这里可以看到两块类似的数据,每块 50(十六进制)个字节的长度,每块数据的第 24(十六进制)个字节处都有一个标志（第一个是 00，第二个是 01）；</p>
<p>该标志指定了代码块（也就是程序启动后要加载的窗体）出现的顺序，先加载 00，也就是我们要去掉的 NAG 窗口，再加载 01，也就是主窗口；</p>
<p>所以，为了去掉<code>烦人的窗口</code>，将此处的两个标志的值互换，即：00 改 01，01 改 00，这样的话 NAG 窗口就永远也没机会出现了，最后将修改保存到文件；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxphhj5cjj30ys0dm74w.jpg" alt="互换值"></p>
<p>接着，运行保存的文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxpknxv21j30nc0m2n0o.jpg" alt="reverse"></p>
<p>直接出现程序主窗体，NAG 窗口被去除；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>VB</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之分析 N-Code（一）</title>
    <url>/post/1203909517/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-17">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先运行软件，了解一下程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwwx2zk5ij30cg0j474t.jpg" alt="运行程序"></p>
<p>O, No!</p>
<ul>
<li><p>首先是一个<code>NAG 窗口</code>:</p>
<blockquote>
<p><code>NAG 窗口</code>：软件未注册或软件的试用版经常会弹出一些提示窗口要求注册，这些窗口被称为 nag 窗口，也叫烦人的窗口；</p>
</blockquote>
</li>
<li><p>然后才是软件窗口，要求输入注册码；</p>
</li>
<li><p>输入随机字符点击 OK，一个奇怪的弹窗，应该是 No? Thanks?</p>
</li>
</ul>
</li>
<li><p>将<code>CrackMe</code>倒入<code>OD</code>，开始分析：</p>
<ul>
<li><p>首先，第一件事儿是去掉<code>烦人的窗口</code>：</p>
<p>既然是弹窗，那么它肯定调用了<code>MessageBox</code>这个 API，不过，VB 有专有的 API <code>rtcMsgBox</code>：调用一个消息框，类似于 Windows 里的 MessageBox/A/EXA，此之前一定有个 PUSH 命令将要在消息框中显示的数据压入椎栈；</p>
<ol>
<li><p>既然已经知道了它调用的 API，那还等什么，给<code>rtcMsgBox</code>设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwf5ajmbfj319x0u0ado.jpg" alt="设置断点"></p>
<p>按下<code>Ctrl + G</code>输入<code>rtcMsgBox</code>，然后点击确定，程序会跳转到<code>rtcMsgBox</code>函数的行首，然后双击该行设置断点，并做好备注；</p>
</li>
<li><p>设置好断点后，<code>F9</code>运行程序，程序会中断在断点位置，然后在<code>堆栈窗口</code>跟踪调用位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwfej14e2j31a10u0787.jpg" alt="反汇编窗口中跟随"></p>
</li>
<li><p>来到<code>反汇编窗口</code>，这个时候函数<code>rtcMsgBox</code>已经调用完成，既然找到了调用位置，那怎么能去掉<code>烦人的窗口</code>呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwrwzbi2mj31a40u0q74.jpg" alt="返回位置"></p>
<p>设置好断点，重载并运行程序后，程序中断在预先设置好的断点位置，而下面一行的<code>CALL</code>就是调用<code>rtcMsgBox</code>的位置，如果把这个调用<code>NOP</code>了，是不是就没有<code>NAG 窗口</code>了，听起来蛮靠谱，试一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmws2k2c0gj31a00u0adj.jpg" alt="NOP"></p>
</li>
<li><p><code>NOP</code>了调用<code>rtcMsgBox</code>的<code>CALL</code>后，继续运行程序，但并没有按照预期显示程序主窗口，而是程序结束了，这是怎么回事儿呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmws7fd2l7j319y0u0jus.jpg" alt="程序终止了"></p>
<p>按下<code>-</code>减号键，返回上层位置，把修改的内容保存下来试试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwszp7i1mj31c90u0ag0.jpg" alt="保存到文件"></p>
<p>双击运行保存的程序，没有任何反应，em ～～ 看来程序被玩坏了，此路不通；</p>
</li>
<li><p>重载并运行程序，重新来到<code>反汇编窗口</code>，既然把直接调用函数<code>NOP</code>了不行，那就只能继续运行程序，看看它的上一级调用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwtwz0lpqj319u0u0gq0.jpg" alt="上级调用"></p>
<p>来到上级调用的返回位置，上一行的<code>CALl</code>就是刚才整段代码的调用位置，如果把这个<code>CALl</code>干掉，那么弹窗也就没有了，试一试，但愿程序不被玩儿坏；</p>
<p>在这个<code>CALl</code>的参数的上一行设置断点，重载并运行程序；</p>
</li>
<li><p>程序中断在预定位置，选择下面<code>CALl</code>和它的参数用<code>NOP</code>填充：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwu4tmu4yj319x0u0789.jpg" alt="用NOP填充"></p>
</li>
<li><p>继续运行程序，啊哈，期待已久的程序主窗口终于出现了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwu6csc67j319y0u0adb.jpg" alt="程序主窗口"></p>
<p>主程序出现，说明这个方法可行；</p>
</li>
<li><p>为了后面找码方便，把修改后的程序另存为一个新的程序：终于要和<code>烦人的窗口</code>说拜拜了，至于保存的方法，上面已经说明，不再赘述；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwue6f08gj30fa0hyglz.jpg" alt="NoNAG"></p>
<p>运行修改的程序，嗯，没有<code>NAG 窗口</code>，直接出现程序主窗体，一切 OK；</p>
</li>
</ol>
</li>
<li><p>搞定<code>NAG 窗口</code>后，是时候寻找一下注册码了：</p>
<ol>
<li><p>把修改后的程序倒入<code>OD</code>，然后运行程序，主窗体出现：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwujt8bmmj31a10u0whn.jpg" alt="运行修改程序"></p>
</li>
<li><p>输入随机注册码，但不要点 OK，但不要点 OK，但不要点 OK，重要的事情说三遍：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwunevjelj31a90u0419.jpg" alt="内存访问断点"></p>
<p>接着到<code>内存窗口</code>，在<code>CODE 段</code>设置<code>内存访问断点</code>，然后到程序中点击 OK；</p>
</li>
<li><p>点击 OK 后，程序中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwuq1qlscj31a70u0dj1.jpg" alt="程序中断"></p>
<p>这里的代码看不大懂，不过没关系，也没有找到需要的信息；</p>
</li>
<li><p>继续运行程序，直到看到了随机输入的注册码和字符串比较函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwuupo64mj319x0u0wi4.jpg" alt="字符串比较"></p>
<p>随机输入的字符作为字符串比较函数的参数，那另一个参数毋庸置疑，肯定是真实的注册码；</p>
</li>
<li><p>不过遗憾的是，由于这个软件是西欧字符软件，好多字符无法正确显示，找到了真实的注册码也无法输入，复制也不行，因为系统字符集中没有某些字符：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwv3kqadtj319w0u0jxi.jpg" alt="字符集"></p>
</li>
<li><p>既然无法输入真实注册码，那就只能让任意字符成为注册码了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwvbq3c94j319r0u0wif.jpg" alt="比较不成立"></p>
<p>首先，字符串比较函数的返回结果非 0，说明两个参数不相等，继续向下分析；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmww36rsqtj319z0u0jwe.jpg" alt="向下分析"></p>
<p>把比较的结果从 EAX 拷贝到 EDI 中，然后进行了一系列的操作，然而，如果 EDI 为 0，则这些操作没有任何意义，至于中间夹杂的其他操作可以忽略了，因为没有涉及到 EDI：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmww36rsqtj319z0u0jwe.jpg" alt="操作 EDI"></p>
<p>这里有一个 JE 跳转，上一行代码是<code>TEST DI, DI</code>，如果 EDI 自身为 0，则<code>TEST DI, DI</code>影响 ZF 标志位，ZF 置 1，反之为 0，而恰恰 JE 根据 ZF 标志位跳转，可以看到，程序运行到了这里，ZF 依然为 0，则间接说明了输入的注册码不正确；</p>
<p>既然这个跳转根据比较的结果进行跳转，那就可以确定它是关键跳，如果将 JE 修改为 JMP，是否就能满足<code>让任意字符成为注册码</code>？值得一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwwqklr2hj319v0u0jv1.jpg" alt="修改为 JMP"></p>
<p>修改 JE 为 JMP 后，取消内存访问断点，然后<code>F9</code>运行程序，It’s OK，终于看到了成功弹窗，不过由于字符集的原因，部分字符无法显示；</p>
</li>
<li><p>保存修改到文件，然后输入任意字符：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwwuohw0dj30ca0i4mxh.jpg" alt="成功"></p>
<p>成功的弹窗是 Yes? Thanks?</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>VB</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之分析 N-Code（二）</title>
    <url>/post/3794155287/</url>
    <content><![CDATA[<blockquote>
<p>之前分析过这个 CrackMe（参见：VB 调试之分析 N-Code（一）），需要借助修改版的 OD 才能去除 NAG 窗口，在阅读<a href="https://reversecore.com/">逆向工程核心原理</a>一书后，学到了一种新的技巧，记录下来；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-21">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>将<code>CrackMe</code>倒入<code>OD</code>，查找<code>rtcMsgBox</code>并设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpdqgghp6j31b80u0jun.jpg" alt="查找"><br><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpdsakoemj31b40u0jv4.jpg" alt="设置断点"></p>
</li>
<li><p>然后<code>F9</code>运行程序，程序会中断在调用位置，与直接给 API 设置的断点不同，这样设置的断点会中断在调用位置，而给 API 设置的断点会中断在<code>rtcMsgBox</code>函数的行首：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpdxeqg7cj31b20u0n0o.jpg" alt="调用位置"></p>
</li>
<li><p>向上滚动代码，找到函数栈帧，然后设置断点：</p>
<p>至于什么是栈帧？</p>
<p>ESP 始终指向栈的顶端，程序运行中，ESP 寄存器的值随时变化，访问栈中函数的局部变量、参数时，若以 ESP 的值为基准会十分困难，使 CPU 很难引用到准确的位置；</p>
<p>所以，调用函数时，先要把作为基准点（函数起始地址）的 ESP 值保存到 EBP，并维持在函数内部，这样，无论 ESP 如何变化，以 EBP 的值为基准总是能够安全的访问到相关函数的局部变量、参数、返回地址，这就是栈帧；</p>
<p>也就是说，ESP 寄存器承担着栈顶指针的作用，而 EBP 寄存器则负责行使栈帧指针的职能；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpedvtcsej31b40u0tcb.jpg" alt="函数栈帧"></p>
</li>
<li><p>取消其它断点，重载并运行程序，程序会在断点处中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpeifwm5kj31b40u078b.jpg" alt="断点处中断"></p>
<p>然后在<code>堆栈窗口</code>选择<code>反汇编窗口中跟随</code>到调用位置；</p>
</li>
<li><p>给调用位置和返回位置设置<code>F2</code>断点并取消其它断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpemqmyx6j31b40u0q6s.jpg" alt="设置两个断点"></p>
</li>
<li><p>重载并运行程序，程序中断在调用位置设置的断点处：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpepoqti8j31b40u078f.jpg" alt="调用位置栈顶指针"></p>
<p>记录调用位置栈顶指针的地址；</p>
</li>
<li><p><code>F9</code>运行程序，NAG 窗口弹出，点击确定，程序中断在函数的返回位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpeuabiakj31au0u0wil.jpg" alt="返回位置栈顶指针"></p>
<p>记录返回位置栈顶指针的地址；</p>
</li>
<li><p>用返回位置的栈顶指针也就是 ESP 的值减去调用位置 ESP 的值；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpey3glw9j30pk0go0tj.jpg" alt="ESP相减"></p>
<p>以图为例：<code>0012FA10 - 0012FA08 = 8(16 进制)</code>，是不是可以这么理解：在调用函数中使用了 8 个字节的栈内存；</p>
</li>
<li><p>Win32 API 使用的函数调用约定是 stdcall 方式，这种方式的栈内存由被调用者清理，在这里就是由被调用的函数清理，如果在函数的起始位置直接清理栈内存，函数就不会被执行，也就不会弹出 NAG 窗口了；</p>
<p>函数调用约定参见：寄存器小记</p>
</li>
<li><p>重载并运行程序，程序中断在调用位置，<code>F7</code>单步步入到函数内部：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpfnfbtjvj31b50u0wik.jpg" alt="再次中断"></p>
<p>然后来到了 VB 程序类似于交通枢纽的位置，继续<code>F7</code>，跳转到创建 NAG 窗口的函数内部；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpfqj3wzxj31b60u0juw.jpg" alt="交通枢纽"></p>
<p>创建 NAG 窗口的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpfuhpl8ij31b70u041w.jpg" alt="创建 NAG 窗口的函数"></p>
<p>咦，好眼熟啊，是的，这里就是设置程序第 1 个断点的函数，调用<code>rtcMsgBox</code>的函数；</p>
</li>
<li><p>之前的步骤终于派上用场了，根据计算，调用创建 NAG 窗口的函数会使用 8 个字节的栈内存，所以，修改函数的行首，清理栈内存：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpg1bxiquj31b40u0q6s.jpg" alt="清理栈内存"></p>
<p>然后运行程序，没有 NAG 窗口，直接弹出程序主窗体；</p>
</li>
<li><p>保存修改到可执行文件，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpg54qpa0j30f00eut95.jpg" alt="运行程序"></p>
</li>
<li><p>将修改后的 CrackMe 倒入<code>OD</code>，开始处理序列号的问题，然后发现，给<code>rtcMsgBox</code>设置断点后，程序并不会中断，怎么办？</p>
<p>既然程序在输入错误的序列号后会弹出错误弹窗，那么程序内部肯定验证了序列号，那就查找关于字符串比较的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpghdpk83j31b80u0adv.jpg" alt="vbastrcmp"></p>
<p>找到<code>__vbaStrCmp</code>并设置断点，然后<code>F9</code>运行程序；</p>
</li>
<li><p>程序中断在调用<code>__vbaStrCmp</code>的位置，然后，在 EAX 中发现了输入的随机序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpgllvlhaj31bk0u0787.jpg" alt="发现序列号"></p>
<p>既然 EAX 是第 2 参数，那么 ECX 中存放的就是第 1 参数，可能就是真正的序列号；</p>
</li>
<li><p>数据窗口中跟随 ECX 后发现，西欧文字系统无法显示，就是一堆乱码，既然真实注册码无法使用，那有没有可能让任意字符成为注册码，继续向下分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnphe6x02uj31ba0u0q7k.jpg" alt="返回非0"></p>
<p>首先，向下执行一行代码后，EAX 为非 0 值，这里使用的是<code>__vbaStrCmp</code>，所以非 0 说明不相等；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnphegy116j31bd0u0781.jpg" alt="操作EDI"></p>
<p>接着，把返回值拷贝到 EDI 中，进行了一系列操作后，来到了一个跳转，这就很可疑了；</p>
<p>这里对 EDI 进行的一系列操作，如果 EDI 为 0，则没有任何影响，最后的结果是跳转实现，但随机注册码和指定字符串比较，结果肯定不为 0，最终的结果是跳转失败；</p>
<p>按照这个逻辑来推断，这个跳转应该是关键跳转，如何证明呢？修改<code>JE</code>为<code>JMP</code>，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnphla0vxzj31b20u0jvy.jpg" alt="正确弹窗"></p>
<p>修改<code>JE</code>为<code>JMP</code>并运行程序后，弹出提示序列号正确的弹窗，至于为什么这是正确的弹窗，很简单，因为它和错误弹窗不一样；</p>
</li>
<li><p>保存修改到可执行程序，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnphohcvjij30si0cudgg.jpg" alt="成功了"></p>
<p>输入任意字符，点击 OK 后，弹出成功弹窗，结束！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>VB</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之初识 VB</title>
    <url>/post/674877238/</url>
    <content><![CDATA[<blockquote>
<p>初识简单了解一下 VB，相信随着深入的学习，对它的了解会更多，理解会更深；</p>
</blockquote>
<h4 id="P-Code-Packed-Code-压缩代码"><a href="#P-Code-Packed-Code-压缩代码" class="headerlink" title="P-Code Packed Code 压缩代码"></a>P-Code Packed Code 压缩代码</h4><ul>
<li>4.0 以前</li>
<li>运行时，动态链接库（DLL）将翻译或解释执行程序中的指令；</li>
<li>解释器 MSVBVM50.DLL 和 MSVBVM60.DLL</li>
</ul>
<h4 id="N-Code-Native-Code-本机代码"><a href="#N-Code-Native-Code-本机代码" class="headerlink" title="N-Code Native Code 本机代码"></a>N-Code Native Code 本机代码</h4><ul>
<li>5.0 以后</li>
<li>改善 VB 的运行速度</li>
<li>但还是需要 MSVBVM60.DLL，因为许多函数本体放在 MSVBVM60.DLL 里面，需要不断地 CALL 其中的函数，不过，这时候的 MSVBVM60.DLL 就不承担解释执行的任务了，只是充当一般的 DLL；</li>
</ul>
<h4 id="编译器技术"><a href="#编译器技术" class="headerlink" title="编译器技术"></a>编译器技术</h4><ul>
<li>编译器的编译技术可以分为native－compile（自然编译）与pcode－compile（伪编译）两种；</li>
<li>自然编译是编译器将高级语言转换为汇编代码，并经链接生成EXE程序的过程；</li>
<li>伪编译是编译器将高级语言转换为某种编码后，将能解释、执行此编码的一段程序一同链接，生成EXE程序；</li>
<li>伪代码p-code，最早应该叫做Pascal-Code，其名称起源于一个pascal编译器使用的“中间代码”编译技术。现在一般作为pseudo-code（伪代码），或packed-code（压缩代码）简称，此项编译技术的出现，最终导致了“虚拟机”的出现。而微软在其编程工具basic、c、vb中都使用了类似的编译技术；</li>
<li>所谓伪代码，其基本工作原理是编译器先把执行程序编译为比80X86机器码紧凑得多的中间代码形式，然后在链接时把一个小工作引擎嵌入执行程序中，最后在运行时由此工作引擎把P-Code解释为本地机器码实际执行，所以叫做packed-code；同时又由于此代码并不是最终的机器码形式，实际上是“变形的源代码”，所以也被称为pseudo-code。依靠P-code编译技术，使得编程语言不依赖于机器或操作平台成为可能；</li>
</ul>
]]></content>
      <categories>
        <category>VB</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器小记</title>
    <url>/post/592731679/</url>
    <content><![CDATA[<h3 id="基本程序运行寄存器"><a href="#基本程序运行寄存器" class="headerlink" title="基本程序运行寄存器"></a>基本程序运行寄存器</h3><ul>
<li>通用寄存器：32 位，8 个</li>
<li>段寄存器：16 位，6 个</li>
<li>程序状态与控制寄存器：32 位，1 个</li>
<li>指令指针寄存器：32 位，1 个</li>
</ul>
<p>在寄存器名称缩略语之前添加字母 E（Extended），表示该寄存器在 16 位 CPU 时就已经存在，并且其大小在 IA-32 下由原 16 位扩展为 32 位；</p>
<a id="more"></a>

<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器是一种通用型的寄存器，用于传送和暂存数据，也可以参与算术逻辑运算，并保存运算结果；</p>
<h4 id="通用寄存器拆分"><a href="#通用寄存器拆分" class="headerlink" title="通用寄存器拆分"></a>通用寄存器拆分</h4><p>为了实现对低 16 位的兼容，各寄存器又可以分为高、低几个独立寄存器；</p>
<p>以 EAX 为例（不涉及大端序、小端序），只为直观：</p>
<ul>
<li>EAX = 12345678 （0 ～ 31）32 位</li>
<li>&nbsp;&nbsp;AX = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5678 （0 ～ 15）EAX 的低 16 位</li>
<li>&nbsp;&nbsp;AH = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;56&nbsp;&nbsp;&nbsp; （8 ～ 15）AX 的高 8 位</li>
<li>&nbsp;&nbsp;AL = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;78 （0 ～ 7）AX 的低 8 位</li>
<li>以上拆分方式适用于 EAX / EBX / ECX / EDX</li>
<li>EBP / ESP / ESI /EDI 只能拆分为 16 位，即 BP / SP / SI / DI</li>
</ul>
<h4 id="大端序与小端序"><a href="#大端序与小端序" class="headerlink" title="大端序与小端序"></a>大端序与小端序</h4><p>计算机领域中，字节序是多字节数据在计算机内存中存储或网络传输时各字节的存储顺序，主要分为两大类：小端序（Little endian）和大端序（Big endian）；</p>
<table>
<thead>
<tr>
<th align="center">TYPE</th>
<th align="center">Name</th>
<th align="center">SIZE</th>
<th align="center">大端序类型</th>
<th align="center">小端序类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BYTE</td>
<td align="center">b</td>
<td align="center">1</td>
<td align="center">[12]</td>
<td align="center">[12]</td>
</tr>
<tr>
<td align="center">WORD</td>
<td align="center">w</td>
<td align="center">2</td>
<td align="center">[12][34]</td>
<td align="center">[34][12]</td>
</tr>
<tr>
<td align="center">DWORD</td>
<td align="center">dw</td>
<td align="center">4</td>
<td align="center">[12][34][56][78]</td>
<td align="center">[78][56][34][12]</td>
</tr>
<tr>
<td align="center">char []</td>
<td align="center">str</td>
<td align="center">4</td>
<td align="center">[73][74][72][00]</td>
<td align="center">[73][74][72][00]</td>
</tr>
</tbody></table>
<ul>
<li>数据类型为字节型（BYTE）时，其长度为 1 个字节，无论采用大端序还是小端序，字节顺序都一样；</li>
<li>数据长度为 2 个字节以上（含 2 个字节）时，采用不同字节序保存数据时，形成的存储顺序是不同的；</li>
<li>采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位；</li>
<li>采用小端序存储数据时，内存地址高位存储数据的高位，内存地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒转；</li>
<li>字符串被保存在字符数组中；</li>
<li>字符数组在内存中是连续的，所以，无论采用大端序还是小端序，存储顺序都相同；</li>
<li>字符串最后以 NULL 结尾；</li>
<li>Intel x86 CPU 采用小端序存储数据；</li>
</ul>
<h4 id="通用寄存器含义"><a href="#通用寄存器含义" class="headerlink" title="通用寄存器含义"></a>通用寄存器含义</h4><ul>
<li><p>EAX：（针对操作数和结果数据的）累加器</p>
</li>
<li><p>EBX：（DS 段中的数据指针）基址寄存器</p>
</li>
<li><p>ECX：（字符串和循环操作的）计数器</p>
</li>
<li><p>EDX：（I/O 指针）数据寄存器</p>
<p>以上 4 个寄存器主要用于算数运算指令中，常常用来保存常量与变量的值；<br>某些汇编指令（MUL、DIV、LODS 等）直接用来操作特定寄存器，执行这些命令后，仅改变特定寄存器中的值；<br>EAX 一般用在函数返回值中，所有 Win32 API 函数都会先把返回值保存到 EAX 再返回，如果处理结果的大小超过 EAX’ 寄存器的容量，其高 32 位将会放到 EDX 寄存器中；</p>
</li>
<li><p>EBP：（SS 段中栈内数据指针）扩展基址指针寄存器</p>
</li>
<li><p>ESP：（SS 段中栈指针）栈指针寄存器</p>
</li>
<li><p>ESI：（字符串操作源指针）源变址寄存器</p>
</li>
<li><p>EDI：（字符串操作目标指针）目的变址寄存器</p>
<p>以上 4 个寄存器主要用于保存内存地址的指针；<br>ESP 指示栈区域的栈顶地址，某些指令（PUSH、POP、CALL、RET）可以直接操作 ESP；<br>EBP 表示栈区域的基地址，函数被调用时保存 ESP 的值，函数返回时再把值返回 ESP，保证栈不会崩溃，这被称为栈帧技术；<br>ESI 和 EDI 与特定指令（LODS、STOS、REP、MOVS 等）一起使用，主要用于内存复制；</p>
</li>
</ul>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>IA-32 的保护模式中，段是一种内存保护技术，它把内存划分为多个区段，并为每个区段赋予起始地址、范围、访问权限等，以保护内存；<br>此外，它还同分页技术一起用于将虚拟内存变更为实际物理内存；<br>段内存记录在 SDT（段描述符表）中，而段寄存器就持有这些 SDT 的索引；<br>段寄存器总共由 6 种寄存器组成，分别是 CS、SS、DS、ES、FS、GS，每个寄存器大小为 16 位，即 2 个字节；；<br>另外，每个段寄存器指向的段描述符与虚拟内存结合，形成一个线性地址，借助分页技术，线性地址最终被转换为实际的物理地址；<br>不使用分页技术的操作系统中，线性地址直接变为物理地址；</p>
<h4 id="段寄存器含义"><a href="#段寄存器含义" class="headerlink" title="段寄存器含义"></a>段寄存器含义</h4><ul>
<li><p>CS：Code Segment，代码段寄存器；</p>
</li>
<li><p>SS：Stack Segment，栈段寄存器；</p>
</li>
<li><p>DS：Data Segment，数据段寄存器；</p>
</li>
<li><p>ES：Extra（Data）Segment，附加（数据）段寄存器；</p>
</li>
<li><p>FS：Data Segment，数据段寄存器；</p>
</li>
<li><p>GS：Data Segment，数据段寄存器；</p>
<p>CS 寄存器用于存放应用程序代码所在段的段基址；<br>SS 寄存器用于存放栈段的段基址；<br>DS 寄存器用于存放数据段的段基址；<br>ES、FS、GS 寄存器用来存放程序使用的附加数据段的段基址；</p>
</li>
<li><p><code>FS 寄存器</code>从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 位存放的是起始位置的地址；</p>
</li>
</ul>
<h3 id="程序状态与控制寄存器"><a href="#程序状态与控制寄存器" class="headerlink" title="程序状态与控制寄存器"></a>程序状态与控制寄存器</h3><p>IA-32 中，标志寄存器的名称为 EFLAGS，其大小为 4 个字节（32 位），由原来的 16 位 FLAGS 寄存器扩展而来；<br>EFLAGS 寄存器的每位都有意义，每位的值为 1 或为 0，代表 ON/OFF 或 TRUE/FALSE；<br>其中有些位由系统直接设定，有些位则根据程序命令的执行结果设置；</p>
<h4 id="标志位寄存器"><a href="#标志位寄存器" class="headerlink" title="标志位寄存器"></a>标志位寄存器</h4><ul>
<li><p>OF 是<code>溢出标志位</code>;</p>
<ul>
<li>有符号整数溢出时，OF 为 1；</li>
<li>MSB（最高有效位）改变时，OF 为 1；</li>
<li>当指令改变了符号位且返回错误值的时候，OF 为 1，表示溢出成立；</li>
<li>运算结果超出机器能够表示的范围称为溢出；</li>
</ul>
</li>
<li><p>PF 是 <code>奇偶标志位</code>；</p>
<ul>
<li>当指令的<code>返回值的二进制</code>表现形式中<code>1</code>的个数为偶数个时，PF 为 1；</li>
<li>运算结果的最低 16 位中含 1 的个数为偶数；</li>
<li>如：11，101，110，1001，1010，1100，1111</li>
</ul>
</li>
<li><p>ZF 是<code>0 标志符</code>.</p>
<ul>
<li>当前指令的运算结果为 0，则 ZF 为 1；</li>
</ul>
</li>
<li><p>SF 是<code>符号位标志符</code>;</p>
<ul>
<li>当指令的运算结果为负数时，SF 为 1；</li>
<li>SF 与运算结果的最高位相同；</li>
</ul>
</li>
<li><p>CF 是<code>进位标志符</code>；</p>
<ul>
<li>无符号整数溢出时，CF 为 1；</li>
<li>当指令的无符号运算结果超过最大值时，CF 为 1；</li>
<li>最高位产生进位或借位；</li>
</ul>
</li>
<li><p>AF 是<code>辅助进位标志符</code>；</p>
<ul>
<li>当指令的运算结果的低 4 位向高 4 位有进位或借位时，AF 为 1；</li>
</ul>
</li>
<li><p>TF 是<code>跟踪标志符</code>；</p>
<ul>
<li>用于调试单步操作；</li>
<li>若 TF 为 1，则每条指令执行结束后，产生中断；</li>
</ul>
</li>
<li><p>DF 是<code>方向标志符</code>；</p>
<ul>
<li>用来控制串处理指令的处理方向；</li>
<li>若 DF 为 1，则串处理中地址自动递减，否则自动自增；</li>
<li>若 DF 为 1，每次操作后使 SI 和 DI 递减，DF 为 0 时则自增；</li>
</ul>
</li>
<li><p>IF 是<code>中断标志符</code>；</p>
<ul>
<li>用来控制 CPU 是否响应可屏蔽中断；</li>
<li>若 IF 为 1 则允许中断，否则禁止中断；</li>
</ul>
</li>
</ul>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><ul>
<li><p>EIP：指令指针寄存器；</p>
<p>指令指针寄存器保存着 CPU 要执行的指令地址，其大小为 32 位（4 个字节），由原 16 位 IP 寄存器扩展而来；<br>程序运行时，CPU 会读取 EIP 中一条指令的地址，传送指令到指令缓冲区后，EIP 寄存器的值自动增加，增加的大小即是读取指令的字节大小，这样，CPU 每次执行完一条指令，就会通过 EIP 寄存器读取并执行下一条指令；<br>与通用寄存器不同，不能直接修改 EIP 的值，只能通过其它指令间接修改，这些特定指令包括 JMP、JCC、CALL、RET；<br>还可以通过中断或异常来修改 EIP 的值；</p>
</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是定义在进程中的一段内存空间，向下（低地址方向）扩展，且其大小被记录在 PE 头中，也就是说，进程运行时确定栈内存的大小；</p>
<p>栈通常用于存储局部变量、传递函数参数、保存函数返回地址等；</p>
<p>栈内存在进程中的作用：</p>
<ul>
<li>暂时保存函数内的局部变量；</li>
<li>调用函数时传递参数；</li>
<li>保存函数返回后的地址；</li>
</ul>
<p>栈是一种数据结构，它按照 FILO（First In Last Out，先进后出）的原则存储数据；</p>
<ul>
<li>一个进程中，栈指针（ESP）初始状态指向栈底端；</li>
<li>执行 PUSH 压栈命令时，栈指针就会向上移动到栈顶端；</li>
<li>执行 POP 弹栈命令时，若栈为空，则栈指针重新移动到栈底端；</li>
<li>栈是一种由高地址向低地址扩展的数据结构；</li>
<li>栈是由下向上扩展的，栈是逆序扩展的；</li>
</ul>
<p>向栈压入数据时，栈指针减小，向低地址移动；从栈中弹出数据时，栈指针增加，向高地址移动；</p>
<h4 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h4><p>函数调用约定（Calling Convention）：是对函数调用时如何传递参数的一种约定；</p>
<ul>
<li>调用函数前，要先把参数压入栈，然后再传递给函数；</li>
<li>栈内存是固定的，ESP 用来指示栈的当前位置，若 ESP 指向栈底，则无法再使用该栈；</li>
<li>函数调用后如何处理 ESP 就是函数调用约定要解决的问题；</li>
</ul>
<p>主要的函数调用约定：</p>
<ul>
<li><p>cdecl：是主要在 C 语言中使用的方式，调用者负责处理栈；</p>
<p>如：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> <span class="number">00401000</span>       <span class="comment">; 调用函数</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">ESP</span>, <span class="number">8</span>          <span class="comment">; 清理栈</span></span><br></pre></td></tr></table></figure>
<p>调用函数后，使用<code>ADD ESP, 8</code>命令整理栈；</p>
<p>调用者直接清理其压入栈的函数参数，这样的方式即是<code>cdecl</code>；</p>
<p><code>cdecl</code>方式的好处是，它可以像 C 语言的 printf()函数一样，向被调用函数传递长度可变的参数，这种长度可变的参数在其它调用约定中很难实现；</p>
</li>
<li><p>stdcall：常用于 Win32 API，该方式由被调用者清理栈；<br>若想在 C 语言中使用，只要使用 _stdcall 关键字即可；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> stdio.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调试：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">00401000</span> <span class="keyword">PUSH</span> <span class="built_in">EBP</span>                       <span class="comment">; add() 函数</span></span><br><span class="line"><span class="number">00401001</span> <span class="keyword">MOV</span> <span class="built_in">EBP</span>, <span class="built_in">ESP</span>                   <span class="comment">; 函数栈帧</span></span><br><span class="line"><span class="number">00401003</span> <span class="keyword">MOV</span> <span class="built_in">EAX</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">SS</span>:[<span class="built_in">EBP</span>+<span class="number">8</span>]  <span class="comment">; 参数 2 拷贝到 EAX</span></span><br><span class="line"><span class="number">00401006</span> <span class="keyword">ADD</span> <span class="built_in">EAX</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">SS</span>:[<span class="built_in">EBP</span>+C]  <span class="comment">; 参数 1 加上参数 2，结果保存在 EAX</span></span><br><span class="line"><span class="number">00401009</span> <span class="keyword">POP</span> <span class="built_in">EBP</span>                        <span class="comment">; 恢复函数执行前的 EBP</span></span><br><span class="line">0040100A <span class="keyword">RETN</span> <span class="number">8</span>                         <span class="comment">; 恢复函数执行前的 ESP</span></span><br><span class="line"><span class="number">0040100D</span> <span class="keyword">INT3</span></span><br><span class="line">0040100E <span class="keyword">INT3</span></span><br><span class="line">0040100F <span class="keyword">INT3</span></span><br><span class="line"><span class="number">00401010</span> <span class="keyword">PUSH</span> <span class="built_in">EBP</span>                       <span class="comment">; main() 函数</span></span><br><span class="line"><span class="number">00401011</span> <span class="keyword">MOV</span> <span class="built_in">EBP</span>, <span class="built_in">ESP</span>                   <span class="comment">; 函数栈帧</span></span><br><span class="line"><span class="number">00401013</span> <span class="keyword">PUSH</span> <span class="number">2</span>                         <span class="comment">; 参数 2 压栈</span></span><br><span class="line"><span class="number">00401015</span> <span class="keyword">PUSH</span> <span class="number">1</span>                         <span class="comment">; 参数 1 压栈</span></span><br><span class="line"><span class="number">00401017</span> <span class="keyword">CALL</span> <span class="number">00401000</span>                  <span class="comment">; 调用 add() 函数</span></span><br><span class="line">0040101C <span class="keyword">POP</span> <span class="built_in">EBP</span>                        <span class="comment">; 恢复函数执行前的 EBP</span></span><br><span class="line"><span class="number">0040101D</span> <span class="keyword">RETN</span></span><br></pre></td></tr></table></figure>
<p>栈的清理工作由 add()函数最后的<code>RETN 8</code>命令来执行；<br><code>RETN 8</code>命令的含义为<code>RETN + POP 8 字节</code>，即返回后使 ESP 增加指定大小；<br>像这样在被调用者内部清理栈的方式即为 stdcall 方式；<br>stdcall 方式的好处是相对于每次调用函数都要使用<code>ADD ESP, xxx</code> 的 cdecl 方式代码尺寸小；<br>Win32 API 是使用 C 语言编写的，但使用的是 stdcall 方式，这是为了获得更好的兼容性，使 C 语言以外的其它语言也能直接调用 API；</p>
</li>
<li><p>fastcall<br>fastcall 方式与 stdcall 方式基本类似，但该方式通常会使用寄存器而非栈内存，去传递那些需要传递给函数的部分参数（前 2 个）；<br>如：函数有 4 个参数，则前 2 个参数分别使用 ECX 和 EDX 寄存器传递；<br>fastcall 相对于 stdcall 速度快，毕竟 CPU 访问寄存器要比内存快得多，但需要额外的系统开销来管理 ECX 和 EDX 寄存器；</p>
</li>
<li><p>不管采用哪种方式，通过栈来传递参数的基本概念是一样的；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的汇编指令</title>
    <url>/post/1025109479/</url>
    <content><![CDATA[<h3 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h3><h4 id="NOP"><a href="#NOP" class="headerlink" title="NOP"></a>NOP</h4><ul>
<li><code>NOP</code>：No Operation，不执行任何动作的指令，只消耗 CPU 时钟；</li>
<li>NOP 的机器码是<code>90</code>；</li>
<li>NOP 是空指令，就是没有操作，无操作；</li>
<li>使用 <code>NOP</code> 来填充指令执行后多出来的字节，而不是用<code>00</code>来填充；</li>
</ul>
<a id="more"></a>

<h4 id="PUSH-压入堆栈"><a href="#PUSH-压入堆栈" class="headerlink" title="PUSH 压入堆栈"></a>PUSH 压入堆栈</h4><p>PUSH 的用法：</p>
<ul>
<li><code>PUSH 0x1 / 0xF</code>：把十六进制数字压入堆栈顶部；</li>
<li><code>PUSH EAX / EBX</code>：把指定寄存器中的数据压入堆栈顶部；</li>
<li><code>PUSH [00401000]</code>：把指定内存地址中的数据压入堆栈顶部；</li>
</ul>
<h4 id="POP-弹出堆栈"><a href="#POP-弹出堆栈" class="headerlink" title="POP 弹出堆栈"></a>POP 弹出堆栈</h4><p>POP 的用法：</p>
<ul>
<li><code>POP EAX / EBX</code>：将堆栈顶部的内容弹出并放入指定的寄存器；</li>
</ul>
<h4 id="PUSHAD"><a href="#PUSHAD" class="headerlink" title="PUSHAD"></a>PUSHAD</h4><ul>
<li>通用寄存器指：EAX / ECX / EDX / EBX / ESP / EBP / ESI / EDI；</li>
<li>PUSHAD 保护现场 / 备份现场，将通用寄存器的数据自上而下依次压入堆栈，最后一个寄存器的数据处于堆栈顶部；</li>
<li>PUSHAD 是 32 位操作；</li>
<li><code>PUSHAD</code> 相当于是<code>PUSH EAX, PUSH ECX, PUSH EDX, PUSH EBX, PUSH ESP, PUSH EBP, PUSH ESI, PUSH EDI</code>八条命令的合集；</li>
</ul>
<h4 id="POPAD"><a href="#POPAD" class="headerlink" title="POPAD"></a>POPAD</h4><ul>
<li>通用寄存器指：EAX / ECX / EDX / EBX / ESP / EBP / ESI / EDI；</li>
<li>POPAD 还原现场，将堆栈顶部的数据依次弹出并自下而上依次填充到通用寄存器；</li>
<li>POPAD 是 32 位操作；</li>
<li><code>POPAD</code> 相当于是<code>POP EDI, POP ESI, POP EBP, POP ESP, POP EBX, POP EDX, POP ECX, POP EAX</code>八条命令的合集；</li>
</ul>
<h4 id="PUSHA"><a href="#PUSHA" class="headerlink" title="PUSHA"></a>PUSHA</h4><ul>
<li>PUSHA 和 PUSHAD 功能相同，用于备份现场；</li>
<li>PUSHA 是 16 位操作；</li>
<li><code>PUSHA</code> 相当于是<code>PUSH AX, PUSH CX, PUSH DX, PUSH BX, PUSH SP, PUSH BP, PUSH SI, PUSH DI</code>八条命令的合集；</li>
</ul>
<h4 id="POPA"><a href="#POPA" class="headerlink" title="POPA"></a>POPA</h4><ul>
<li>POPA 和 POPAD 功能相同，用于还原现场；</li>
<li>POPA 是 16 位操作；</li>
<li><code>POPA</code> 相当于是<code>POP DI, POP SI, POP BP, POP SP, POP BX, POP DX, POP CX, POP AX</code>八条命令的合集；</li>
</ul>
<h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h4><ul>
<li>MOV 本意为<code>move，移动</code>，但功能相当于复制/赋值；</li>
<li><code>MOV EAX, ECX</code>：两个操作数的长度必须相同；</li>
<li><code>MOV EAX, ECX</code>：复制<code>ECX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，4 字节操作；</li>
<li><code>MOV AX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>AX（第一个参数）</code>，2 字节操作；</li>
<li><code>MOV AL, CL</code>：复制<code>CL（第二个参数）</code>的数据到<code>AL（第一个参数）</code>，1 字节操作；</li>
<li><code>MOV [00402000], EAX</code>：复制<code>EAX（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，4 字节操作；</li>
<li><code>MOV [00402000], AX</code>：复制<code>AX（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，2 字节操作；</li>
<li><code>MOV [00402000], AH</code>：复制<code>AH（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，1 字节操作；</li>
</ul>
<h4 id="MOVSX"><a href="#MOVSX" class="headerlink" title="MOVSX"></a>MOVSX</h4><ul>
<li><code>MOVSX EAX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，如果<code>EAX（第一个参数）</code>的长度比<code>CX（第二个参数）</code>长，剩余的长度用<code>CX（第二个参数）</code>的符号位填充；</li>
<li>正数用 0 填充，负数用 F 填充；</li>
</ul>
<h4 id="MOVZX"><a href="#MOVZX" class="headerlink" title="MOVZX"></a>MOVZX</h4><ul>
<li><code>MOVZX EAX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，如果<code>EAX（第一个参数）</code>的长度比<code>CX（第二个参数）</code>长，剩余的长度用 0 填充；</li>
<li>带 0 扩展传送命令；</li>
</ul>
<h4 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h4><ul>
<li>LEA：复制<code>第二个参数的内存地址</code> 或 <code>第二个参数运算后的内存地址</code>到<code>第一个参数</code>；</li>
<li><code>LEA EAX, [00401000]</code>：第一个参数必须是通用寄存器，第二个参数必须是内存地址；</li>
<li><code>LEA EAX, [ECX + 16]</code>：第一个参数必须是通用寄存器，第二个参数必须是内存地址；</li>
</ul>
<h4 id="XCHG-互换-交换"><a href="#XCHG-互换-交换" class="headerlink" title="XCHG 互换 / 交换"></a>XCHG 互换 / 交换</h4><ul>
<li><code>XCHG EAX, ECX</code>：第一个参数可以是通用寄存器或内存地址，第二个参数必须是通用寄存器；</li>
<li><code>XCHG [00401000], ECX</code>：第一个参数可以是通用寄存器或内存地址，第二个参数必须是通用寄存器；</li>
</ul>
<h4 id="SHR-二进制右移"><a href="#SHR-二进制右移" class="headerlink" title="SHR 二进制右移"></a>SHR 二进制右移</h4><h4 id="SHL-二进制左移"><a href="#SHL-二进制左移" class="headerlink" title="SHL 二进制左移"></a>SHL 二进制左移</h4><h4 id="CLD"><a href="#CLD" class="headerlink" title="CLD"></a>CLD</h4><ul>
<li>用来操作方向标志位 DF，CLD 使 DF 复位，即让 DF = 00；</li>
</ul>
<h4 id="STD"><a href="#STD" class="headerlink" title="STD"></a>STD</h4><ul>
<li>用来操作方向标志位 DF，STD 使 DF 置位，即让 DF = 01；</li>
</ul>
<h3 id="数学指令"><a href="#数学指令" class="headerlink" title="数学指令"></a>数学指令</h3><h4 id="ADD-SUB-加法-减法"><a href="#ADD-SUB-加法-减法" class="headerlink" title="ADD / SUB | 加法 / 减法"></a>ADD / SUB | 加法 / 减法</h4><ul>
<li><code>ADD / SUB</code>的返回结果放在第一个参数中；</li>
</ul>
<h4 id="ADC-带进位的加法"><a href="#ADC-带进位的加法" class="headerlink" title="ADC 带进位的加法"></a>ADC 带进位的加法</h4><ul>
<li><code>ADC EAX, ECX</code> = <code>EAX + ECX + 0 | 1</code>：两个参数累加并且加上<code>进位标识符CF</code>的值为最终结果；</li>
</ul>
<h4 id="SBB-带进位的减法"><a href="#SBB-带进位的减法" class="headerlink" title="SBB 带进位的减法"></a>SBB 带进位的减法</h4><ul>
<li><code>SBB EAX, ECX</code> = <code>EAX - ECX - 0 | 1</code>：两个参数相减并且减去<code>进位标识符CF</code>的值为最终结果；</li>
</ul>
<h4 id="INC-DEC-自增-自减"><a href="#INC-DEC-自增-自减" class="headerlink" title="INC / DEC | 自增 / 自减"></a>INC / DEC | 自增 / 自减</h4><ul>
<li><code>INC EAX</code>：每执行一次该指令，参数的值自增 1；</li>
<li><code>DEC EAX</code>：每执行一次该指令，参数的值自减 1；</li>
</ul>
<h4 id="MUL-无符号乘法"><a href="#MUL-无符号乘法" class="headerlink" title="MUL 无符号乘法"></a>MUL 无符号乘法</h4><ul>
<li><code>MUL ECX</code>：<code>MUL CL | CX | ECX</code>默认和 <code>AL | AX | EAX</code>做乘法运算，运算结果分别存放到<br><code>AL | DX:AX | EDX:EAX</code>中，其中<code>DX 或 EDX</code>存放高位，<code>AX 或 EAX</code>存放低位；</li>
</ul>
<h4 id="DIV-无符号除法"><a href="#DIV-无符号除法" class="headerlink" title="DIV 无符号除法"></a>DIV 无符号除法</h4><ul>
<li><code>DIV CL</code>：默认的被除数为<code>EAX</code>，如果 <code>CL（除数）</code>是 8 位，那么<code>商</code>放在<code>AL</code>中，<code>余数</code>放在<code>AH</code>中；</li>
<li><code>DIV CX</code>：默认的被除数为<code>EAX</code>，如果 <code>CX（除数）</code>是 16 位，那么<code>商</code>放在<code>AX</code>中，<code>余数</code>放在<code>DX</code>中；</li>
<li><code>DIV ECX</code>：默认的被除数为<code>EAX</code>，如果 <code>ECX（除数）</code>是 32 位，那么<code>商</code>放在<code>EAX</code>中，<code>余数</code>放在<code>EDX</code>中；</li>
</ul>
<h4 id="IMUL-有符号乘法"><a href="#IMUL-有符号乘法" class="headerlink" title="IMUL 有符号乘法"></a>IMUL 有符号乘法</h4><ul>
<li>立即数：自然数；</li>
<li>单操作数：<code>IMUL CL | CX | ECX</code>默认和 <code>AL | AX | EAX</code>做乘法运算，运算结果分别存放到<br><code>AL | DX:AX | EDX:EAX</code>中，其中<code>DX 或 EDX</code>存放高位，<code>AX 或 EAX</code>存放低位；</li>
<li>双操作数：<code>IMUL AX, CX | 0x2</code>：第一个参数必须是通用寄存器，第二个参数可以是通用寄存器、内存地址或立即数，运算结果存放到第一个参数中；</li>
<li>三操作数：<code>IMUL AX, CX, 0x2</code>：第一个参数必须是通用寄存器，第二个参数可以是通用寄存器或内存地址，第三个参数必须是立即数，将第二个参数和第三个参数的运算结果存放到第一个参数中；</li>
</ul>
<h4 id="IDIV-有符号除法"><a href="#IDIV-有符号除法" class="headerlink" title="IDIV 有符号除法"></a>IDIV 有符号除法</h4><ul>
<li><code>IDIV CL</code>：默认的被除数为<code>EAX</code>，如果 <code>CL（除数）</code>是 8 位，那么<code>商</code>放在<code>AL</code>中，<code>余数</code>放在<code>AH</code>中；</li>
<li><code>IDIV CX</code>：默认的被除数为<code>EAX</code>，如果 <code>CX（除数）</code>是 16 位，那么<code>商</code>放在<code>AX</code>中，<code>余数</code>放在<code>DX</code>中；</li>
<li><code>IDIV ECX</code>：默认的被除数为<code>EAX</code>，如果 <code>ECX（除数）</code>是 32 位，那么<code>商</code>放在<code>EAX</code>中，<code>余数</code>放在<code>EDX</code>中；</li>
</ul>
<h4 id="XADD-先交换后相加"><a href="#XADD-先交换后相加" class="headerlink" title="XADD 先交换后相加"></a>XADD 先交换后相加</h4><ul>
<li><code>XADD EAX, ECX</code>：先交换两个参数的值，然后进行加法运算，运算结果保存在第一个参数中；</li>
</ul>
<h4 id="NEG-取反"><a href="#NEG-取反" class="headerlink" title="NEG 取反"></a>NEG 取反</h4><ul>
<li><code>NEG EAX</code>：如题，取反</li>
</ul>
<h3 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h3><h4 id="AND-OR-XOR-NOT"><a href="#AND-OR-XOR-NOT" class="headerlink" title="AND / OR / XOR / NOT"></a>AND / OR / XOR / NOT</h4><ul>
<li>全部以二进制形式进行比较 / 操作；</li>
<li><code>AND EAX, ECX</code>：双 1 为 1，否则为 0；</li>
<li><code>OR EAX, ECX</code>：逢 1 为 1，否则为 0；</li>
<li><code>XOR EAX, ECX</code>：不同为 1，相同为 0；</li>
<li><code>NOT EAX</code>：二进制取反；</li>
</ul>
<h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h4><ul>
<li><code>CMP EAX, ECX</code>：两个参数相减进行比较，如果运算结果为 0，则 <code>ZF（0 标志位）</code>为 1；</li>
<li>通用寄存器、内存地址和立即数之间可以相互比较；</li>
</ul>
<h4 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h4><ul>
<li><code>TEST EAX, EAX</code>：判断 EAX 自身是否为 0；</li>
<li>如果运算结果为 0，且 ZF（0 标志位）为 1，则说明 EAX 自身为 0；</li>
<li>与<code>AND</code>相同，仅改变标志位而不改变操作数的值，若 2 个操作数中的一个为 0，则运算结果为 0，ZF 置 1；</li>
</ul>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h4 id="JMP-无条件跳转"><a href="#JMP-无条件跳转" class="headerlink" title="JMP 无条件跳转"></a>JMP 无条件跳转</h4><ul>
<li><code>JMP 00401018</code>：无条件跳转；</li>
</ul>
<h4 id="JE-JZ"><a href="#JE-JZ" class="headerlink" title="JE / JZ"></a>JE / JZ</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>ZF（0 标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNE-JNZ"><a href="#JNE-JNZ" class="headerlink" title="JNE / JNZ"></a>JNE / JNZ</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>ZF（0 标志位）</code>为 0 则跳转；</li>
<li>与<code>JE / JZ</code>相反；</li>
</ul>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><ul>
<li><code>SF（符号位标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNS"><a href="#JNS" class="headerlink" title="JNS"></a>JNS</h4><ul>
<li><code>SF（符号位标志位）</code>为 0 则跳转；</li>
<li>与<code>JS</code>相反；</li>
</ul>
<h4 id="JP-JPE"><a href="#JP-JPE" class="headerlink" title="JP / JPE"></a>JP / JPE</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>PF（奇偶标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNP-JPO"><a href="#JNP-JPO" class="headerlink" title="JNP / JPO"></a>JNP / JPO</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>PF（奇偶标志位）</code>为 0 则跳转；</li>
<li>与<code>JP / JPE</code>相反；</li>
</ul>
<h4 id="JO"><a href="#JO" class="headerlink" title="JO"></a>JO</h4><ul>
<li><code>OF（溢出标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNO"><a href="#JNO" class="headerlink" title="JNO"></a>JNO</h4><ul>
<li><code>OF（溢出标志位）</code>为 0 则跳转；</li>
<li>与<code>JO</code>相反；</li>
</ul>
<h4 id="JB"><a href="#JB" class="headerlink" title="JB"></a>JB</h4><ul>
<li><code>CF（进位 / 借位 标志位）</code>为 1 则跳转；</li>
<li>JB 不关注符号位，只关注无符号位的运算；</li>
</ul>
<h4 id="JNB"><a href="#JNB" class="headerlink" title="JNB"></a>JNB</h4><ul>
<li><code>CF（进位 / 借位 标志位）</code>为 0 则跳转；</li>
<li>与<code>JB</code>相反；</li>
</ul>
<h4 id="JL"><a href="#JL" class="headerlink" title="JL"></a>JL</h4><ul>
<li><code>SF（）符号位标志位</code>为 1 则跳转；</li>
<li>与 JB 不同的是，JL 关注有符号位的运算；</li>
<li>JL 会忽略<code>CF（进位 / 借位 标志位）</code>的变化；</li>
</ul>
<h4 id="JBE"><a href="#JBE" class="headerlink" title="JBE"></a>JBE</h4><ul>
<li><code>OF（溢出标志位）为 1</code>或<code>ZF（0 标志位）为 0</code>则跳转；</li>
<li>小于等于；</li>
</ul>
<h4 id="JNBE-JA"><a href="#JNBE-JA" class="headerlink" title="JNBE / JA"></a>JNBE / JA</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>OF（溢出标志位）为 0</code>并且<code>ZF（0 标志位）为 1</code>则跳转；</li>
<li>必须是大于；</li>
</ul>
<h4 id="CALL-RETN"><a href="#CALL-RETN" class="headerlink" title="CALL / RETN"></a>CALL / RETN</h4><ul>
<li>CALL 可以理解为 CALLBACK；</li>
<li>CALL 会执行一个子程序，可以理解为执行了一个函数；</li>
<li>RETN 在 CALL 所执行的子程序中时，会返回该 CALL 所在的主程序，并继续向下执行；</li>
<li>RETN 与其他指令单独使用时，和 JMP 的功能相同；</li>
</ul>
<h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><ul>
<li><p>LOOP 相当于</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">XOR</span> <span class="built_in">ECX</span>, <span class="built_in">ECX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">ECX</span>, <span class="number">6</span></span><br><span class="line"><span class="keyword">DEC</span> <span class="built_in">ECX</span></span><br><span class="line"><span class="comment">; CMP ECX, 0</span></span><br><span class="line"><span class="keyword">TEST</span> <span class="built_in">ECX</span>, <span class="built_in">ECX</span></span><br><span class="line"><span class="keyword">JNZ</span> [<span class="keyword">DEC</span> <span class="built_in">ECX</span> 所在的地址]</span><br></pre></td></tr></table></figure></li>
<li><p>与以上指令不同的是：LOOP 执行时第一次循环计数器不会自减；</p>
</li>
<li><p>约定俗成：使用 ECX 作为计数器；</p>
</li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>直接寻址：指令后面直接写出此次运算使用的地址，称为直接寻址；</li>
<li>间接寻址：只有执行到某一行指令才能知道此次运算使用的地址，称为间接寻址；</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之 SFX 功能定位 OEP</title>
    <url>/post/3371155739/</url>
    <content><![CDATA[<blockquote>
<p>对壳一无所知的情况下，通过简单的操作完成程序的脱壳，从而增加成就感，获得学习的乐趣及动力；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li>加壳工具使用了<a href="https://upx.github.io/">UPX</a>，感谢 🙏 开源，以及 <a href="http://www.aspack.com/">ASPACK</a>：收费软件，可以试用；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h4><p>壳（也叫“外壳”）是一种专用加密软件技术；</p>
<p>壳分为：压缩壳、加密壳、虚拟机保护软件；</p>
<h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><ol>
<li><p>首先，将原始程序导入 OD，然后查看 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv7l4xkb9j31dp0u0jv3.jpg" alt="原始程序导入 OD"></p>
<p>可以看到，原始程序的 OEP 是：00401000；</p>
</li>
<li><p>安装 UPX，然后打开并给 CM 加壳：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv797t16ij31340u076k.jpg" alt="给 CM 加壳"></p>
<p>将 CM 拖入 UPX，选项默认，点击 RUN 即可；</p>
<p>不会生成新文件，而是直接在源程序上加壳，所以，记得备份源程序；</p>
</li>
<li><p>打开 OD 设置 SFX：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv7j8uzeuj31dx0u0n2e.jpg" alt="设置 SFX"></p>
<p>打开调试设置，在异常选项卡下，勾选全部选项，是为了防止 SFX 在自动分析中，中断在某个异常而导致失败；</p>
<p>然后，在 SFX 选项卡下，勾选 <code>块方式跟踪</code>或<code>字节方式跟踪</code>其一，它们的区别是查找速度与准确率，首先选择速度较快的<code>块方式跟踪</code>；</p>
</li>
<li><p>然后将加壳后的程序载入 OD，发现没有任何反应，即使切换 SFX 选项卡为<code>字节方式跟踪</code>也没有任何反应，这是为什么呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv7vp6yy2j31e30u0jut.jpg" alt="没有任何反应"></p>
</li>
<li><p>原来，SFX 使用是有限制的：程序在载入 OD 后，入口点必须位于代码段（.code）之外，才会生效；</p>
<p>打开内存窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv7xm4w2qj31e00u077c.jpg" alt="内存窗口"></p>
<p>发现当前程序的代码段起始位置为：00409000，大小为 1000，也就是说，当前程序代码段的范围是 00409000 ～ 00409FFF；</p>
<p>而程序载入 OD 后，EP（入口点）位于 00409BF0，处于代码段范围，所以 SFX 没有生效；</p>
</li>
<li><p>既然 UPX 加壳后入口点在代码段，那就切换加壳软件，使用 ASPACK；</p>
<p>安装 ASPACK 并打开，在打开文件选项卡下点击打开并选择原始程序，就会自动加壳：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv8e3edj4j30n80iat9g.jpg" alt="ASPACK"></p>
<p>ASPACK 同样不会生成新文件，所以，记得备份源程序；</p>
</li>
<li><p>首先，打开 OD 确认 SFX 以及异常选项卡设置 OK，然后将 ASPACK 加密后的程序导入 OD：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv8k4495oj31du0u0q6x.jpg" alt="ASPACK 加密后的程序导入 OD"></p>
<p>CM 运行起来了，然而，程序并非停留在 OEP 上，因为第 1 步的时候，已经确认了原始程序的 OEP 是：00401000；</p>
<p>看来 SFX 的<code>块方式跟踪</code>速度很快但是不够准确，不过，既然 CM 能够运行，也侧面说明了，ASPACK 加壳后，EP 位于代码段之外；</p>
</li>
<li><p>切换 SFX 选项为<code>字节方式跟踪</code>并删除 OD 操作日志（UDD 文件夹内），重新将 ASPACK 加密后的程序导入 OD：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnv8u6b8v9j31dy0u0wi4.jpg" alt="程序已脱壳"></p>
<p>此时 EP 停留在 00401000 上，也就 OEP 上，说明程序已经脱壳了；</p>
</li>
<li><p>加壳方式多种多样，这种脱壳方式可用范围应该很小，毕竟换了加壳工具后就失效了，不过，很振奋人心；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>SFX</tag>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之 VB 程序快速定位 OEP</title>
    <url>/post/69889928/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-19">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="http://www.aspack.com/">ASPACK</a>：收费软件，可以试用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>使用 ASPACK 给 CM 加壳；</p>
</li>
<li><p>将加壳后的 CM 导入 OD，然后来到内存窗口，找到 MSVBVM60.dll 的代码段，设置内存访问断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwh95tsoij31a30u0ad4.jpg" alt="MSVBVM60"></p>
<p>VB 程序有个特点：入口处都是一个 PUSH 指令，然后一个 CALL 指令，并且 CALL 指令中的 JMP 指向 MSVBVM60/50；</p>
<p>所以这里的思路就是：当外壳程序执行完毕，跳转至 OEP 时，程序会调用 MSVBVM60/50，所以，只要给 MSVBVM60/50 设置断点，然后跟随到调用位置，就到达 OEP 了；</p>
</li>
<li><p>设置好断点并<code>F9</code>运行程序，程序会中断在 MSVBVM60/50 的行首：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwi48xrnrj31a60u0adj.jpg" alt="中断在 MSVBVM60/50 的行首"></p>
<p>此时在栈窗口跟随到调用位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwicoomz0j31a50u0wi6.jpg" alt="调用位置"></p>
<p>这里，通过上面的函数列表就已经可以确定是 OEP，VB 程序的 OEP 基本类似，都是这种结构；</p>
</li>
<li><p>删除代码分析后，更加确定这里就是 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwi9wuc1ij31a40u0djm.jpg" alt="删除代码分析后"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>VB</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之修正 IAT</title>
    <url>/post/1928138386/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-25">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 OD 插件 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-1">OllyDump.dll</a>，来自互联网；</li>
<li>修正输出表的工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p>Import REConstructor（简称 ImportREC）是目前最好用的输入表重建工具，它可以从杂乱的 IAT 中重建一个输入表；</p>
<p>要运行 ImportREC，必须满足以下条件：</p>
<ul>
<li>目标文件已完全被 Dump 并保存为另外一个文件；</li>
<li>目标文件必须正在运行；</li>
<li>事先找到目标程序真正的 OEP 或知晓 IAT 的偏移量和大小；</li>
</ul>
<ol>
<li><p>将 CM 导入 OD，使用栈平衡法找到 OEP，并停留在 OEP（目标文件必须正在运行）；</p>
</li>
<li><p>使用 OllyDump 将内存数据 Dump 出来并保存至可执行文件（目标文件已完全被 Dump 并保存为另外一个文件）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0n79lxu4j31dt0u0jvk.jpg" alt="OllyDump"></p>
<p>在插件菜单选择 OllyDump 或右键菜单选择转存调试的进程都可以，然后确认 Dump 选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0n2xcja2j31e00u0djx.jpg" alt="Dump"></p>
<p>插件 Dump 数据方面没有问题，但重建 IAT 功能不够强大，因此，取消勾选重建输入表选项；</p>
</li>
<li><p>在 OD 中定位到 IAT，查看起始 RVA 以及结束 RVA，计算 Size：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0nfnw56mj310w0o8ta0.jpg" alt="Size"></p>
<p>在输入表中，一个 DLl 对应于一份 IAT，多个 IAT 之间一般以一个 DWORD 的 0 隔开；</p>
<p>此处 CM 的 IAT 之间被添加了无效信息；</p>
</li>
<li><p>用 ImportREC 打开 CM 进程，填写 OEP（RVA）以及 IAT 的起始地址（RVA）和大小，然后点击获取：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0no2nckij30we0oojsj.jpg" alt="ImportREC"></p>
<p>获取输入表后，可以看到有一组<code>valid：NO</code>的数据，这就是两个 IAT 之间的无效信息：</p>
<p>确认是无效信息后，在无效信息上右键菜单执行“Cut thunk(s)”命令：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0nzzqto3j31e10u0aeq.jpg" alt="Cut thunk(s)"></p>
<p>剔除无效信息后，数据还是不正确：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0o4b5w5kj31dy0u078u.jpg" alt="数据还是不正确"></p>
<p>因为 CM 中调用了 3 个 DLL，分别是 user32.dll、kernel32.dll 以及 ntdll.dll；</p>
<p>而 ImportREC 只找到了两个，看来这玩意儿也不好使啊；</p>
<p>NoNoNo，它找到了三个，但因为 ntdll 中的 API 混合在 kernel32 的 API 中，所以被替换了，看 log 窗口的提示信息；</p>
<p>此时如果直接修复 dump.exe，在当前环境（xp）下是可以运行的，但可能会在其它 OS 中遇到兼容性问题；</p>
<p>所以还需要修复 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0olk6qhmj31lk0qu0v8.jpg" alt="修复"></p>
<p>在获取的信息中，双击对应的 API，在弹出的函数编辑框中修改对应的 DLL 名称和 API 名称；</p>
<ul>
<li>查看 RVA 来获取对应的函数比较直观，如：00001200 和 00001210；</li>
<li>双击函数行打开函数编辑框；</li>
<li>在编辑框中首先选择 DLL 名称，然后可以在下面的输入框中搜索指定的函数名，接着选择函数，点击 OK 确认修改；</li>
<li>修改完成后，依然显示的是未修改的状态，但修复程序后，显示已修改；</li>
</ul>
<p>修改完成后，点击<code>Fix Dump</code>，选择需要修复的程序，完成修复：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0p1ijxbfj31e20u0ada.jpg" alt="完成修复"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>IAT</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之修复 IAT</title>
    <url>/post/452711586/</url>
    <content><![CDATA[<blockquote>
<p>之前尝试了手动修复 IAT，了解修复的原理后，本次记录使用工具修复的过程；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="https://upx.github.io/">UPX</a>，感谢 🙏 开源；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-3">PETools</a>，来自互联网；</li>
<li>修正输出表的工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>使用 UPX 加密 CM，然后导入 OD；</p>
</li>
<li><p>使用栈平衡法定位并跳转至 OEP，接下来在操作过程中不能关闭 OD 且程序需停留在 OEP 位置；</p>
</li>
<li><p>打开 PETools，将内存数据 Dump 出来并保存至可执行文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzu6nvencj31500u0tbv.jpg" alt="PETools"></p>
<p>默认保存为 dumped.exe；</p>
</li>
<li><p>打开 ImportREC 选择 CM 进程：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzuc3dogbj30wm0omgmq.jpg" alt="选择 CM 进程"></p>
<p>选择后，日志窗口会提示关联模块获取完成：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzudwpewvj30wo0omwfh.jpg" alt="关联模块获取"></p>
<p>然后在下方填写 dumped.exe 程序 OEP 的 RVA，以及 IAT 的起始位置（RVA）和尺寸：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzuqyt15wj31e40u00yt.jpg" alt="计算 RVA"></p>
<p>根据 VA 和 RVA 的转换公式计算如下（注意都是 16 进制哦）：</p>
<p>OEP 的 RVA = 401000 - 400000 = 1000；</p>
<p>IAT 的 RVA = 403184 - 400000 = 3184；</p>
<p>IAT 的 Size = 40328C - 403184 = 108；</p>
<p>填写 ImportREC 的选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzux3fy14j310u0ou75d.jpg" alt="填写 ImportREC"></p>
<p>然后点击<code>Get Imports</code>，开始获取输入表的内容：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzv149j6vj30wi0oqgn3.jpg" alt="获取内容"></p>
<p>获取完成后，需要检查获取的数据是否有效，如果 valid 为 NO，需要手动检查是否为无用信息，否则需要修正后重新获取；</p>
<p>接着点击<code>Fix Dump</code>选项，在弹出窗口选择 dumped.exe，用于修复；</p>
</li>
<li><p>修复后的程序可以正常运行，但导入 OD 后依然会提示入口点超出代码段范围：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzv6dfug9j313m06sjrl.jpg" alt="入口点超出代码段范围"></p>
<p>修改代码段的起始地址（RVA）即可：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnzvbrofegj31dm0u0gp3.jpg" alt="修改代码段的起始地址"></p>
<p>然后选中修改并保存到可执行文件，完工！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>IAT</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之内存访问定位 OEP</title>
    <url>/post/3449356463/</url>
    <content><![CDATA[<blockquote>
<p>OEP：当外壳保护的程序运行时，会先执行外壳程序，外壳程序负责在内存中把原程序解压、还原，并把控制权还给解压后的真正程序，再跳到原来程序的入口点，这个解压后真正程序的入口点称为 OEP（Original Entry Point，原始入口点）；</p>
<p>EP：与 OEP 对应的是 EP（Entry Point，入口点），无壳程序的 EP 与 OEP 相同，加壳程序的 EP 是壳的入口点，而不是原程序的入口点；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-23">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><h4 id="使用改版-OD-到达-OEP"><a href="#使用改版-OD-到达-OEP" class="headerlink" title="使用改版 OD 到达 OEP"></a>使用改版 OD 到达 OEP</h4><ol>
<li><p>此方法来自<a href="http://xuepojie.com/">SharkHeng</a>；</p>
</li>
<li><p>将 CM 导入 OD 后，会弹出警告，提示入口点超出代码段范围，这是因为当前 EP 指向外壳部分，而不是代码段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw2w2pc78j31cg06u0sz.jpg" alt="英文版"></p>
<p>再来个中文版（感谢汉化 OD 的大佬）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw2w4uhjmj312w06sdg1.jpg" alt="中文版"></p>
<p>虽然弹窗可以在 OD 设置中关闭，但弹窗也是一件好事儿，弹出这种窗口就是提示我们程序加壳了；</p>
</li>
<li><p>既然提示 EP 不在代码段，那就来到内存窗口，查看各区段范围：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw37zkq86j31a50u0aeh.jpg" alt="各区段范围"></p>
<p>可以看到，当前 EP 为 00413000，而代码段的范围是：00401000 ～ 00404FFF，确实不在这个范围，所以才会有一开始的弹窗；</p>
</li>
<li><p>在代码段（.text）设置内存访问断点，然后<code>F9</code>运行程序：</p>
<p>加壳程序在运行时，会将原程序解压、还原，控制权交还，然后原程序执行，此时，就会触发<code>内存执行断点</code>，从而产生中断；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw3gh6rdoj314w0iuq3l.jpg" alt="产生中断"></p>
<p>中断位置的代码看起来像是数据，不过很有规律，按下<code>Ctrl + A</code>，分析程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw3k3n4ftj31a00u0ad9.jpg" alt="分析程序"></p>
<p>分析之后的代码就正常了，开始位置是生成栈帧的指令，表示函数要开始执行了，而且，当前 EIP 也处于代码段；</p>
</li>
</ol>
<h4 id="使用原版-OD-到达-OEP"><a href="#使用原版-OD-到达-OEP" class="headerlink" title="使用原版 OD 到达 OEP"></a>使用原版 OD 到达 OEP</h4><ol>
<li><p>此方法来自<a href="https://bbs.pediy.com/forum-99.htm">加密解密</a>第 16 章：16.2.2；</p>
</li>
<li><p>将 CM 导入原版 OD，打开内存窗口，在代码段（.text）以及相邻的只读数据段（.rdata）设置<code>F2</code>断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw3usmmfwj31dv0u0771.jpg" alt="设置`F2`断点"></p>
<p>.rdata 设置的断点不是必须的，也可以在其它区段设置断点（外壳所在区段除外）；</p>
<p>此处设置断点的意义是：加壳程序运行时，会依次解压各区段，所以，对后面的其它区段设置断点，如果程序在 .text 中断后再次中断，说明代码段已解压完毕；</p>
</li>
<li><p>运行程序，首先中断在 .text：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw464c4ryj31dw0u00x9.jpg" alt="中断在 .text"></p>
<p>此时中断说明将要对代码段进行操作了；</p>
</li>
<li><p>再次运行程序，程序中断在 .rdata：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw48ao7ibj31dx0u0td5.jpg" alt="中断在 .rdata"></p>
<p>通过查看内存窗口知道，代码段的范围是：00401000 ～ 00404FFF；</p>
<p>而当前将要访问的位置是：00405000，不在代码段范围内，也就说明对代码段的操作结束了；</p>
</li>
<li><p>再次来到内存窗口，对代码段设置<code>F2</code>断点，然后运行程序：</p>
<p>这里设置断点的意义是：既然外壳对代码段的解压、还原已经结束了，如果再次访问代码段的话，就是程序执行的时候；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw4d6kf2lj31dw0u041w.jpg" alt="程序中断在 OEP"></p>
<p>中断位置与方法一一致；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之壳常用函数定位 OEP</title>
    <url>/post/1066637783/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-24">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><h5 id="GetProcAddress"><a href="#GetProcAddress" class="headerlink" title="GetProcAddress"></a>GetProcAddress</h5><ol>
<li><p>将程序导入 OD，goto 到 GetProcAddress 函数的行首，设置 F2 断点，然后运行程序；</p>
</li>
<li><p>程序中断在函数的行首，使用<code>shift + F4</code>设置条件记录断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx8nzo52ej319x0u041z.jpg" alt="设置条件记录断点"></p>
<p>表达式的值填写<code>[esp]</code>，表示获取 ESP 中的数据，同时勾选记录表达式的值以及函数参数选项；</p>
</li>
<li><p>清空 log 窗口，然后运行程序，条件记录断点会在 log 窗口记录每次调用 GetProcAddress 函数的调用地址及参数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx8ws8qugj31aa0u0acs.jpg" alt="记录每次调用"></p>
<p>通过查看内存窗口得知，外壳程序对 GetProcAddress 的最后一次调用位于：0047009A：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx939o7ifj31a80u0gou.jpg" alt="外壳程序的最后一次调用"></p>
</li>
<li><p>重载程序，编辑条件记录断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9ag1b3uj31a00u00vx.jpg" alt="编辑条件记录断点"></p>
<p>勾选<code>按条件中断</code>选项，同时将条件设置为<code>[ESP] == 0047009A</code>，表示当 ESP 的值为 0047009A 时中断；</p>
</li>
<li><p>运行程序后，程序中断在条件记录断点位置，来到内存窗口，给代码段设置内存执行断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9euqak5j31ok0e2jrz.jpg" alt="内存执行断点"></p>
</li>
<li><p>多次运行程序后，程序到达 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9k811k6j31a50u0tby.jpg" alt="程序到达 OEP"></p>
<p>这里需要运行太多次了，所以这种方法因程序而异，灵活使用；</p>
<p>其实，设置了内存执行断点后，就可以将条件访问断点取消了，取消之后就和异常法大同小异了，好处是可以绕过部分反调试；</p>
</li>
</ol>
<h4 id="ExitThread"><a href="#ExitThread" class="headerlink" title="ExitThread"></a>ExitThread</h4><p>因为本例中有终止线程的动作，且位于代码段之外，可以使用 ExitThread；</p>
<ol>
<li><p>将程序导入 OD，<code>F9</code>运行程序后，打开日志窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9vj0yquj30sa0eoaaj.jpg" alt="打开日志窗口"></p>
<p>可以看到，在一堆异常中，有一个线程结束日志，位于最后一次异常之前；</p>
</li>
<li><p>打开 OD 调试设置菜单，事件选项卡，选中<code>中断于线程结束</code>选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9z0mfyhj30q20lgdgc.jpg" alt="中断于线程结束"></p>
</li>
<li><p>重载并运行程序，程序中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnxa1y4w6uj319v0u0tcr.jpg" alt="提示信息"></p>
<p>看提示信息可以得知，中断原因是某个线程结束了；</p>
</li>
<li><p>在内存窗口，给代码段设置内存执行断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnx9k811k6j31a50u0tby.jpg" alt="程序中断在 OEP"></p>
<p>程序到达 OEP；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之壳的加载过程</title>
    <url>/post/1754370069/</url>
    <content><![CDATA[<blockquote>
<p>记录<a href="https://bbs.pediy.com/forum-99.htm">加密解密</a>一书中对<code>壳的加载过程</code>的描述，第 16 章：16.1；</p>
<p>眼过千遍，不如手过一遍；</p>
</blockquote>
<a id="more"></a>

<h4 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a>壳的加载过程</h4><p>加壳软件通过修改原程序执行文件的组织结构，从而使壳比原程序代码更早获得控制权，且不影响原程序的正常运行，以下是壳的常见加载过程:</p>
<ol>
<li><p>保存入口参数</p>
<p>加壳程序在初始化时会保存各寄存器的值，待外壳执行完毕，再恢复各寄存器的内容，最后跳到原程序执行，通常使用 PUSHAD/PUSHFD、POPAD/POPFD 指令来保存与恢复现场；</p>
</li>
<li><p>获取壳本身需要使用的 API 地址</p>
<p>在一般情况下，外壳的输入表中只有 GetProcAddress、GetModuleHandle 和 LoadLibrary 这 3 个 API 函数，甚至只有 Kernel32.dll 及 GetProcAddress；</p>
<p>如果需要使用其它 API 函数，可以通过函数 LoadLibraryA（W）或 LoadLibraryExA（W）将 DLL 文件映像映射到调用进程的地址空间中，函数返回的 HINSTANCE 值用于标识文件映像所映射的虚拟内存地址；</p>
<p>LoadLibrary 函数原型：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HINSTANCE LoadLibrary(</span><br><span class="line">    LPCTSTR lpLibFileName    // DLL 文件名地址</span><br><span class="line">     );</span><br></pre></td></tr></table></figure>
<p>返回值：成功则返回模块的句柄，失败返回 NULL；</p>
<p>如果 DLL 文件已经被映射到调用进程的地址空间中，可以调用 GetModuleHandleA（W）函数获取 DLL 模块的句柄；</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HMODULE GetModuleHandle(</span><br><span class="line">    LPCTSTR lpModuleName    // DLL 文件名地址</span><br><span class="line">     );</span><br></pre></td></tr></table></figure>
<p>返回值：成功则返回模块的句柄，失败返回 NULL；</p>
<p>一旦 DLL 模块被加载，线程就可以调用 GetProcAddress 函数获取输入函数的地址了；</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">    HMODULE hModule,        // DLl 模块句柄</span><br><span class="line">    LPCSTR  lpProcName      // 函数名</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>参数 hModule 是 DLL 模块的句柄，是调用 LoadLibrary（Ex） 或 GetModuleHandle 函数的返回值；</p>
<p>参数 lpProcName 是函数名或函数序数值，如果此参数是序数值，则必须使用低位字；高位必须为零；</p>
<p>返回值：成功则返回函数地址，失败返回 NULL；</p>
<p>在外壳中使用的其他函数都是由这 3 个函数调用的；</p>
<p>有些壳为了提高强度，连系统提供的 GetProcAddress 函数都不使用，而是自己实现一个相同功能的函数来代替 GetProcAddress，从而增加函数调用的隐蔽性；</p>
</li>
<li><p>解密原程序各区块的数据</p>
<p>出于保护原程序代码和数据的目的，壳一般会加密原程序文件的各个区段；</p>
<p>在程序执行时，外壳将解密这些区段数据，从而使程序能够正常运行；</p>
<p>壳一般是按区块加密的，所以解密时也按区块解密，并把解密的区块数据按照区块的定义放入内存中合适的位置；</p>
</li>
<li><p>IAT 的初始化</p>
<p>IAT 的填写本来应该由 PE 装载器实现，但由于在加壳时构造了一个自建输入表，并让 PE 文件头数据目录表中的输入表指针指向自建输入表，PE 装载器会对自建输入表进行填写；</p>
<p>程序的原始输入表会被外壳变形后存储，IAT 的填写会由外壳程序实现；</p>
<p>外壳程序要做的就是将这个变形输入表的结构从头到尾扫描一遍，重新获取每个 DLL 引入的所有函数的地址，并将其填写在 IAT 中；</p>
</li>
<li><p>重定位项的处理</p>
<p>文件执行时将被映射到指定内存地址中，这个初始内存地址称为基址，当然，这只是程序文件中声明的，当程序运行时，操作系统一定会满足其要求吗？</p>
<p>对 EXE 文件来说，操作系统会尽量满足其要求，如：程序声明的基址是 400000，操作系统提供的基址也是 400000，在这种情况下就不需要基址重定位了；</p>
<p>由于不需要对 EXE 文件进行重定位，加壳软件会删除原程序文件中用于保存重定位信息的区块，使加壳后的程序更小巧；</p>
<p>对 DLL 的动态链接库文件来说，操作系统无法保证 DLL 每次运行时都提供相同的基址，所以重定位就很重要了；</p>
<p>此时，壳中也要有用于重定位的代码，否则原程序将无法正常运行；</p>
<p>所以，加壳的 DLL 比加壳的 EXE 在修正时多了一个重定位表；</p>
</li>
<li><p>Hook API<br>在程序文件中，输入表的作用是让 Windows 操作系统在程序运行时将 API 的实际地址提供给程序使用，在程序的第 1 行代码执行前，Windows 操作系统就完成了这项工作；</p>
<p>壳大都在修改原程序的输入表后，自己模仿 Windows 操作系统的工作流程，向输入表中填充相关的数据，在填充过程中，外壳可以填充 Hook API 代码的地址，从而间接获得程序的控制权；</p>
</li>
<li><p>跳转到程序原始入口点（OEP）</p>
<p>从这个时候起，壳就把控制权还给原程序了，一般的壳在这里会有一条明显的分界线；</p>
<p>现在越来越多的加密壳先将 OEP 代码段搬到外壳的地址空间里，再将这段代码清除（这种技术称为“Stolen Bytes”），这样，OEP 与外壳之间那条明显的分界线就消失了，脱壳的难度也增加了；</p>
</li>
</ol>
<h4 id="脱壳机"><a href="#脱壳机" class="headerlink" title="脱壳机"></a>脱壳机</h4><p>针对特定的壳开发出来的脱壳软件称为“脱壳机”；</p>
<p>脱壳就是将加壳后的程序恢复到原来的状态，脱壳成功的标志是文件能正常运行；</p>
<p>由于脱壳时可能没有将壳本身的代码去除，脱壳后程序的体积通常会比原程序的体积大；</p>
<p>脱壳机一般分为专用脱壳机和通用脱壳机；</p>
<p>专用脱壳机是针对某种壳专门编写的，只能脱特定的壳，虽然使用范围小，但效果好；</p>
<p>通用脱壳机具有通用性，可以脱多种不同类型的壳（主要是压缩壳）；</p>
<p>在分析一个软件前，可以使用 PEiD 确定壳的种类，再选择合适的脱壳机；</p>
<h4 id="手动脱壳"><a href="#手动脱壳" class="headerlink" title="手动脱壳"></a>手动脱壳</h4><p>对一些加密壳或修改的壳，没有脱壳机，因此必须要分析外壳并手动脱壳；</p>
<p>手动脱壳过程一般分为 3 步：</p>
<ol>
<li>查找真正的程序入口点（OEP）；</li>
<li>抓取内存映像文件；</li>
<li>重建 PE 文件；</li>
</ol>
<p>当程序执行时，外壳代码首先获得控制权，模拟 Windows 加载器，将原程序恢复到内存中，这时，内存中的数据就是加壳前的映像文件了，适时将其抓取并修改，即可还原到加壳前的状态；</p>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之小练习</title>
    <url>/post/2471182341/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-24">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-3">PETools</a>，来自互联网；</li>
<li>修正输出表的工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-4">ImportREC</a>，来自互联网；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><ol>
<li><p>将 CM 导入 OD，使用内存访问法定位 OEP（这种方式设置的断点是一次性的）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0wlp01l2j31dz0u0diq.jpg" alt="F2 断点"></p>
<p>原理是：加壳程序运行时，会依次解压各区段，所以，访问后会中断；</p>
</li>
<li><p>运行程序后，程序中断两次：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0woppgmtj31e00u0jv3.jpg" alt="第一次重点"></p>
<p>中断后查看提示信息，程序访问了代码段，所以触发了断点，再次运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0wqml26dj31e30u0djj.jpg" alt="第二次中断"></p>
<p>程序再次中断，程序访问了第 2 个设置断点的区段，此时说明代码段已经解压完成了；</p>
</li>
<li><p>再次来到内存窗口，给代码段设置 F2 断点，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0wve0v2wj31e60u041p.jpg" alt="再次设置断点"></p>
<p>原理是：既然代码段已经解压完毕了，如果再次访问，就是原程序运行的时候；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0x0nx0ndj31e00u0q7e.jpg" alt="到达 OEP"></p>
<p>从模块中删除分析后，就可以看到程序的本来面目了；</p>
</li>
<li><p>然后打开 PETools，选择当前 CM 进程，右键菜单选择完整转存并保存到可执行文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0x64np0kj314y0u0adf.jpg" alt="PETools"></p>
</li>
<li><p>回到 OD，定位到 IAT，查看 IAT 起始位置（RVA）及结束位置（RVA），计算 Size：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0x9gmecfj31dt0u0q6v.jpg" alt="定位到 IAT"></p>
<p>通过 GetVersion 函数的地址，定位到 IAT；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xenogn6j31e10u0jvs.jpg" alt="计算 RVA"></p>
<p>通过计算得知：</p>
<ul>
<li>OEP 的 RVA 为：271B0；</li>
<li>IAT 的 起始地址 RVA 为：60818；</li>
<li>IAT 的 Size 为：60F28 - 60818 = 710（Hex）；</li>
</ul>
</li>
<li><p>打开 ImportREC 填写相关选项并获取：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xk307itj30wi0oqt9p.jpg" alt="填写选项"></p>
<p>获取完成后，检查获取的数据：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xlkacwwj30wi0oo3zu.jpg" alt="检查"></p>
<p>手动或通过显示无效选项检查获取数据是否有效；</p>
<p>确认无误后点击修复转存按钮，选择转存的程序，就完成修复了；</p>
</li>
<li><p>将修复后的程序导入 OD，查看 log 窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xswrszgj31dy0u0ju8.jpg" alt="log"></p>
<p>没有异常，说明程序正常运行；</p>
<p>然后定位到 IAT，随便选择一个函数，右键菜单查看可执行文件，到达函数 IMAGE_THUNK_DATA 结构体；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0xuvyplsj31e50u00wl.jpg" alt="查看可执行程序"></p>
<p>这里存放的是函数名字符串的 RVA，<code>Ctrl + G</code>跳转到 VA 查看函数名字符串；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1go0y4g6n1sj31dy0u0wlb.jpg" alt="确认 IAT"></p>
<p>确认函数名和 IAT 显示的函数名一致，脱壳完成；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之异常法定位 OEP</title>
    <url>/post/2614075303/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-24">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>拿到 CM 后，第 1 想法就是栈平衡，将 CM 导入原版 OD：</p>
<p>首先弹出警告弹窗，说明程序有壳（这不是废话嘛）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwou1dw2sj31eb0u0n0j.jpg" alt="将 CM 导入原版 OD"></p>
<p>然后到达 EP 位置，行首却不是 PUSHAD/PUSHFD，这就让人很尴尬了，不过又想到了栈平衡的第 2 种方法；</p>
</li>
<li><p>大胆的猜测一下，如果 OEP 行首是压栈指令，那么压栈的地址就是：0012FFC0:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwp0hlhrej31eg0u0aez.jpg" alt="压栈的地址"></p>
<p>所以，给 0012FFC0 设置硬件写入断点，然后运行程序；</p>
</li>
<li><p>程序会中断两次，第 2 次才会到达 OEP，因为第 2 中断时才处于代码段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwp87zzrwj31e70u043k.jpg" alt="OEP"></p>
</li>
<li><p>然后又尝试了设置访问断点来到达 OEP，两种方法皆是可行的，不过这 3 种方法并不是今天的重点；</p>
</li>
<li><p>将程序导入改版 OD，<code>F9</code>运行程序，待程序主窗体出现后，打开日志窗口（请不要关闭程序主窗体）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwpf8lzy7j31a80u0diy.jpg" alt="一大堆异常"></p>
<p>来到日志窗口后，发现程序运行期间，有一大堆异常，但程序却正常运行了，很是奇怪；</p>
</li>
<li><p>程序可以正常运行，是因为 OD 的调试选项忽略了所有异常，如果不忽略异常，程序会在每一次异常时暂停，而在最后一次异常后，程序正常运行了；</p>
<p>如果在最后一次异常时（也可以说是程序运行前）给代码段设置内存访问断点，是否可以到达 OEP 呢？</p>
</li>
<li><p>首先设置 OD 调试选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwpwb6stlj31ab0u077r.jpg" alt="不忽略异常"></p>
<p>在日志窗口可以看到，最后一次异常是 INT3，所以取消忽略 INT3 异常，同时取消忽略异常范围选项，因为从 00000000 ～ FFFFFFFF 就忽略了所有异常；</p>
</li>
<li><p>然后运行程序，在几次中断后，就来到了最后一次异常所在位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwq3u0p0fj31a50u00wx.jpg" alt="最后一次异常"></p>
</li>
<li><p>来到内存窗口，给代码段设置<code>内存执行断点</code>，然后按下<code>Shift + F9</code>忽略异常并运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwq6yj16mj31a50u077g.jpg" alt="OEP"></p>
<p>程序到达 OEP，Perfect！</p>
</li>
<li><p>既然有那么多方法，问什么要用这么复杂的方法呢？</p>
<p>是因为，加壳不仅可以隐藏 OEP，还可以反调试，而为了绕过反调试，在执行部分代码后，再设置断点相对会更安全，这是一种好的思路；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之栈平衡原理定位 OEP</title>
    <url>/post/810738268/</url>
    <content><![CDATA[<blockquote>
<p>加壳软件必须保证外壳初始化的现场环境（各寄存器的值）与原程序的现场环境是相同的；</p>
<p>加壳后的程序在初始化时保存各寄存器的值，待外壳执行完毕再恢复各寄存器的内容，最后跳转到原程序执行；</p>
<p>通常，加壳后的程序在开始时使用 PUSHAD/PUSHFD 来保护现场，外壳执行完毕后，使用 POPAD/POPFD 恢复现场；</p>
<p>也就是说，加壳软件必须遵守栈平衡原理；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="https://upx.github.io/">UPX</a>，感谢 🙏 开源；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ol>
<li><p>首先，使用 UPX 压缩 CM；</p>
</li>
<li><p>将加壳后的 CM 导入 OD 后，查看 EP 以及 ESP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw6ny7gdpj31dy0u0n1f.jpg" alt="查看 EP 以及 ESP"></p>
<p>EP 处使用 PUSHAD 备份当前各通用寄存器的值，然后将会在外壳执行完毕后再使用 POPAD 恢复各寄存器的值，以保证程序到达 OEP 时，寄存器的内容保持不变；</p>
<p>此时 ESP 的值为：0012FFC4；</p>
</li>
<li><p><code>F7</code>单步执行程序，也就是执行<code>PUSHAD</code>指令后，8 个通用寄存器的内容压入栈：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw6w8i7qej31dw0u0n1f.jpg" alt="通用寄存器的内容压入栈"></p>
</li>
<li><p>加壳程序必须遵守栈平衡原理，所以在执行完毕后，一定会访问栈以恢复各寄存器的内容，所以给处于栈中的任意寄存器内容设置硬件访问断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw766d18oj31e00u0wjp.jpg" alt="硬件访问断点"></p>
<p>这里以 EAX 寄存器的内容为例，使用<code>HR 12FFC0</code>，设置硬件访问断点；</p>
<p>设置完毕后，可以在调试菜单，硬件断点选项下看到已经设置的硬件断点；</p>
</li>
<li><p>运行程序后， 程序中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw7dshoraj31du0u0wje.jpg" alt="程序中断"></p>
<p>中断位置的 POPAD 访问了保存在栈中的寄存器内容，触发了断点；</p>
<p>同时，各寄存器已经恢复到 EP 时的状态，ESP 重新指向 0012FFC4，说明栈中保存的内容被丢弃了，使用后释放，这就是堆栈平衡；</p>
</li>
<li><p><code>F7</code>单步执行程序，程序跳转到 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw7lk3f4oj31du0u0q6p.jpg" alt="OEP"></p>
<p>此时各寄存器的内容以及 ESP 的值与程序处于 EP 时保持一致；</p>
</li>
<li><p>可以把整个外壳理解为一个函数或子程序，在执行过程中会遵守栈平衡原理，所以当外壳执行完毕跳转到 OEP 时，ESP 的值保持不变；</p>
</li>
</ol>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><ol>
<li><p>大多数程序 OEP 的第 1 行指令都是压栈指令（PUSH）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw7w7ivrjj31e30u0teo.jpg" alt="都是压栈指令（PUSH）"></p>
</li>
<li><p>向栈压入数据时，栈指针减小，向低地址移动；从栈中弹出数据时，栈指针增加，向高地址移动；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw832cqgjj31ds0u0wiq.jpg" alt="向栈压入数据时"></p>
<p>以当前 CM 为例，执行<code>PUSH 0</code>后，ESP 由 0012FFC4 指向 0012FFC0，地址减小了，这是程序到达 OEP 后执行的第 1 条指令；</p>
</li>
<li><p>反向思考一下，如果给 0012FFC0 设置写入断点，是不是就可以到达 OEP？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw8bcwefcj31du0u079d.jpg" alt="设置硬件写入断点"></p>
<p>将程序载入 OD 后，程序停留在 EP 位置，此时的 ESP 为 0012FFC4，根据栈平衡原理，外壳执行完毕后，ESP 保持不变，所以，OEP 的第 1 条 PUSH 指令，会将内容写入 0012FFC0（向栈压入数据时，栈指针减小，向低地址移动）；</p>
<p>确定写入地址后设置硬件写入断点<code>HW 0012FFC0</code>；</p>
</li>
<li><p>运行程序后，程序中断在代码段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnw8jjzzdlj31dy0u0q7q.jpg" alt="程序中断在代码段"></p>
<p>可以看到，由于<code>PUSH 0</code>指令向 0012FFC0 写入内容，从而触发了硬件写入断点，导致中断，而这里就是 OEP；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之编译语言特点定位 OEP</title>
    <url>/post/4132012963/</url>
    <content><![CDATA[<blockquote>
<p>各类语言编译的文件入口点都有自己的特点；</p>
<p>使用同一种编译器编译的程序，其入口代码都很类似，都有一段启动代码，编译器在编译程序时会自动与程序连接；</p>
<p>在完成必需的初始化工作后，调用 WinMain 函数，该函数执行完毕，启动代码将再次获得控制权，进行初始化清除工作；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="https://upx.github.io/">UPX</a>，感谢 🙏 开源；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>将 CM 导入 OD，此时未加壳，EP 即是 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnxboon3q2j31ek0u00we.jpg" alt="EP 即是 OEP"></p>
<p>可以看到， 第 1 个调用的函数是<code>GetModuleHandleA</code>；</p>
</li>
<li><p>使用 UPX 加密 CM，然后导入 OD：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnxbruvqiuj31e40u0420.jpg" alt="使用 UPX 加密 CM"></p>
<p>在 EP 处使用<code>Ctrl + G</code>跳转至 GetModuleHandleA 函数的行首，然后设置 F2 断点；</p>
</li>
<li><p>运行程序后，程序中断在断点位置，goto 到栈顶指针指向的位置，就到达了 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnxbwwuu6uj31e60u00xa.jpg" alt="到达了 OEP"></p>
</li>
<li><p>如果对常见语言的入口代码比较熟悉，就可以很容易的完成脱壳修复或定位 OEP 等工作，这就需要大量积累了；</p>
</li>
<li><p>由于采用默认的启动代码对软件进行加壳保护不是很有利，一些开发人员会对启动源代码进行修改，这时程序的入口点与默认的就完全不同了；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>OEP</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（一）</title>
    <url>/post/1969921723/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-10">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7morb9trj3087083mx8.jpg" alt="打开"></p>
<ul>
<li>ID 不可输入，应该是根据电脑硬件的某些特征生成的；</li>
<li>输入随机注册码点击 Check 之后，没有任何反馈；</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>既然程序有输入，有按钮，那可用的 API 可就多了。按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，用的<code>API</code>不多，一眼就看到了<code>GetWindowTextA</code>，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，嘿嘿，程序窗口一闪而过，而且<code>OD</code>的右下角也显示了程序的状态：<code>已终止</code>，;</p>
</li>
<li><p>如果说程序损坏的话，那么刚开始的时候应该也是打不开的；</p>
</li>
<li><p>如果说<code>OD</code>出现了问题，那么程序应该倒入不进来，而且查看不了 API 列表；</p>
</li>
<li><p>到底是什么问题呢？不绕弯子，程序有反调试，至于是如何反调试的？它就是今天的主角儿<code>IsDebuggerPresent</code>:</p>
<ul>
<li><p>先了解一下这个 API：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IsDebuggerPresent</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">     确定调用进程是否由用户模式的调试器调试。</span><br><span class="line"> 返回值</span><br><span class="line">     如果当前进程运行在调试器的上下文，返回值为非零值。</span><br><span class="line">     如果当前进程没有运行在调试器的上下文，返回值为零。</span><br></pre></td></tr></table></figure>
<p>看着好绕，大白话：检测当前程序是否正在被调试，没有被调试返回 0，只要返回值不是 0，那就表示程序正在被调试；</p>
</li>
</ul>
</li>
<li><p>既然知道它是一个 Windows API，那我们不妨按下<code>Ctrl + N</code>去函数列表看看这个程序是否调用了<code>IsDebuggerPresent</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7nnd0jurj316d0n974i.jpg" alt="API"></p>
<p>果然，在函数列表中发现了<code>IsDebuggerPresent</code>，不过，怎么证明它被调用了，而不是放在函数列表中迷惑我们呢？</p>
</li>
<li><p>很简单，给它设置一个断点，然后运行程序，没有意外，程序中断了，那就说明程序调用了这个 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7o1rwvmpj316b0n8dgl.jpg" alt="中断"></p>
<p>我们都知道<code>API 断点</code>会中断在函数的行首，也就是说，<code>IsDebuggerPresent</code>这个函数并没有执行，如果<code>Ctrl + F9</code>执行到返回，这个函数才算执行完毕了，而一旦它执行完毕，就意味着程序是否被调试它已经检测完成了，但从代码上看，只有区区 4 行，它是如何检测的呢，分析一下；</p>
</li>
<li><p>分析一下这 4 行代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOVZX</span> <span class="built_in">EAX</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">2</span>]   <span class="comment">; 将 EAX 中的地址，存储的第 2 个字节的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>
<p>嘛意思？往下分析；</p>
<ul>
<li><p><code>FS:[18]</code>中的<code>FS 寄存器</code>的地址是什么呢？</p>
<p><code>SF 标志位</code>指向<code>FS 寄存器</code>的地址；</p>
</li>
<li><p>开始分析代码，先是第 1 行代码<code>MOV EAX,DWORD PTR FS:[18]</code>：将<code>FS:[18]</code>中的地址拷贝到 <code>EAX</code>；</p>
<blockquote>
<p><code>FS 寄存器</code>从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 位存放的是起始位置的地址；</p>
</blockquote>
<p>对这句话很困惑？那我们按下<code>Ctrl + G</code>跟随一下这个地址，在这里，我的机器上，<code>FS</code>的地址是<code>7FFDF000</code>，那<code>FS:[18]</code>的地址就显而易见了，是<code>7FFDF018</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7pi19cnvj316d0nz0ua.jpg" alt="FS"></p>
<p><code>FS:[18]</code>的地址是<code>7FFDF018</code>，按下<code>F7</code>，单步执行代码，同时查看<code>EAX 寄存器</code>，丝毫不差，<code>FS:[18]</code>存放的正是<code>FS 寄存器</code>的起始地址<code>7FFDF000</code>，既然第 1 行代码搞定，那就开始分析第二行；</p>
</li>
<li><p>第 2 行代码<code>MOV EAX,DWORD PTR DS:[EAX+30]</code>：将 EAX 中的地址加 0x30 之后的地址拷贝到<code>EAX</code>；</p>
<p>与上一步相同，按下<code>Ctrl + G</code>跟随<code>7FFDF030</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7puc1wkhj316e0o0ta1.jpg" alt="加30"></p>
<p>没有意外，运行结果与我们分析的一致：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7pzqqa7hj316f0o0t9r.jpg" alt="运行后"></p>
</li>
<li><p>第 3 行代码<code>MOVZX EAX,BYTE PTR DS:[EAX+2]</code>：将 EAX 中的地址，存储的第 2 个字节的数据拷贝到 EAX；</p>
<p>跟随一下这个地址，看看它存储的是什么内容：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7q63xhhtj316c0ncwfo.jpg" alt="数据"></p>
<p>它存储的数据很简单，第二个字节是<code>01</code>，而根据<code>没有被调试返回 0，只要返回值不是 0，那就表示程序正在被调试</code>这句话来看，很明显，它检测到我们正在调试程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7q9nu35cj316b0nzgmb.jpg" alt="返回"></p>
<p>至此，恍然大明白，原来这 4 行代码就可以检测程序有没有被调试，至于为什么这里存放的是<code>01</code>这个数据，不得而知；</p>
</li>
<li><p>顺带提一嘴，如果程序倒入<code>OD</code>没有运行，那么<code>EBX 寄存器</code>指向的地址就是以上三行代码执行后需要取出数据的地址，也就是存放 01 的地址；</p>
</li>
</ul>
</li>
<li><p>既然已经明白了它是如何检测的以及知道了它的返回值，那如何绕过呢？</p>
<p>当然是修改返回值，也就是<code>EAX 寄存器</code>的值喽，没有调试返回 0，那返回 0 就是没有调试；</p>
</li>
<li><p>原理也明白了，也能绕过了，那么，它检测到程序被调试后，是如何退出程序的呢？意犹未尽；</p>
<p>不修改返回值，跟随一下<code>RETN</code>，看看它接下来会做什么？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7qkxbg5mj31690nbq3n.jpg" alt="退出消息"></p>
<p>哦豁，它用<code>PostQuitMessage</code>提交了退出消息，接着跟；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7qpagltqj316a0ncwf9.jpg" alt="退出进程"></p>
<p>然后，调用退出进程函数<code>ExitProcess</code>，再运行一下下，结束！</p>
</li>
<li><p>由于本文重点是了解反调试，那么分析找到对应用户名的序列号之后就到此为止吧；</p>
</li>
<li><p>至于序列号的算法，既然用户名都是计算出来的，那肯定是软编码喽；不过，换个角度，在机器没有任何变动的情况下，相对于这台机器，它是硬编码；</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（三）</title>
    <url>/post/140693809/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><code>OD</code>补丁程序<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-6">re-pair</a>；</li>
<li>类名检测工具<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-7">Greatis WinDowse</a>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-12">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>依然是学习完毕后的总结；</p>
</li>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk4zdntwnj306u05wjrb.jpg" alt="打开软件"></p>
<p>如果没有打开<code>OD</code>，程序可以打开并显示如上，如果打开了<code>OD</code>，程序则无法打开；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先，<code>Ctrl + N</code>查看一下 API 列表，很意外，出奇的干净，只有区区两个 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk4yoy6d9j31ff0u0dov.jpg" alt="API列表"></p>
<p>还好有一个我们认识的<code>ExitProcess</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExitProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    结束调用的进程及其所有的线程；</span><br></pre></td></tr></table></figure>
<p>那就只能从它下手了：设置 CC 断点并设置好备注；</p>
</li>
<li><p>接着，运行程序，程序会中断在我们设置的断点<code>ExitProcess</code>函数的行首，然后在<code>堆栈窗口</code>右键<code>反汇编窗口中跟随</code>来到调用这个函数的位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk4zzxwewj31ff0u0145.jpg" alt="反汇编窗口中跟随"></p>
<p>这里很困惑？困惑的同学没学懂，再复习一下 API 吧；</p>
<p>常规操作是：<code>Ctrl + F9</code>执行到返回，然后看它获取的数据，再进行下一步操作；</p>
<p>然鹅，别忘了<code>ExitProcess</code>的功能：结束进程及其所有的线程。</p>
<p>如果我们<code>Ctrl + F9</code>执行到返回，是不是意味着我们手动执行了结束进程的函数，那么，这个断点的意义是什么？</p>
<p>所以，我们要跟随函数到调用它的地方，往上看，为什么要调用它？</p>
</li>
<li><p>来到<code>反汇编窗口</code>，发现调用位置的同时，也发现了很多 API，其中大部分都不认识，但是有一根救命稻草<code>GetProcAddress</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk50duycnj31ff0u014a.jpg" alt="反汇编窗口"></p>
<p>既然 API 列表没有内容的同时发现了<code>GetProcAddress</code>，那是不是说明，大多数函数都被隐藏了，而<code>GetProcAddress</code>就是关键呢？</p>
<p>再来复习一下<code>GetProcAddress</code>的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetProcAddress</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定的动态链接库中的输出库函数地址；</span><br><span class="line">    （获取函数列表中不显示且被调用的隐藏函数的地址；）</span><br><span class="line">    （捕捉间接加载或调用的其他隐藏函数；）</span><br><span class="line">参数</span><br><span class="line">    hModule：包含此函数的 DLL 模块的句柄；</span><br><span class="line">    （程序的句柄）</span><br><span class="line">    IpProcName：包含函数名的以 NULL 结尾的字符串；</span><br><span class="line">    （程序的名字）</span><br></pre></td></tr></table></figure>
<p>毫无疑问，给<code>GetProcAddress</code>设置断点并做好备注，看看都有哪些隐藏的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk50u2kmtj31ff0u07fg.jpg" alt="GetProcAddress"></p>
</li>
<li><p>然后重载并运行程序后程序会中断，接着多次运行直到中断在了<code>ExitProcess</code>后，发现只是调用了以下隐藏函数：<code>CreateToolhelp32Snapshot</code> <code>OpenProcess</code> <code>Process32First</code> <code>Process32Next</code> <code>TerminateProcess</code> <code>lstrcmpA</code> <code>FindWindowA</code>；</p>
<ul>
<li><p>其中，<code>OpenProcess</code> <code>TerminateProcess</code> <code>lstrcmpA</code>很熟悉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知 PID 获取程序的句柄；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TerminateProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过进程句柄终止指定进程及其所有线程；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lstrcmpA</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    区分大小写的字符串比较；</span><br><span class="line"></span><br><span class="line">lstrcmpi</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    不区分大小写的字符串比较；</span><br></pre></td></tr></table></figure></li>
<li><p>至于其他几个，需要学习一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateToolhelp32Snapshot</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    给所有进程的详细信息拍摄快照，返回快照句柄供其他 API调用；</span><br><span class="line">参数</span><br><span class="line">    dwFlags：用来指定“快照”中需要返回的对象；</span><br><span class="line">    th32ProcessID：指定将要快照的进程ID；</span><br><span class="line">        - 该参数只有在dwFlags设置了TH32CS_SNAPHEAPLIST或者TH32CS_SNAPMODULE后才有效；</span><br><span class="line">        - 该参数为 0 则获取当前进程快照；</span><br><span class="line">        - 其他情况下参数会被忽略，所有的进程都会被快照；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process32First</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    获取进程快照第一个进程的句柄；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process32Next</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    获取进程快照下一个进程的句柄；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FindWindowA</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">    lpClassName：指向类名的字符串或一个可以确定类名字符串的原子；</span><br><span class="line">    lpWindowName：指向窗口名（即窗口标题）的字符串；</span><br><span class="line">作用</span><br><span class="line">    检索并处理顶级窗口的类名和窗口标题匹配指定的字符串；</span><br><span class="line">    不搜索子窗口；</span><br><span class="line">    不区分大小写；</span><br><span class="line">    如果有指定的类名或窗口标题则表示成功返回一个窗口的句柄；否则返回零；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>了解这些 API 后，重载并运行程序，程序中断后，分别给这些 API 设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk518c8dvj31ff0u012g.jpg" alt="设置断点并做好备注"></p>
<p>至于断点及备注的设置方法，请翻阅上一篇文章；</p>
</li>
<li><p>设置好所有断点后，再次运行程序，发现程序并不是和刚才一样中断在<code>ExitProcess</code>，而是中断在新设置的断点<code>CreateToolhelp32Snapshot</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk51l5855j31ff0u0alh.jpg" alt="CreateToolhelp32Snapshot"></p>
<ul>
<li><p>根据<code>CreateToolhelp32Snapshot</code>的用法，发现它的参数<code>Flags</code>并不是<code>TH32CS_SNAPHEAPLIST 或 TH32CS_SNAPMODULE</code>二者中的任何一个，那么它的参数将被忽略，所以，在这里它会获取所有进程的快照，并返回快照的句柄供其他 API 调用；</p>
</li>
<li><p>接着，<code>Ctrl + F9</code>执行到返回，在<code>EAX</code>中有一个返回值，那么它是不是一个句柄呢？去<code>句柄窗口</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk51xpoxlj31ff0u0gw9.jpg" alt="句柄窗口有"></p>
<p>可以看到，<code>句柄窗口</code>有一个相同的句柄，结果不言而喻；</p>
</li>
</ul>
</li>
<li><p>继续运行程序，程序再次中断，这次是中断在<code>Process32First</code>：</p>
<ul>
<li><p>可以看到，它要获取的第一个进程的句柄是<code>hSnapshot = 00000038</code>，而它的第二参数是一个指向进程详细信息的指针，<code>数据窗口</code>中跟随一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk52gpq0qj31ff0u07g3.jpg" alt="数据窗口中跟随"></p>
</li>
<li><p>接着<code>Ctrl + F9</code>执行到返回，可以看到，它获取到了信息并且信息一致：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk52sggjzj31ff0u0drl.jpg" alt="信息一致"></p>
</li>
</ul>
</li>
<li><p>接着运行程序，程序中断在<code>FindWindowA</code>，而它给定的参数是<code>Class = &quot;OllyDbg&quot;</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk5353sccj31ff0u0al6.jpg" alt="FindWindowA"></p>
<ul>
<li><p>根据<code>FindWindowA</code>的用法<code>如果有指定的类名或窗口标题则表示成功返回一个窗口的句柄；否则返回零；</code>，如果接下来<code>Ctrl + F9</code>执行到返回后，<code>EAX</code>是非零的值，是不是意味着找到了与<code>Class = &quot;OllyDbg&quot;</code>指定的类名匹配的窗口，并且拿到了它的句柄？</p>
</li>
<li><p>先来看看<code>OD</code>的类名与标题是什么，这里要借助一个软件<code>Greatis WinDowse</code>：</p>
<p><code>Greatis WinDowse</code>需要安装；<br><code>Greatis WinDowse</code>的用法是：将鼠标悬停在需要检测的窗口的标题栏即可；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk53ggz5tj31ff0u04ax.jpg" alt="类名与标题"></p>
<p>可以看到，检测到的标题与窗口标题完全一致，那类名不言而喻；</p>
</li>
<li><p>接下来<code>Ctrl + F9</code>执行到返回后，发现<code>EAX</code>里的确有一个非零的值，如何证明它就是<code>OD</code>的句柄呢，再次打开<code>Greatis WinDowse</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk53smw27j31ff0u0tk6.jpg" alt="OD的句柄"></p>
<p>检测到的句柄与<code>EAX</code>的值完全相同，那<code>OD</code>可就危险了；</p>
</li>
</ul>
</li>
<li><p>到了这里，如果继续运行程序，肯定会获得一个程序结束的大礼包，有继续运行程序冲动的同学需要加强学习了，既然拿到了<code>OD</code>的句柄，也就是生杀大权，那么，应该跟着它，看看它拿着句柄要干什么？So，<code>F8</code>单步执行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk549889lj31ff0u0dqa.jpg" alt="来到了这里"></p>
<p>程序来到了这里，先不要执行代码，观察一下，如果没有猜错，下面的<code>ExitProcess</code>就是刚运行程序设置的第一个断点调用的位置；</p>
<ul>
<li><p>再来查看一下代码，前三行，两个比较一个跳转，既然找到了与指定类名相同的窗口，那么句柄也就是<code>EAX</code>肯定不为 0，所以第三行的跳转一定会成立；</p>
</li>
<li><p>紧接着看看下面两个跳转，除了起始位置不同，都完美的跳过了<code>ExitProcess</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk54mk4r7j31qs0ms76z.jpg" alt="两个跳转"></p>
</li>
<li><p>当然，以上都只是推论，代码并没有执行，如何证实推论？当然是将句柄也就是<code>EAX</code>置 0：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk54yys42j31ff0u0gwj.jpg" alt="EAX置0"></p>
</li>
<li><p>然后继续<code>F8</code>单步执行程序，果不其然，程序跳过了<code>ExitProcess</code>，来到了<code>lstrcmpA</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk557lbrrj31ff0u0k2t.jpg" alt="字符串比较"></p>
<p>用获取到的第一个进程的标题名和给定字符串做比较；</p>
</li>
<li><p>继续向下执行，逻辑瞬间清晰：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk55qvbguj31ff0u04aj.jpg" alt="逻辑清晰"></p>
<p>至此，终于理清了它反调试的套路：</p>
<ol>
<li>首先使用<code>CreateToolhelp32Snapshot</code>获取进程快照；</li>
<li>接着使用<code>Process32First</code>获取进程快照第一个进程的句柄；</li>
<li>然后使用<code>FindWindowA</code>获取给定类名或标题的进程的句柄，如果获取成功，则使用句柄关闭这个程序的所有进程及线程；</li>
<li>如果使用<code>FindWindowA</code>获取失败，则通过<code>Process32First</code>获取的第一个进程的标题与给定字符串进行比较，相同则关闭这个程序；</li>
<li>如果第一个进程的信息比较不相同，则使用<code>Process32Next</code>获取进程快照的下一个进程，并用其标题与给定字符串比较，相同则关闭程序，不同则取下一个，直到进程快照中的所有进程比较完毕；</li>
</ol>
</li>
</ul>
</li>
<li><p>既然已经跳过了这个程序对<code>OD</code>的检测，是不是意味着现在可以看到最开始的弹窗呢？禁用所有断点并运行程序：<br><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk560iqxxj31ff0u0k0o.jpg" alt="弹窗"></p>
<p>完工！</p>
</li>
<li><p>不不不，没有完工，既然知道了这个程序的反调试原理，如何绕过呢，不能每次都手动吧？这里需要借助一个<code>OD</code>补丁程序<code>re-pair</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk56aya3ej31ff0u0n8v.jpg" alt="补丁程序"></p>
<p>补丁程序会生成了一个名称随机的<code>OD</code>主程序，试试效果如何：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk56lopeqj31ff0u04ap.jpg" alt="完工啦"></p>
<p>再多句嘴，插件<code>HideDebugger</code>虽然也有<code>FindWindow/EnumWindows</code>选项，但只能绕过标题名检测，无法绕过类名检测：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk56vnr87j31ff0u0wqt.jpg" alt="HideDebugger"></p>
<p>这次是真的完工了！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（二）</title>
    <url>/post/1165783651/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-11">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>本次内容是学习完毕之后脑海里的回放，原因无他，不了解 Windows API，不知道每个函数的具体作用以及是否需要特别关注，所以，只能跟着大佬学习思路以及 Windows API；</p>
</li>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhnceosakj30aq07ot8q.jpg" alt="打开软件"></p>
<p>既然是学习反调试，那么注册码当然不是重点，重点是它对<code>OD</code>的影响，打开<code>OD</code>，发现闪了一下然后被关闭了，嗯，反调试了；</p>
<p>还有一个现象就是：给<code>OD</code>改个名后，就不会被反调试了，即使是<code>OD</code>载入程序并运行，也不会被反调试；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先，<code>Ctrl + N</code>查看 API 列表，API 很多，搜索<code>GetProcAddress</code>设置 CC 断点；</p>
<ul>
<li><p>了解一下 Windows API <code>GetProcAddress</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetProcAddress</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定的动态链接库中的输出库函数地址；</span><br><span class="line">    （获取函数列表中不显示且被调用的隐藏函数的地址；）</span><br><span class="line">    （捕捉间接加载或调用的其他隐藏函数；）</span><br><span class="line">参数</span><br><span class="line">    hModule：包含此函数的 DLL 模块的句柄；</span><br><span class="line">    （程序的句柄）</span><br><span class="line">    IpProcName：包含函数名的以 NULL 结尾的字符串；</span><br><span class="line">    （程序的名字）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>接着，<code>F9</code>运行程序，程序会在设置断点的 API 上中断多次，每中断一次，都代表获取了一个隐藏的函数；</p>
</li>
<li><p>在大约中断了 143 次后，对接下来获取到的 3 个重要的 API 设置 CC 断点：<code>EnumProcesses</code>、<code>EnumProcessesModules</code>、<code>GetModuleBaseNameA</code>；</p>
<ul>
<li><p>国际惯例，分别了解一下这几个 API ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnumProcesses</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索进程列表中每一个进程的标识符；</span><br><span class="line">    （枚举进程的 PID；）</span><br><span class="line">    （获取进程列表所有进程的 PID；）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnumProcessesModules</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定进程中每个模块的句柄；</span><br><span class="line">    （获取进程的基址；）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetModuleBaseNameA</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定模块的基本名称；</span><br><span class="line">    （获取进程名；）</span><br></pre></td></tr></table></figure></li>
<li><p>设置断点的方法：</p>
<p>程序中断后，在<code>堆栈窗口</code>确认是需要的 API 后，在函数名称所在行右键菜单选择复制到剪贴板，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqpoeyaqj31ff0u013m.jpg" alt="复制"></p>
<p>接着<code>Ctrl + F9</code>执行到返回，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqqvhbvhj31ff0u0n80.jpg" alt="执行到返回"></p>
<p>然后<code>bp EAX</code>设置断点，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqrzoin0j31ff0u0qf2.jpg" alt="设置断点"></p>
<p>在断点窗口双击断点进入汇编窗口，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqrsjy18j31ff0u0n6k.jpg" alt="断点窗口"></p>
<p>在注释栏双击并粘贴复制的函数名，也就是给断点设置备注，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqtz1wgmj31ff0u0gxm.jpg" alt="注释"></p>
<p>断点设置完成；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqupj78mj31ff0u0gum.jpg" alt="注释完成"></p>
<p>至于为什么要设置备注，如果有 10 个没有设置备注的断点，那就傻傻分不清了；</p>
</li>
</ul>
</li>
<li><p>这里不得不提一下 PID，它的全称是<code>Process ID</code>，通俗易懂嘛，<code>进程 ID</code>；</p>
<ul>
<li><p>至于怎么查看 PID，打开任务管理器，选择<code>进程</code>列，就显示了当前所有程序的诸如程序名、PID、用户名等等信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrn2d1q8j30mc0vcq46.jpg" alt="任务管理器"></p>
<p>而我们使用的<code>OD</code>也赫然在列；</p>
</li>
<li><p>当然，如果你的进程列表中没有 PID 这一列，不要慌，你的电脑没问题，点击菜单栏中的<code>查看</code>按钮并选择<code>选择列</code>选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrqp0c07j30me0v8t9y.jpg" alt="选择列"></p>
</li>
<li><p>然后勾选<code>PID</code>复选框并确定，你的进程列表中就有 PID 这一列了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrsbmu0qj30mc0v6jst.jpg" alt="复选框"></p>
</li>
</ul>
</li>
<li><p>了解并知道如何查看 PID 之后，就要进入正题了：</p>
<p>以我的机器为例，<code>OD</code>的 PID 是<code>1380</code>，这是一个 10 进制数，要在<code>OD</code>里使用它，当然要转换为 16 进制：</p>
<p>进制转换的方法很多，比如使用网页提供的进制转换器，使用系统内置的计算器，使用<code>OD</code>自带的进制转换，这里以<code>OD</code>为例：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhs12msd7j30d408qjrf.jpg" alt="16进制"></p>
<p>随便双击一个寄存器，然后修改它的<code>无符号</code>值，<code>十六进制</code>栏就会显示对应的 16 进制数，这里<code>OD</code>的 PID 对应的 16 进制数就是<code>00000564</code>；当然，修改寄存器的值只是为了进制转换，一定不要点击确定哦；</p>
</li>
<li><p>设置好 3 个函数的断点后，继续运行程序，程序会再次中断，不过，不再是中断在<code>GetProcAddress</code>，而是中断在新设置的第一个断点，也就是<code>EnumProcesses</code>：</p>
<ul>
<li><p>我们已经了解了<code>EnumProcesses</code>的功能：获取进程列表所有进程的 PID；</p>
</li>
<li><p>既然<code>EnumProcesses</code>不需要参数，那么堆栈窗口<code>ESP + 4</code>的位置，存储的就是它的返回值，数据窗口中跟随一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhssuz2luj31ff0u0k33.jpg" alt="数据窗口"></p>
</li>
<li><p>接着<code>Ctrl + F9</code>执行到返回，发现以基址为起始位置的部分地址的内容被覆盖了，而<code>OD</code>的 PID 也在其中：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhsu51my1j31ff0u0n90.jpg" alt="od16"></p>
</li>
</ul>
</li>
<li><p>既然是要了解反调试对<code>OD</code>的影响，当然要跟随<code>OD</code>的数据了，在<code>OD</code>的 PID 上设置<code>内存访问断点</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhsx5pxacj31ff0u013l.jpg" alt="内存访问断点"></p>
</li>
<li><p>继续运行程序，程序再次中断，一眼就看到了<code>OD</code>的 PID 被当作参数传递给了函数<code>OpenProcess</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhtbacm5dj31ff0u0gx2.jpg" alt="参数"></p>
<ul>
<li><p><code>OpenProcess</code>这个函数的作用是什么呢，了解一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知 PID 获取程序的句柄；</span><br></pre></td></tr></table></figure></li>
<li><p><code>OD</code>危险了，因为这个<code>CrackMe</code>拿到了它的句柄，也就是它的生杀大权；</p>
</li>
<li><p><code>F8</code>单步步过执行程序，看看是否如是：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhthr6mxdj31ff0u0al0.jpg" alt="拿到句柄"></p>
<p>因为函数的返回值一般都在<code>EAX</code>，所以我们大胆猜测，<code>EAX</code>中应该就是<code>OD</code>的句柄，如何证明呢？去<code>句柄窗口</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhtm3151xj31ff0u0tjy.jpg" alt="句柄窗口"></p>
<p><code>句柄窗口</code>中有一个数值相同的句柄，而这个函数是用来获取句柄的，又把<code>OD</code>的 PID 当作了参数，那么它返回的应该就是<code>OD</code>的句柄，所以可以确定，<code>EAX</code>中就是<code>OD</code>的句柄也就是<code>000000C4</code>;</p>
</li>
</ul>
</li>
<li><p>继续运行程序，程序再次中断，来到了我们设置的三个函数断点中的其二，也就是<code>EnumProcessesModules</code>：获取指定进程的基址</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvdso10zj31ff0u0wpw.jpg" alt="获取基址"></p>
<p>在数据窗口中跟随存放函数执行结果的地址，然后<code>Ctrl + F9</code>执行到返回后，可以发现<code>OD</code>的基址是<code>00400000</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvfcc0plj31ff0u0ams.jpg" alt="基址"></p>
</li>
<li><p>继续<code>F9</code>运行程序，程序再次中断，这次是<code>GetModuleBaseNameA</code>：</p>
<p>执行到返回发现，它通过进程和基址获取到了<code>OD</code>的名称：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvrs35erj31ff0u0dr0.jpg" alt="名称"></p>
</li>
<li><p>接下来就不能直接<code>F9</code>运行程序了，因为再运行下去程序可能就结束了，所以使用<code>F8</code>单步执行，看看它获取了进程名之后要做什么：</p>
<ul>
<li><p>咦，又一个把<code>OD</code>句柄当作参数传递的函数，了解一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvyuodhhj31ff0u0n8h.jpg" alt="close"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CloseHandle</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知对象的句柄关闭句柄；</span><br></pre></td></tr></table></figure></li>
<li><p>继续执行后，去<code>句柄窗口</code>查看，已经找不到<code>OD</code>的句柄了，说明它被关闭了；</p>
</li>
<li><p>接着向下运行，发现一个把<code>OD</code>的名称当作参数的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhw42p6njj31ff0u0n8g.jpg" alt="名称"></p>
<p>使用<code>F7</code>步入跟进后，发现它是将<code>OD</code>的名称转换为 UpperCase，紧跟着下一个函数把转换后的名称和给定字符进行了比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwc8u9y2j31ff0u07g5.jpg" alt="比较"></p>
</li>
<li><p>上一步执行完毕后，由于比较的结果相同，跳转失败，程序又重新通过<code>OpenProcess</code>使用<code>OD</code>的 PID 获取了<code>OD</code>的句柄：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwl1yxpvj31ff0u0tkk.jpg" alt="重新获取"></p>
</li>
<li><p>接着，把<code>OD</code>的句柄作为参数传递给<code>TerminateProcess</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwpt69mlj31ff0u0k2p.jpg" alt="句柄当做参数"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TerminateProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过进程句柄终止指定进程及其所有线程；</span><br></pre></td></tr></table></figure>
<p>了解了这个 API 的用途后，继续运行程序，结果不言而喻：灵光一闪，程序关闭！</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（五）</title>
    <url>/post/3503361299/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-2">HideDebugger</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-14">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>可能是深入讲解会让新手陷入困境，大佬在讲解的时候点到为止，但我抑制不住好奇心，使用搜索引擎搜寻良久并未找到通俗易懂的说明，倒是在<a href="https://ctf-wiki.github.io/ctf-wiki/">CTF Wiki</a>上发现了描述，但无奈自己功力尚浅，无法透彻理解，遂将链接奉上，感兴趣的同学可以去学习一下<a href="https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntglobalflag-zh/">NtGlobalFlag</a>，<a href="https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/heap-flags-zh/">Heap Flags</a>；</p>
</li>
<li><p>文中使用的<code>CrackMe</code>无特定要求，可以使用任意一款；</p>
</li>
<li><p>了解一下两个标志，以下描述引用自<a href="https://ctf-wiki.github.io/ctf-wiki/">CTF Wiki</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NtGlobalFlag</span><br><span class="line"></span><br><span class="line">描述</span><br><span class="line">    1. 在 32 位机器上, NtGlobalFlag字段位于PEB(进程环境块)0x68的偏移处, 64 位机器则是在偏移0xBC位置.</span><br><span class="line">    2. 该字段的默认值为 0.</span><br><span class="line">    3. 当调试器正在运行时, 该字段会被设置为一个特定的值.</span><br><span class="line">    4. 尽管该值并不能十分可信地表明某个调试器真的有在运行, 但该字段常出于该目的而被使用</span><br></pre></td></tr></table></figure>
<p>呃，至于<code>ProcessHeap</code>，实在是总结不出具体的描述性语言，感兴趣的同学去<a href="https://ctf-wiki.github.io/ctf-wiki/">CTF Wiki</a>看吧；</p>
</li>
<li><p>接下来就用实例来说明一下这两个标志的用法：</p>
<ul>
<li><p>首先选择一个<code>CrackMe</code>倒入<code>OD</code>：</p>
<p>之前学习<code>IsDebuggerPresent</code>的时候学习到：如果程序倒入<code>OD</code>之后没有运行，那么<code>EBX</code>寄存器指向的位置就是<code>IsDebuggerPresent</code>检测的位置，用代码表示就是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOVZX</span> <span class="built_in">EAX</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">2</span>]   <span class="comment">; 将 EAX 中的地址，存储的第 2 个字节的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>
<p>在这里简单计算一下，就当作复习之前的知识了，以这个<code>CrackMe</code>为例：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkafiohmmj31ff0u0gxv.jpg" alt="为例子"></p>
<p>手动计算一下<code>IsDebuggerPresent</code>要检测的位置：</p>
<ol>
<li><p><code>MOV EAX,DWORD PTR FS:[18]</code>：<code>FS 寄存器</code>从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 位存放的是起始位置的地址，也就是说，在这里，<code>FS:[18] == 7FFDF000</code>；</p>
</li>
<li><p><code>MOV EAX,DWORD PTR DS:[EAX+30]</code>：这个很好计算嘛，<code>[EAX+30] == 7FFDF030</code>，使用<code>Ctrl + G</code>跟随一下这个地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkarqpe18j31ff0u0n8e.jpg" alt="计算并跟随"></p>
<p><code>7FFDF030</code>中存储的地址不正式<code>EBX</code>中的地址嘛；</p>
</li>
</ol>
</li>
<li><p>回顾完之前的内容，开始学习本次内容的第一个标志<code>NtGlobalFlag</code>：</p>
<p>根据对<code>NtGlobalFlag</code>描述可知：在 32 位机器上, NtGlobalFlag 字段位于 PEB(进程环境块)0x68 的偏移处；</p>
<p>首先，什么是 PEB?查询了许久之后又引出了 TEB，不太理解，但找到一些感觉描述很通俗的话：</p>
<ul>
<li><p>TEB：即 Thread Environment Block ，它记录相关线程的信息，每一个线程都有自己的 TEB，每个 TEB 都有自己的 TIB（Thread Information Block）,即线程信息块，每当创建一个线程，系统均会为每个线程分配 TEB，而且 TEB 永远放在 FS 寄存器指定的数据段的 0 偏移处；</p>
</li>
<li><p>PEB：即（Process Envirorment Block Structure），英文翻译过来就是进程环境信息块，在你进行打开这个程序或以调试方式打开这个程序，那么操作系统会对你这个进程的进程环境块的一些标志设置一系列的属性，如果你使用系统的调试方法，那么系统就会把相对应的标志位给设置上；</p>
<ol>
<li><p>TEB 结构体位于 FS 段选择符所指的段内存的起始地址处，也就是 0 偏移处；</p>
</li>
<li><p>PEB 成员位于距 TEB 结构体 Offset 30 的位置，也就是 0x30 偏移处；</p>
</li>
<li><p>那么就有两种获取 PEB 的方法：</p>
<ul>
<li>既然 TEB 位于 <code>FS 寄存器</code> 0 偏移处，在本文中就是<code>7FFDF000</code>，而 PEB 位于距 TEB 结构体 0x30 偏移处，那么是不是可以直接理解为：PEB 位于<code>FS 寄存器</code> 0x30 偏移处，即<code>FS:[30]</code>就是 PEB，在本文中就是<code>7FFDF030</code>；</li>
<li>TEB 位于 <code>FS 寄存器</code> 0 偏移处，在本文中就是<code>7FFDF000</code>，如何获取<code>FS 寄存器</code> 0 偏移处即文中的<code>7FFDF000</code>呢？当然是<code>FS:[18]</code>了，既然拿到 TEB 本身，如何获取 PEB 呢？方法就和上面复习的一样了；</li>
</ul>
</li>
</ol>
</li>
<li><p>既然找到了 PEB 的位置，而根据对<code>NtGlobalFlag</code>的定义得知，它位于 PEB 0x68 偏移处；</p>
<p>本文中 PEB 为<code>7FFDF030</code>地址中的数据<code>7FFD8000</code>，也就是初始<code>EBX</code>指向的地址，再偏移 0x68 计算为<code>7FFD8068</code>，也就是说，如果<code>7FFD8068</code>地址的数据不为 0，则表示检测到正在调试程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkcwq4qc1j31ff0u0n7p.jpg" alt="NtGlobalFlag"></p>
<p>整理一下代码的实现：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">68</span>]   <span class="comment">; 将 EAX 中的地址加 0x68 之后的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">OR</span> <span class="built_in">EAX</span>,<span class="built_in">EAX</span>                      <span class="comment">; 是否为 0</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>
<p>验证一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkdsmdg1kj31ff0u0tjp.jpg" alt="验证NtGlobalFlag"></p>
</li>
</ul>
</li>
<li><p>再来说说第二个标志<code>ProcessHeap</code>：</p>
<p>对这个标志的了解少之又少，暂时没有查到直接关联的资料，只能按照大佬的思路总结一下：</p>
<ol>
<li><p>位于 PEB 偏移 0x18 处，本文中 PEB 是<code>7FFD8000</code>，偏移 0x18 之后是<code>7FFD8018</code>；</p>
</li>
<li><p>把偏移后的地址中的 DWORD 长度的数据作为地址，偏移 0x10，即对本文的<code>7FFD8018</code>中的数据<code>00140000</code>偏移 0x10；</p>
</li>
<li><p>如果这个位置的数据不为 0，即本文的<code>00140010</code>不为 0，则表示检测到正在调试程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkdjjn9lfj31ff0u0akf.jpg" alt="ProcessHeap"></p>
<p>整理一下代码的实现：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">18</span>]   <span class="comment">; 将 EAX 中的地址加 0x18 之后的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">10</span>]   <span class="comment">; 将 EAX 中的地址加 0x10 之后的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">OR</span> <span class="built_in">EAX</span>,<span class="built_in">EAX</span>                      <span class="comment">; 是否为 0</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>
<p>验证一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glkdp9qncvj31ff0u0qdy.jpg" alt="验证ProcessHeap"></p>
</li>
</ol>
</li>
<li><p>两个标志分析完毕，接下来就要说说如何绕过了，不能每次都手动修改吧；</p>
<p>这里需要借助两个<code>OD</code>插件<code>HideDebugger</code>和<code>HideOD</code>，是的，它们就是上一节中使用的插件；</p>
<p>设置如下图：<br><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gll7skb4c3j31ff0u048h.jpg" alt="插件设置"></p>
<p>细心的同学会发现，这里的设置和上节课一模一样，是的，设置相同，但是重点不同；</p>
<p>虽然之前设置了某些选项，但只是照猫画虎，不知其意，相信学完这节内容，就会理解这样设置的意图；</p>
</li>
<li><p>验证一下插件是否生效：</p>
<p>程序倒入<code>OD</code>不要运行，在<code>数据窗口</code>中跟随<code>EBX</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gll8umchjbj31ff0u07ez.jpg" alt="前两个绕过"></p>
<p>可以在<code>数据窗口</code>直观的看到，<code>IsDebuggerPresent</code>和<code>NtGlobalFlag</code>检测的位置已经成功置 0，绕过检测，至于<code>ProcessHeap</code>，<code>Ctrl + G</code>跟随地址查看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gll931b41xj31ff0u0qd9.jpg" alt="最后一个绕过"></p>
</li>
</ul>
</li>
<li><p>聊完两个标志，再来聊聊另外一个知识点：一个崩溃：</p>
<p>一个崩溃不是说 Windows 的 API 又有特殊的用途或参数，或者说是大佬思路清奇把 API 用出了花儿，而是<code>OD</code>的 bug：当被调试的程序通过 OutputDebugString 输出超长的一串调试字符串的时候，OllyDbg 无法处理导致崩溃；</p>
<p>非常抱歉，目前暂不知道如何重现这个 bug ，只能是根据大佬的讲解，用插件修复这个 bug，至于修复的方法，如上图；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（六）</title>
    <url>/post/3051308746/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-2">HideDebugger</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-15">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>本次内容涉及了小部分脱壳以及一个<code>OD</code>无法处理的异常<code>int 68</code>，深入内容目前还做不到，所以暂时只是根据大佬的说明修改并绕过，而后面的反调试才是目前学习的重点，做到：<code>有耐心，不好高骛远</code>；</p>
</li>
<li><p>简单的脱壳和<code>int 68</code>说明：</p>
<p>要想看到<code>int 68</code>异常，需要用到<code>HideDebugger</code>和<code>HideOD</code>插件，不然程序运行不到那里就退出了，至于两个插件的配置，翻阅上篇文章，这里不再赘述；</p>
<ul>
<li><p>首先，这个程序很奇怪，没有打开<code>OD</code>的情况下程序也打不开，眼疾手快的同学可以在任务管理器窗口发现打开程序的同时有个进程一闪而过；</p>
</li>
<li><p>在开始之前，需要设置一下<code>OD</code>，为了能捕获所有异常，需要设置如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo98arrrbj31ff0u0gvn.jpg" alt="设置OD"></p>
</li>
<li><p>既然打不开，那还等什么，直接倒入<code>OD</code>分析：</p>
<p>倒入后，会弹出了弹窗，而这个弹窗正说明了这个程序有壳：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloa6ipooej313c06sjrl.jpg" alt="有壳"></p>
<p>关闭弹窗继续；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glnj7u4ww4j31ff0u0k16.jpg" alt="奇怪"></p>
<p>如果在这里能发现异常，说明基础知识还是比较扎实的；</p>
<p>是的，第二行代码<code>POPAD</code>就很奇怪，往上翻也只有一行空指令，奇怪在哪里呢？<code>POPAD</code>是弹栈的意思，也就是说，这条指令会把 8 个通用寄存器的数据从栈中弹出，恢复到程序压栈前的状态，而前面却没有对应的压栈指令<code>PUSHAD</code>，所以很奇怪；</p>
</li>
<li><p>既然<code>POPAD</code>前面有一行空指令，那岂不是可以直接写一个<code>PUSHAD</code>就解决了，我不但这么想了，而且还这么做了，不过立马就后悔了，原因无他，程序倒入<code>OD</code>没有运行的话，本就处于<code>OEP</code>位置，在<code>OEP</code>前面写代码，如何运行？被自己的灵机一动蠢哭了；</p>
<p><code>OEP</code>是什么：(Original Entry Point)，程序的入口点，软件加壳就是隐藏了 OEP（或者用了假的 OEP）， 只要我们找到程序真正的 OEP，就可以立刻脱壳；</p>
<p>PUSHAD （压栈） 代表程序的入口点；</p>
<p>POPAD （出栈） 代表程序的出口点，与 PUSHAD 相对应，一般找到这个 OEP 就在附近；</p>
</li>
<li><p>不过怀疑归怀疑，如何确定<code>POPAD</code>这个指令有问题呢，继续运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo991kaugj31ff0u0akc.jpg" alt="程序中断"></p>
<p>程序中断，在<code>OD</code>的最下方给出了原因，是因为有一个异常：<code>访问违规</code>，也就是说<code>PUSH 474988</code>这行指令无法压栈，无法压栈的原因是什么呢？应该是堆栈地址不对，就好比去澡堂子洗澡，给你的是 183 号衣柜的钥匙，而你非要放入 96 号衣柜，这肯定是放不进去的；</p>
<p>如何证实这个猜想呢？去<code>内存窗口</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo9hudfdbj31ff0u0477.jpg" alt="堆栈区间"></p>
<p>可以看到，系统分配给堆栈的地址是<code>0012C000</code>开始，大小<code>4000</code>，加法运算一下，刚好<code>00130000</code>，也就是说，堆栈的区间是<code>0012C000 - 0012FFFF</code>；</p>
<p>回过头来看<code>ESP</code>的地址，<code>ESP</code>指向堆栈顶端嘛：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo9mnhbmvj31ff0u07e3.jpg" alt="ESP"></p>
<p>很明显，<code>PUSH 474988</code>这行指令要压栈的地址，超出了堆栈的范围，所以才会引发异常；</p>
</li>
<li><p>既然找到了问题，那问题的根源是什么？还记得第二行代码吗？<code>POPAD</code>，有可能是它改变了<code>ESP</code>的地址，从而导致后面的异常，重载程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo9ynnu5dj31ff0u0gvh.jpg" alt="未运行"></p>
<p>观察<code>POPAD</code>前，<code>ESP</code>的数据，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glo9zy8jjvj31ff0u0qck.jpg" alt="运行后"></p>
<p>此时明显看到，<code>ESP</code>指向的地址，已经不在堆栈范围内，所以这个压栈指令会产生一个异常；</p>
</li>
<li><p>那么如何修改绕过这个异常呢？</p>
<p>既然<code>POPAD</code>前，<code>ESP</code>指向的地址在堆栈范围内，那如果不让它弹栈岂不是没有影响了，那就让它入栈<code>PUSHAD</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloa9p6p8nj31ff0u048h.jpg" alt="pushad"></p>
<p>然后运行程序，那个异常没有出现，看来已经绕过了，然鹅，程序却展示了一堆”乱码”，嘿嘿，这里不是乱码，而是程序加密了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloacagzksj31ff0u0wo4.jpg" alt="乱码"></p>
<p>如何解码？很简单，在<code>汇编窗口</code>任意位置右键<code>分析 &gt; 从模块中删除分析</code>，然后乱码就消失了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloai1oghzj31ff0u0n6q.jpg" alt="解码"></p>
</li>
<li><p>兴奋之余扫了一眼<code>OD</code>左下角，又是一个<code>访问违规</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloam91kdtj31ff0u0woj.jpg" alt="又一个访问违规"></p>
<p>而它就是我们今天要了解的第二个异常<code>INT 68</code>，具体的描述也没有在搜索引擎中找到，暂且就知道它是一个<code>OD</code>无法处理的异常；</p>
<p>至于绕过方法很简单，就是将这行指令改为<code>NOP</code>即可：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloarbasscj31ff0u0ak3.jpg" alt="改为nop"></p>
<p>然后继续运行程序，发现程序正常运行了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloataudrgj31ff0u014h.jpg" alt="程序运行"></p>
</li>
</ul>
</li>
<li><p>反调试小记：</p>
<p>既然绕过脱壳和<code>int 68</code>异常，程序就正常运行了，那还反调试啥？别忘了，前面为了看到<code>int 68</code>异常，我们使用了两个插件，而如果没有这两个插件呢？</p>
<ul>
<li><p>把<code>HideDebugger</code>和<code>HideOD</code>插件从<code>OD</code>移除并重启<code>OD</code>，然后将程序倒入<code>OD</code>；</p>
</li>
<li><p>倒入程序后，<code>Ctrl + N</code>查看 API 列表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1globd2ax57j31ff0u0do8.jpg" alt="函数列表"></p>
<p>可以看到，函数不多而且没有什么特殊的，但<code>GetProcAddress</code>却在其中，这就很值得思考了，是不是函数都被隐藏了，果断给<code>GetProcAddress</code>设置断点并做好备注；</p>
</li>
<li><p>然后运行程序，程序会中断多次，而<code>GetProcAddress</code>会获取到所有隐藏或间接调用的函数，把认为可疑的函数设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glocd77gw8j31ff0u07dz.jpg" alt="断点做备注"></p>
<p>可以看到有三个断点被禁用了，这是经过思考之后的决定：</p>
<ol>
<li><code>GetProcAddress</code>：既然程序中断的位置已经改变，那就说明所有隐藏函数获取完毕，这个断点就没有意义了：“飞鸟尽良弓藏”；</li>
<li><code>CloseHandle</code>：关闭句柄，用处不大；</li>
<li><code>OpenProcess</code>：获取句柄，这个用途范围太大，况且，获取了就是要操作，直接拦截关闭岂不更香；</li>
</ol>
</li>
<li><p>获取所有隐藏函数后， 程序中断在<code>CreateToolhelp32Snapshot</code>：这个 API 是获取进程列表的所有程序的进程快照，并返回快照句柄供其他 API 使用，<code>Ctrl + F9</code>执行到返回；</p>
</li>
<li><p>既然已经获取了进程快照，那接下来应该就是调用<code>Process32First</code>或<code>Process32Next</code>来分析每个进程了吧？</p>
<p><code>F8</code>单步执行程序，程序又来到了未解密的代码段，右键<code>分析 &gt; 从模块中删除分析</code>解码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glocy1e9w9j31ff0u0dpe.jpg" alt="分析代码"></p>
<p><code>Ctrl + A</code>分析一下解码后的代码，确实发现了<code>Process32First</code>，呃，不过不在一个代码块，打脸是不是来的有点快；</p>
</li>
<li><p>继续<code>F8</code>单步执行程序，程序跳转，来到了一个新的代码段，这里看上去非常可疑：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glod4sudjrj31ff0u0gw7.jpg" alt="非常可疑"></p>
<p>有一处用<code>OpenProcess</code>获取句柄然后用<code>TerminateProcess</code>关闭程序，还有两个结构很类似的代码结构，继续往下翻，数一数，共有 6 处相同的结构：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glodjl22b5j31ff0u0wpf.jpg" alt="很一致"></p>
</li>
<li><p>既然觉得可疑，那就单步执行分析一下代码：</p>
<p>没有打脸，它确实调用了<code>Process32First</code>和<code>Process32FirstW</code>，二者的区别是：<code>Process32FirstW</code>是<code>Unicode</code>;</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glodpd2i7lj31ff0u0ajp.jpg" alt="调用Process32First"></p>
<p>继续运行程序，当然不会退出程序，因为进程列表的第一个进程肯定不是<code>OD</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glohkwrynmj30me0ve0tv.jpg" alt="进程列表"></p>
</li>
<li><p>然后多次运行程序，6 个结构相同的代码段依次比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glohisj5w1j31ff0u0qcn.jpg" alt="6个比较"></p>
</li>
<li><p>比较完会干什么？当然是调用<code>Process32Next</code>获取下一个进程的信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glohp0tbx1j31ff0u0qcp.jpg" alt="Process32Next"></p>
</li>
<li><p>继续向下执行，毫无悬念，又会回到 6 个循环组成的大循环，直到进程快照的所有进程比较完毕；</p>
</li>
<li><p>这里分析的差不多了，接下来迫不及待的想知道所有进程比较完毕后会做什么？很简单，无论它比较的结果是什么，都不让它结束程序，所以，把这里的<code>JNZ</code>都改成<code>JMP</code>，同样是 6 个：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glohvdo2lyj31ff0u0gvf.jpg" alt="JMP"></p>
</li>
<li><p>继续运行程序，直到所有进程比较完毕：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloi05b6qoj31ff0u0qcj.jpg" alt="PostQuitMessage"></p>
<p>程序中断在了<code>PostQuitMessage</code>，发送了退出程序的信息，这里就不能向下执行了，跟随它到调用的地方去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloi35nqeaj31ff0u0dph.jpg" alt="反汇编窗口跟随"></p>
<p>来到反汇编窗口，发现代码段很短：但很重要</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glokr3hvzuj31ff0u0akg.jpg" alt="代码段很短"></p>
<p>如果这个跳转成立，就不会调用<code>PostQuitMessage</code>，那就直接修改为<code>JMP</code>即可，甚至可以不用管它上面那个关键<code>CALL</code>是做什么的，这是为什么？很简单，因为这么半天了，连程序窗口都没有看到，如果允许程序调用<code>PostQuitMessage</code>就彻底没戏了，所以，在这个跳转上设置断点；</p>
</li>
<li><p>接着，重载并运行程序到最后设置的断点，需要先修改<code>POPAD</code>，接着修改大循环的<code>JNZ</code>为<code>JMP</code>，然后才能到达最后这个跳转的断点：</p>
<ul>
<li><p>重载程序的时候，会有提示弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glol2wpsbgj31am06yq3a.jpg" alt="重载弹窗"></p>
<p>这是因为，重载程序后，程序被加密了，我们在程序领空设置的断点无法识别，这个弹窗是提示我们程序领空设置的断点被禁用了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glol7yklm7j31ff0u0wnx.jpg" alt="断点禁用"></p>
</li>
<li><p>在修改完<code>POPAD</code>并运行程序后，程序会中断在<code>CreateToolhelp32Snapshot</code>，这时就可以启用程序领空的断点了；</p>
</li>
<li><p>运行到关键跳转的断点，修改<code>JE</code>为<code>JMP</code>达到绕过<code>PostQuitMessage</code>的目的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glolee6mnoj31ff0u048r.jpg" alt="绕过PostQuitMessage"></p>
</li>
</ul>
</li>
<li><p>接着<code>F9</code>运行程序，程序中断在<code>INT 68</code>，这个简单，直接修改为<code>NOP</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glolmnrznlj31ff0u0k17.jpg" alt="NOP填充"></p>
</li>
<li><p>继续运行程序，期待已久的程序界面终于出现了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glolus39ivj31ff0u0gwa.jpg" alt="终于出现"></p>
<p>至于界面卡顿，禁用所有断点就正常喽；</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（四）</title>
    <url>/post/3209676884/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-2">HideDebugger</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-13">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>本节内容理解不是很透彻，也没有以往的<code>链式操作</code>：也就是初始找到切入点，然后根据切入点确定下一步的操作，只能跟随大佬的教程去理解、操作，同时查询微软官方文档，本次使用的 API<code>ZwQueryInformationProcess</code>未来可能会弃用，所以目前暂不做深入研究，有需要之时再做深入；</p>
</li>
<li><p>这次使用的反调试 API 很独特：它本身的设计初衷应该是用作异常处理，但却被<code>CrackMe</code>的作者用在了验证方面，不得不说，这位高人对 API 理解的很透彻，很独到，同时也提醒了我，反向思维很重要；</p>
</li>
<li><p>这里就说说本次使用的 API：<code>SetUnhandledExceptionFilter</code>、<code>UnhandledExceptionFilter</code>、<code>ZwQueryInformationProcess</code>；</p>
<ul>
<li><p>先来说说第二个 API <code>UnhandledExceptionFilter</code>：</p>
<p>这是官方文档的描述：</p>
<blockquote>
<p>An application-defined function that passes unhandled exceptions to the debugger, if the process is being debugged. Otherwise, it optionally displays an Application Error message box and causes the exception handler to be executed. This function can be called only from within the filter expression of an exception handler.</p>
</blockquote>
<p>对这段文档的理解：通过判断当前进程是否正在被调试，如果正在被调试，就把异常交给调试器，如果没有，就把异常交给进程的 UnhandledExceptionFilter 处理；</p>
<p>这里就不禁产生了一个疑问：如何判断当前进程是否正在被调试？</p>
</li>
<li><p>再来看第三个 API <code>ZwQueryInformationProcess</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZwQueryInformationProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索有关指定进程的信息</span><br><span class="line">参数</span><br><span class="line">    ProcessInformationClass：要检索的过程信息的类型</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在官方说明的开始有这么一段话：</p>
<blockquote>
<p><code>[ZwQueryInformationProcess may be altered or unavailable in future versions of Windows. Applications should use the alternate functions listed in this topic.]</code></p>
</blockquote>
<p>意思是：这个 API 可能会在未来的 Windows 版本中被更改或弃用，若要开发应用，请使用本文列出的其他替代 API。</p>
</li>
<li><p>这个 API 的第二参数<code>ProcessInformationClass</code>：<code>要检索的过程信息的类型</code>，本身有很多可选的值，而<code>ProcessDebugPort，值是 7</code>是我们关注的重点：</p>
<blockquote>
<p>Retrieves a DWORD_PTR value that is the port number of the debugger for the process. A nonzero value indicates that the process is being run under the control of a ring 3 debugger.</p>
</blockquote>
<p>意思是：检索四子节长度的值，该值是该进程的调试器的端口号。非零值表示该进程正在 Ring 3 调试器的控制下运行。</p>
<p>也就是说，调用这个函数，在把第二参数设置为<code>7</code>的情况下，只要返回非零值就表示我们正在调试程序，很好很强大，同时也解释了在学习上一个 API 时留下的疑惑；</p>
</li>
</ul>
</li>
<li><p>最后来看看第一个 API <code>SetUnhandledExceptionFilter</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SetUnhandledExceptionFilter</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    设置异常捕获函数</span><br><span class="line">参数</span><br><span class="line">    lpTopLevelExceptionFilter：指向顶级异常处理函数的指针，只要 UnhandledExceptionFilter 函数获得控制权且未在调试过程，该指针就会被调用</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这是官方对 API 的说明；</p>
<blockquote>
<p>Enables an application to supersede the top-level exception handler of each thread of a process.</p>
<p>After calling this function, if an exception occurs in a process that is not being debugged, and the exception makes it to the unhandled exception filter, that filter will call the exception filter function specified by the lpTopLevelExceptionFilter parameter.</p>
</blockquote>
</li>
<li><p>这是官方对参数<code>lpTopLevelExceptionFilter</code>的说明，请自行理解；</p>
<blockquote>
<p>A pointer to a top-level exception filter function that will be called whenever the UnhandledExceptionFilter function gets control, and the process is not being debugged. A value of NULL for this parameter specifies default handling within UnhandledExceptionFilter.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>学习完这三个 API，说说自己的理解：</p>
<ol>
<li><p><code>SetUnhandledExceptionFilter</code>可以为异常设置处理函数，参数<code>lpTopLevelExceptionFilter</code>指向自定义的异常处理函数，但要触发这个函数，必须满足一个条件：<code>UnhandledExceptionFilter</code>被调用；</p>
</li>
<li><p>同时，要想<code>UnhandledExceptionFilter</code>被调用，也得满足两个条件：程序没有被调试，并且这个异常没有被处理；</p>
</li>
<li><p>当同时满足以上条件时，就会触发自定义的异常处理函数来处理异常；</p>
</li>
<li><p>那么，程序是如何检测程序是否被调试呢？那就要用到<code>ZwQueryInformationProcess</code>了，也就是说，本次的反调试主角其实是<code>ZwQueryInformationProcess</code>（虽然它就要被弃用了）；</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>下面开始进入正题：</p>
<ul>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzea2h39j30h807uaa4.jpg" alt="打开软件"></p>
<p>很常规的软件，随便输入内容并点击 Check 后，没有任何反馈；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<p>既然已经学习了需要的 API，那就不用去 API 窗口看了，直接给三个函数设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzq6vknpj31ff0u012b.jpg" alt="设置断点并做好备注"></p>
<p>其实地址栏已经显示了地址对应的 API 名称，不过无法保证任何时候都会显示，况且，做备注是一个好的习惯，不是吗？</p>
<p>同时需要先禁用<code>ZwQueryInformationProcess</code>断点，否则程序会多次中断，但不会中断在理想的位置，况且按照对 API 的理解，只有<code>UnhandledExceptionFilter</code>调用它的时候才会检测程序是否被调试，所以，在<code>UnhandledExceptionFilter</code>出现后再启用也为时不晚；</p>
</li>
<li><p>接着<code>F9</code>运行程序，程序会中断在<code>SetUnhandledExceptionFilter</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzxn8v3hj31ff0u0tkf.jpg" alt="SetUnhandledExceptionFilter"></p>
<p>同时，根据 API 说明，它的参数指向自定义异常处理函数，那么就在它的参数地址上设置断点，看看我们是否会触发这个自定义函数；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk01ign7fj31ff0u0484.jpg" alt="参数设置断点"></p>
</li>
<li><p>继续运行程序，程序窗口会弹出，输入内容并点击 Check 后，程序再次中断，这次是中断在了<code>UnhandledExceptionFilter</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk05cb5zxj31ff0u0k39.jpg" alt="UnhandledExceptionFilter"></p>
<p>其实，细心的同学一眼就看到了它调用了另一个 API <code>ZwQueryInformationProcess</code>；</p>
<p>既然它都要调用<code>ZwQueryInformationProcess</code>了，那我们就需要去启用<code>ZwQueryInformationProcess</code>断点了；</p>
</li>
<li><p>激活<code>ZwQueryInformationProcess</code>断点并运行程序，程序会再次中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0bobp81j31ff0u04ag.jpg" alt="ZwQueryInformationProcess"></p>
<p>可以看到，<code>堆栈窗口</code>中，它的第二参数<code>InfoClass=7</code>，那就说明它本次执行的目的就是检测程序是否正在被调试，而它的第三参数<code>Buffer=0012F5E4</code>则存放的是返回值，<code>数据窗口</code>中跟随一下；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0htm7h8j31ff0u0wq1.jpg" alt="数据窗口"></p>
<p>事实上，我们确实正在调试这个这个程序，那我们就看看它的返回值是否是非零值；</p>
</li>
<li><p>既然要看它的返回值，那就不能直接运行程序了，<code>Ctrl + F9</code>执行到返回，同时查看<code>数据窗口</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0sudvwnj31ff0u0wpw.jpg" alt="执行到返回"></p>
<p>果然，返回值是一个非零值，也就说检测到正在调试程序；</p>
<p>既然检测到了正在调试程序，如何触发自定义的异常处理函数呢？当然是将返回值置 0；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0xlkckij31ff0u0k2k.jpg" alt="置0"></p>
<p>选中返回值用 00 填充，直接修改也是可以的；</p>
</li>
<li><p>既然已经修改了返回值，也就是绕过了检测，那么<code>ZwQueryInformationProcess</code>断点也就没用了，禁用<code>ZwQueryInformationProcess</code>断点并运行程序，程序会中断在：为<code>SetUnhandledExceptionFilter 的参数</code>设置的断点位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk14tbrvij31ff0u0n9e.jpg" alt="参数断点"></p>
</li>
<li><p>毫无悬念了，这里就是用来验证的关键代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2bmg6nqj31ff0u0wqc.jpg" alt="验证"></p>
<p>把我们输入的内容进行一系列操作之后，去和一个指定的内容做比较；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2h1fpwqj31ff0u0n8f.jpg" alt="比较"></p>
<p>到这里就可以理解为什么点击 Check 之后没有任何反馈了，是因为验证失败后没有任何操作；</p>
<p>既然已经知道会跳转到失败，如何看到成功的弹窗呢？当然是修改<code>ZF</code>标志位，让<code>JNZ</code>不成立：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2n9tg0jj31ff0u0k2k.jpg" alt="修改"></p>
<p>继续向下执行，期待已久的成功弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2rmsxwmj31ff0u0146.jpg" alt="成功"></p>
</li>
<li><p>既然已经知道了它的反调试原理，但又不想每次都手动修改，那该如何绕过能，这里需要借助插件：<code>HideDebugger</code>和<code>HideOD</code>，设置如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk39bp648j31ff0u0qeb.jpg" alt="插件"></p>
<p>无图无真相：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk3e9o4irj31ff0u07g4.jpg" alt="无图无真相"></p>
<p>插件的作用就是永远保持<code>ZwQueryInformationProcess</code>的参数为<code>7</code>时的返回值为 0；</p>
</li>
<li><p>总结：不得不说，能人背后有能人，这波操作很清奇，也就是说：如果从事物的多个角度去观察，去思考，可能会有不一样的理解与收获；</p>
<p>期待自己早日变得更加强大，加油 💪💪💪❗️</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之异常处理（一）</title>
    <url>/post/996855490/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-16">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>学习完的总结，而且其中讲的<code>PE</code>部分的内容，完全是一脸懵逼听下来，做个笔记；</p>
</li>
<li><p>内存访问异常总结下来就一句话：在没有权限的地方做了没权限的事儿；</p>
</li>
<li><p>将任意<code>CrackMe</code>倒入<code>OD</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonfurw1oj31ff0u0gwo.jpg" alt="倒入OD"></p>
<ul>
<li><p>当前处于代码段，只有只读权限，如果要写入内容会怎么样？</p>
<p>修改第一行代码，把<code>EAX</code>的内容写入指定地址；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloniemvqrj31ff0u0gxc.jpg" alt="修改代码"></p>
<p>然后执行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonkvl23pj31ff0u0wq7.jpg" alt="访问违规"></p>
<p>可以看到，根本无法执行代码；</p>
</li>
<li><p>那每个代码段的权限如何查看呢？</p>
<ol>
<li><p>方法一：</p>
<p>打开<code>内存窗口</code>，找到<code>PE 头文件</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonoefqwhj31ff0u048w.jpg" alt="内存窗口"></p>
<p>然后双击<code>PE 头文件</code>所在行，打开<code>数据窗口</code>，找到 PE 头偏移量<code>Offset to PE signature</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonqf357jj31ff0u0k1l.jpg" alt="偏移量"></p>
<p>既然偏移量是 100， 那地址就是<code>00400100</code>，往下翻找到这个地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glonx75sh8j31ff0u0499.jpg" alt="找到地址"></p>
<p>在这里，发现了代码段和数据段的地址信息，偏移量分别是 1000 和 2000，那地址就分别是<code>00401000</code>和<code>00402000</code>喽，如何确定呢？重载程序就知道了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glop9kcs3qj31ff0u049x.jpg" alt="起始位置"></p>
<p>至于它们的权限，继续往下翻：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloo34nk41j31ff0u0n80.jpg" alt="权限"></p>
<p>在这里可以清楚的看到，CODE 段只有只读权限，而 DATA 段有读写权限；</p>
</li>
<li><p>方法二：</p>
<p>在<code>数据窗口</code>按下<code>Ctrl + G</code>，转到<code>00400000</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glooawpu9qj31ff0u0alk.jpg" alt="转到表达式"></p>
<p>然后在<code>数据窗口</code>右键<code>指定 &gt; PE 头文件</code>，就可以定位到<code>PE 头文件</code>了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloofb56bhj31ff0u0qe1.jpg" alt="定位"></p>
<p>其他操作和方法一一致；</p>
</li>
</ol>
</li>
<li><p>测试一下修改代码段权限，写入内容：</p>
<p>在<code>数据窗口</code>选择代码段权限行，右键选择<code>修改整数</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glooklxgtpj31ff0u0dq1.jpg" alt="修改整数"></p>
<p>然后修改权限：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gloonxmrfcj31ff0u0qeh.jpg" alt="修改成功"></p>
<p>修改后可以看到，CODE 段有写的权限了，然后将修改保存到新的可执行文件；</p>
<p>接着，将保存的新文件倒入<code>OD</code>并修改第一行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glop0ua22cj31ff0u0wqa.jpg" alt="打开新文件"></p>
<p>运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glop2jpw4zj31ff0u013f.jpg" alt="运行程序"></p>
<p>可以看到，<code>EAX</code>的内容成功写入到以指定地址为开始的位置；</p>
</li>
</ul>
</li>
<li><p>对<code>PE</code>没有任何概念，只能根据教程的思路一步步来，做到：能学到的东西要学会；</p>
</li>
<li><p>最后，来说说一个小的知识点<code>除零异常</code>；</p>
<p>刚上学开始学习加减乘除的时候，老师就告诉我们 0 不能作为除数，而在程序设计中，当遇上正整数除以零程序会中止：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glov7g67kij31ff0u013c.jpg" alt="调试语句"></p>
<p>在这里，由于<code>EAX</code>自身为 0，为了区分被除数和除数，让<code>EAX</code>加上一个随机的立即数以区分，这里以 123 为例，接着通过<code>xor</code>让准备作为除数的<code>ECX</code>置 0，最后用<code>EAX</code>除以<code>ECX</code>，接下来，看一下运算的结果：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glovdctagcj31ff0u049u.jpg" alt="除零异常"></p>
<p>可以看到，执行<code>DIV ECX</code>后，也就是除以 0 后，这里产生了一个异常，这个异常就叫作除零异常；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之异常处理（二）</title>
    <url>/post/192684570/</url>
    <content><![CDATA[<h4 id="异常处理流程图"><a href="#异常处理流程图" class="headerlink" title="异常处理流程图"></a>异常处理流程图</h4><p>总结一下异常处理的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB;</span><br><span class="line"></span><br><span class="line">   A[&quot;系统发现产生了一个异常&quot;] --&gt; B&#123;&quot;程序是否正在被调试&quot;&#125;;</span><br><span class="line">   B -- &quot;是，程序正在被调试&quot; --&gt; C&#123;&quot;权限转给调试器，并判断调试器是否忽略了异常&quot;&#125;;</span><br><span class="line">   C -- &quot;是，忽略了&quot; --&gt; D&#123;&quot;程序是否安装 SEH&quot;&#125;;</span><br><span class="line">   D -- &quot;是，安装了&quot; --&gt; E&#123;&quot;SEH 是否解决异常&quot;&#125;;</span><br><span class="line">   E -- &quot;是，解决了&quot; --&gt; F&#123;&quot;程序可以继续正常运行&quot;&#125;;</span><br><span class="line"></span><br><span class="line">   B -- &quot;否，程序没有被调试&quot; --&gt; D;</span><br><span class="line">   C -- &quot;否，未忽略，但未能解决异常&quot; --&gt; G&#123;&quot;系统默认异常处理流程&quot;&#125;;</span><br><span class="line">   D -- &quot;否，未安装&quot; --&gt; G;</span><br><span class="line">   E -- &quot;否，未解决&quot; --&gt; G;</span><br></pre></td></tr></table></figure>
<p>已经写好<code>Mermaid</code>的语法，准备输出流程图了，发现<code>Hexo</code>的<code>mermaid</code>插件已是多年前的产物，不兼容最新的版本，无奈只能用<a href="https://app.diagrams.net/">draw.io</a>画了张图；</p>
<a id="more"></a>

<p>图片镇楼：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glprz3752lj31ay0u0tcd.jpg" alt="图片镇楼"></p>
<p>总结一下，共有 7 种流程：</p>
<p>1.<code>系统发现异常</code>&gt;&gt;<code>是否调试状态</code>&gt;&gt;<code>是</code>&gt;&gt;<code>交给调试器处理</code>&gt;&gt;<code>调试器是否忽略异常</code>&gt;&gt;<code>是</code>&gt;&gt;<code>检查是否安装 SEH</code>&gt;&gt;<code>已安装</code>&gt;&gt;<code>是否解决异常</code>&gt;&gt;<code>已解决</code>&gt;&gt;<code>程序继续运行</code>；</p>
<p>2.<code>系统发现异常</code>&gt;&gt;<code>是否调试状态</code>&gt;&gt;<code>是</code>&gt;&gt;<code>交给调试器处理</code>&gt;&gt;<code>调试器是否忽略异常</code>&gt;&gt;<code>是</code>&gt;&gt;<code>检查是否安装 SEH</code>&gt;&gt;<code>已安装</code>&gt;&gt;<code>是否解决异常</code>&gt;&gt;<code>未解决</code>&gt;&gt;<code>系统默认异常处理流程</code>；</p>
<p>3.<code>系统发现异常</code>&gt;&gt;<code>是否调试状态</code>&gt;&gt;<code>是</code>&gt;&gt;<code>交给调试器处理</code>&gt;&gt;<code>调试器是否忽略异常</code>&gt;&gt;<code>是</code>&gt;&gt;<code>检查是否安装 SEH</code>&gt;&gt;<code>未安装</code>&gt;&gt;<code>系统默认异常处理流程</code>；</p>
<p>4.<code>系统发现异常</code>&gt;&gt;<code>是否调试状态</code>&gt;&gt;<code>是</code>&gt;&gt;<code>交给调试器处理</code>&gt;&gt;<code>调试器是否忽略异常</code>&gt;&gt;<code>否，但未解决</code>&gt;&gt;<code>系统默认异常处理流程</code>；</p>
<p>5.<code>系统发现异常</code>&gt;&gt;<code>是否调试状态</code>&gt;&gt;<code>否</code>&gt;&gt;<code>检查是否安装 SEH</code>&gt;&gt;<code>已安装</code>&gt;&gt;<code>是否解决异常</code>&gt;&gt;<code>已解决</code>&gt;&gt;<code>程序继续运行</code>；</p>
<p>6.<code>系统发现异常</code>&gt;&gt;<code>是否调试状态</code>&gt;&gt;<code>否</code>&gt;&gt;<code>检查是否安装 SEH</code>&gt;&gt;<code>已安装</code>&gt;&gt;<code>是否解决异常</code>&gt;&gt;<code>未解决</code>&gt;&gt;<code>系统默认异常处理流程</code>；</p>
<p>7.<code>系统发现异常</code>&gt;&gt;<code>是否调试状态</code>&gt;&gt;<code>否</code>&gt;&gt;<code>检查是否安装 SEH</code>&gt;&gt;<code>未安装</code>&gt;&gt;<code>系统默认异常处理流程</code>；</p>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之断点</title>
    <url>/post/2731277808/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>OllyDbg 1.1 原版；</li>
<li>简称<code>OD</code>；</li>
</ul>
<a id="more"></a>

<h4 id="断点的分类"><a href="#断点的分类" class="headerlink" title="断点的分类"></a>断点的分类</h4><h5 id="F2-断点"><a href="#F2-断点" class="headerlink" title="F2 断点"></a>F2 断点</h5><ul>
<li><code>F2断点</code>又叫<code>普通断点</code>、<code>CC断点</code>、<code>int3断点</code>；</li>
<li>在<code>OD</code>反汇编窗口（<code>C</code>窗口）中，双击语句的某一行或按下 F2 会设置（触发）一个<code>int3 断点</code>；</li>
<li><code>int3</code>是一个断点（中断）指令，在汇编中机器码是<code>CC</code>，所以，<code>F2断点</code>又可以称为<code>int3断点</code>或<code>CC断点</code>；</li>
<li>在使用 F2 设置断点后，CPU 会引发一个异常，而 OD 会捕获这个异常，从而中断程序；</li>
<li>可以使用命令<code>bp xxxxxxxx</code>快速设置一个<code>CC断点</code>；</li>
<li><code>bp</code>可以为内存地址设置断点，也就是为某条语句设置断点；</li>
<li><code>bp</code>当然也可以为<code>API（函数）</code>设置一个断点，如<code>bp MessageBoxA</code>，断点会设置在 API 的行首，也就是函数的第一行；</li>
<li>通常情况下，当使用<code>bp</code>为<code>API</code>设置断点时，该<code>API</code>应该是可见的，也就是在反汇编窗口按下<code>Ctrl + N</code>后，在函数窗口能找得到时，才能使用<code>bp</code>设置断点，不过偶尔在找不到的情况下，也能使用<code>bp</code>设置断点，这种情况时可以买一注彩票；</li>
<li>使用<code>bp MessageBoxA</code>也就是为<code>API</code>设置断点后，会在系统领空下，这个<code>API</code>的行首设置断点；</li>
<li>使用<code>bpx MessageBoxA</code>也就是为<code>API</code>设置断点后，会在程序领空下，所有调用这个<code>API</code>的位置设置断点；</li>
<li><code>F2断点</code>的设置没有数量限制，可以设置无数个；</li>
<li><code>F2断点</code>很容易被检测，从而触发反调试；</li>
<li><code>F2断点</code>重载程序后不会丢失；</li>
</ul>
<p>当执行一个 int3 断点时，该地址的内容会被调试器用 int3 指令替换，此时 OD 将 int3 隐藏，显示出来的仍是中断前的指令，实际上已经被替换为 CC；</p>
<p>当被调试程序执行 int3 命令导致一个异常时，调试器就会捕捉到这个异常，从而停在断点处，然后将断点处的指令恢复成原来的指令；</p>
<p>由于 int3 断点改变了原程序机器码，所以很容易被软件检测到，躲过检测的方法是将断点设置在函数内部或尾部；</p>
<h5 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h5><ul>
<li><code>内存断点</code>是通过修改内存属性为不可访问、不可执行来实现的；</li>
<li><code>内存断点</code>同时只能存在一个；</li>
<li><code>内存断点</code>在重载程序后会丢失，需要重新设置；</li>
<li><code>内存断点</code>会影响程序的运行速度；</li>
</ul>
<h5 id="内存访问一次性断点"><a href="#内存访问一次性断点" class="headerlink" title="内存访问一次性断点"></a>内存访问一次性断点</h5><p>在内存窗口（Alt + M），每个区段都有相应的权限（属性），选择区段并按下 F2 后，可以设置一次断点，且属性可以单独设置；</p>
<p>断点生效后会被自动删除，所以叫做一次性断点；</p>
<h5 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h5><ul>
<li><code>硬件断点</code>最多可以设置 4 个；</li>
<li><code>硬件断点</code>在设置位置的下一条指令中断；</li>
<li>可以使用命令<code>HE xxxxxxxx</code>快速设置一个<code>硬件执行断点</code>；</li>
<li>可以使用命令<code>HE MessageBoxA</code>在<code>API</code>的行首快速设置一个<code>硬件执行断点</code>；</li>
<li><code>HW xxxxxxxx</code>设置<code>硬件写入断点</code>；</li>
<li><code>HR xxxxxxxx</code>设置<code>硬件读取断点</code>；</li>
<li>硬件断点只能手动删除或执行删除；</li>
</ul>
<p>硬件断点和 DRx 调试寄存器有关；</p>
<p>DRx 调试器一共有 8 个（DR0 ～ DR7）：</p>
<ul>
<li>DR0 ～ DR3:调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点；</li>
<li>DR4 ～ DR5：保留，未公开具体作用；</li>
<li>DR6：调试寄存器组状态寄存器；</li>
<li>DR7：调试寄存器组控制寄存器；</li>
</ul>
<p>硬件断点的原理是使用 DR0 ～ DR3 设定地址，并使用 DR7 设定状态，因此最多设置 4 个断点；</p>
<p>硬件执行断点和 CC 断点的作用一样，但不会修改机器码，所以更难检测；</p>
<p>硬件断点的优点是速度快，在 int3 断点容易发现的地方设置硬件断点效果更好，缺点是只能设置 4 个；</p>
<h5 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h5><ul>
<li>满足某个条件的<code>CC断点</code>;</li>
<li>使用<code>shift + F2</code>快速设置条件断点；</li>
<li>OD 的条件断点可以按寄存器、存储器、消息等设断；</li>
</ul>
<h5 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h5><ul>
<li>多了记录断点处函数表达式或参数值的条件断点；</li>
<li>使用<code>shift + F4</code>快速设置条件记录断点；</li>
</ul>
<h5 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h5><ul>
<li>消息断点实际上就是条件记录断点；</li>
<li>在操作窗口或控件时，都会发送一个消息；</li>
<li>在<code>OD</code>的<code>W</code>窗口刷新来获取交互消息；</li>
<li>检测交互（消息循环）来设置<code>消息断点</code>，如<code>101 按键抬起</code>、<code>202 鼠标左键抬起</code>等；</li>
<li>断点生效后，修改条件来记录操作日志，在<code>OD</code>的<code>L</code>窗口查看记录的日志或将日志输出到指定文件来进一步进行分析；</li>
</ul>
<p>Windows 本身是由消息驱动的；</p>
<p>当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断；</p>
<p>消息断点与 int3 断点的区别是：int3 断点可以在程序启动前设置，消息断点只有在窗体被创建之后才能设置并拦截消息；</p>
<p>所有发送的消息都有 4 个参数：1 个窗口句柄（hwnd）、1 个消息编号（msg）和 2 个 32 位长（long）的参数；</p>
<p>Windows 通过句柄来标识它所代表的对象；</p>
<h5 id="API-断点"><a href="#API-断点" class="headerlink" title="API 断点"></a>API 断点</h5><ul>
<li>给系统提供的 API 设置的<code>CC断点</code>；</li>
<li><code>MessageBoxA</code>中的<code>A</code>表示使用<code>ASCII</code>编码；</li>
<li><code>MessageBoxW</code>中的<code>W</code>表示使用<code>Unicode</code>编码；</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>断点</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（一）</title>
    <url>/post/2293324257/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-1">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy1j9yekwj30oc065t9q.jpg" alt="分析"></p>
<p>就是它了，选中它并右键<code>在输入函数上切换断点</code>，然后去<code>断点窗口（B 窗口）</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后运行程序，“随便输入”一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序停在了设置断点的<code>API</code>的行首，在堆栈窗口可以看到<code>API</code>的各种参数，而参数<code>Buffer</code>里存放着函数返回的数据，选中<code>Buffer</code>右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy267st5oj30t00drq4u.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下<code>Ctrl + F9</code>或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现<code>Buffer</code>对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下<code>F7 或 F8</code>，返回到调用<code>API</code>的程序，发现接下来将要执行的代码很可疑：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy2kqa9a0j30sz0dt0uo.jpg" alt="程序"></p>
<p>一个比较，一个跳转，并且文字显示和序列号有关；</p>
</li>
<li><p>分析一下这几行可疑的代码：</p>
<ul>
<li><p><code>MOV EDX,CrackMe.00403008</code>将<code>00403008</code>这个地址拷贝到<code>EDX</code>，执行一下这行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy2xlpyn3j308805374d.jpg" alt="EDX"></p>
<p>在<code>EDX</code>存放的地址中发现一串可疑字符串，选中<code>EDX</code>右键<code>数据窗口中跟随</code>，原来可疑字符串只是前面几位，而后面那几个字符是我们输入的字符；</p>
</li>
<li><p><code>MOV EBX,DWORD PTR DS:[403010]</code>将<code>00403010</code>这个地址中的数据的前四个字节拷贝到<code>EBX</code>，执行一下这行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy3ehrs27j30as0ay3zf.jpg" alt="EBX"></p>
<p>既然<code>EBX</code>中存放的是数据，而数据又看不懂，怎么知道是什么呢？<code>OD</code>很强大，选择那行代码并右键<code>数据窗口中跟随，然后选择内存地址</code>或者在数据窗口选中那行代码的数据并选择<code>数据窗口中跟随地址</code>就可以看到<code>EBX</code>中存放的内容了，原来是我们输入的“序列号”；</p>
</li>
<li><p><code>CMP EBX,DWORD PTR DS:[403008]</code>这行代码就没什么好说的了，减法比较是否相等，还使用了一个障眼法，<code>EDX</code>放地址，<code>EBX</code>放数据，在这里再取出<code>EDX</code>的数据进行比较；</p>
</li>
<li><p><code>JE SHORT CrackMe.00401087</code>这行也没啥说的，<code>JE</code>根据<code>ZF 标志位</code>进行跳转，而如果上一步的计算结果为<code>0</code>，则<code>ZF</code>为<code>1</code>，<code>JE</code>跳转成立，也就是说，如果<code>EDX</code>和<code>EBX</code>中的数据相同，那么序列号就是对的，<code>JE</code>跳转并向下执行，最后弹出<code>正确！</code>，反之则不跳转向下执行，弹出<code>序列号错误！</code>，看来第一步中发现的可疑字符串就是真正的序列号了；</p>
</li>
<li><p>如果想要输入啥都能通过验证，那么可以将<code>JE</code>改为<code>JMP</code>无条件跳转，保存修改到文件就获得了一个新的程序；</p>
</li>
<li><p>但我们的目的是找出真正的序列号，所以嘛，复制那串字符去试一下，果然，一切如我们所料！</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（三）</title>
    <url>/post/4122547819/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-3">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><h5 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h5><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
<ul>
<li><p>这个 CrackMe 不一般，有两个部分，两个按钮，那就分两部分分析喽（这句话绕不绕）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeer5jilj309a0740su.jpg" alt="CrackMe"></p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyek762n6j30k20cgq4j.jpg" alt="第一部分"></p>
<p>很好的开始，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeq2lafej311s0kx415.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，多么令人兴奋的内容，这么简单吗，会不会有诈？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeumc7cqj30m60bbmyl.jpg" alt="第一部分找到了"></p>
</li>
<li><p>那就分析一下，看看到底是啥：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyf5uv9tsj30nc0b1gms.jpg" alt="第一部分结束"></p>
<p>看来第一部分很简单，逻辑简单粗暴，只要不对直接弹出错误；<br>第一部分到此结束。<br>既然第一部分这么简单，那难点肯定在第二部分，去看看！</p>
</li>
</ul>
</li>
</ol>
<h5 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h5><ul>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，还是那个可疑的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfexxb79j30kc0cmabo.jpg" alt="第二部分"></p>
<p>很好的开始，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfhdwjazj311o0l076u.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，哦豁，好像没啥有用的内容，等等，下面还有个<code>GetWindowTextA</code>，对对，我们输入了用户名和密码，那就得获取两次，而第一次获取的是密码，那就<code>F9</code>再运行程序；</p>
</li>
<li><p>是的，又获取了一次，而这次获取的是用户名，执行到用户代码，果然是下面这个<code>GetWindowTextA</code>，那下面就是比较的代码了呗，毕竟它位于获取和弹窗之间；</p>
</li>
<li><p>那就分析一下它的流程：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfxtvb0yj30ng0ecq43.jpg" alt="开始"></p>
<ul>
<li><p>第一行<code>TEST EAX, EAX</code>不迷茫，<code>TEST EAX, EAX</code>表示检查<code>EAX</code>自身是否为 0，而第二行的<code>JE SHORT 硬编码寻.0040167E</code>指向了一个<code>MessageBoxA</code>，那就说明<code>EAX</code>很重要，既然弹窗提示的是<code>必须输入用户名才可以</code>，那它不是用户名的长度是什么，况且<code>EAX</code>里的数据刚好和用户名长度相同；</p>
</li>
<li><p>接下来，它对用户名做了一系列的运算，并把运算的结果放到了指定的内存中，暂时还不知道它想干嘛：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyh5fsj3gj30ox082753.jpg" alt="用户名"></p>
</li>
<li><p>同样的，又对输入的假序列号进行了一系列运算，并把运算结果放到了指定的内存中，不过相对于用户名，序列号的处理比较简单，只是进行了除法运算，并存储了余数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyh8v4k4vj30oz05faah.jpg" alt="假码"></p>
</li>
<li><p>直到序列号运算完毕，一个<code>JMP</code>跳下来，分析之后，终于知道了它要干什么：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyhc0gpmtj30oy08ddgr.jpg" alt="比较"></p>
<p>原来，它上面进行的一系列运算，是为这一步的比较做准备；</p>
</li>
<li><p>至此，终于分析出了结果：这里没有硬编码，而是软编码，序列号是根据用户名计算出来的</p>
</li>
<li><p>至于计算的规则：</p>
<ul>
<li><p>用户名的运算规则：用户名的下标从零开始，每个字节依次和<code>A</code>进行除法运算，然后用余数和下标异或之后的值加 2；</p>
</li>
<li><p>序列号的运算规则：序列号的每个字节和<code>A</code>进行除法运算，然后用余数和用户名运算的结果进行比较；</p>
</li>
<li><p>序列号的算法：任意数字和<code>A</code>进行乘法运算，并加上用户名每个字符运算的结果就是这个用户名对应的序列号，运算的结果必须可以转为<code>ASCII</code>码中的数字；</p>
</li>
<li><p>例如：</p>
<ul>
<li><p>用户名： yang</p>
</li>
<li><p>运算的结果：03 08 04 02</p>
</li>
<li><p>序列号算法：<code>5 * A + 3 = 35</code> <code>4 * A + 8 = 30</code> <code>5 * A + 4 = 36</code> <code>5 * A + 2 = 34</code></p>
</li>
<li><p>转成 ASCII：5064</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyhyvwfqlj30d2074aaa.jpg" alt="成功"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（二）</title>
    <url>/post/3097998650/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-2">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy5o1g2gpj30g90bwjsq.jpg" alt="函数"></p>
<p>很好的开始，在<code>GetDlgItemTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy5y9rif4j30sr0fsq51.jpg" alt="运行"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，哇，密密麻麻全是汇编语句，往下翻了翻，也没发现什么关键字、有用的信息，接着<code>F9</code>运行，直接弹出了错误信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy69uwm08j303z03z0sn.jpg" alt="弹窗"></p>
</li>
<li><p>看来此路不通啊，但是“程序给我们关上了一扇门，同时又开了一扇窗”，没错，就是它，弹窗，在最开始的函数列表中也有它的身影<code>MessageBoxA</code>，那就从它入手试试；</p>
</li>
<li><p>禁用<code>GetDlgItemTextA</code>并设置<code>MessageBoxA</code>断点，重新运行程序，输入并运行程序后，拦截到了即将要弹出的信息，信息显示在堆栈窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy6hpjnooj30ug0i0wgm.jpg" alt="错误"></p>
<p>如果程序继续运行，将弹出<code>错误！</code>弹窗；</p>
</li>
<li><p>堆栈窗口的顶部显示的是调用信息，包括调用地址、返回地址等</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy6m2r60qj30cw05q0t2.jpg" alt="堆栈"></p>
</li>
<li><p>堆栈顶端，也就是当前<code>ESP</code>指向的堆栈中则是调用地址，也就是说这个地址调用了<code>MessageBoxA</code>这个<code>API</code>，根据程序的流程：程序经过比较之后，发现序列号不对，所以调用<code>MessageBoxA</code>并弹出错误窗口。<br>按照这个逻辑，如果跟随调用地址，是不是就能找到程序进行比较的代码？那还等什么，右键堆栈顶端的地址（堆栈中被标注黑色背景的地址就是堆栈顶端）选择<code>反汇编窗口中跟随</code>，就来到了调用<code>MessageBoxA</code>的程序，查看上面的代码，发现了一些端倪：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy7fm1cz5j30ue0j8jur.jpg" alt="调用"></p>
<p>上面有一个<code>JNZ</code>跳转进来，从而调用了<code>MessageBoxA</code>，所以弹出了错误弹窗，而<code>JNZ</code>的下面还有一个<code>MessageBoxA</code>，那可以猜测，如果不跳转继续向下执行，很有可能弹出的就是注册成功的弹窗，<code>JNZ</code>根据<code>ZF 标志位</code>进行跳转，如果修改<code>ZF 标志位</code>为<code>1</code>，就可以验证一下猜测是否正确，如何修改呢，继续往上翻代码，嘿嘿，发现一个有用的东西<code>GetDlgItemTextA</code>，在调用地址双击数据窗口设置<code>CC断点</code>，重载程序</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy84b4uhoj30uc0j7acn.jpg" alt="重载"></p>
</li>
<li><p>输入并运行程序后，在最后设置断点的地方停了下来，那下面就是要执行的代码了，分析一下看能不能找到隐藏的序列号：</p>
<ul>
<li><p>才分析了几行代码，有一种上了恶当的感觉，感觉它在转移某些内容，就暂且将它转移的内容称为“可疑字符串”：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy8q1uc0zj30p50740ts.jpg" alt="序列号"></p>
</li>
<li><p>不管了，继续分析，依然没有收获：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy90t76crj30om05zjrs.jpg" alt="没有收获"></p>
</li>
<li><p>直到分析了一个轮回，终于有了收获，程序会用我们输入的序列号的每一个字节的机器码减 14 后，和指定的机器码进行比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy9zbazz5j30p10ac75f.jpg" alt="循环"></p>
</li>
<li><p>而我们利用<code>MessageBoxA</code>断点，分析的<code>JNZ</code>的跳转条件是：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyb22if59j30p10hewgy.jpg" alt="JNZ"></p>
</li>
<li><p>如何让条件成立呢？恰恰在我们没有分析到的代码，因为我们输入的序列号是错误的，所以正确的代码根本不会执行，更谈不上分析了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybg7od2pj30p20acjsn.jpg" alt="正确"></p>
<p>在这里，如果是正确的序列号，那么每次比较完成后，<code>EBP - 10</code>和<code>EBP - 34</code>作为两个计数器，它们会正确的同时自增，在最后的比较长度时也就会相等了；</p>
</li>
</ul>
</li>
<li><p>所以，正确的序列号是什么呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybxcwm3ej30p00abjtb.jpg" alt="序列号"></p>
<ul>
<li>在比较的位置设置断点，获取每次比较时给定的字符的机器码，然后加上 14，最后转为 ASCII 码，就是正确的序列号；</li>
<li>获取到的给定字符的机器码：<code>1D 1E 1F 44 61 51 3C 5B 36 55 51</code>；</li>
<li>字符的机器码加 14 之后的值：<code>31 32 33 58 75 65 50 6F 4A 69 65</code>；</li>
<li>转换为 ASCII 码后的值：123XuePoJie；</li>
</ul>
</li>
<li><p>最后，完整的分析图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyciwo9jqj30y80u0tf0.jpg" alt="完整图"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（五）</title>
    <url>/post/755681865/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-5">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻还真不少，善用搜索，<code>GetDlgItemTextA</code>没找到，那就试试<code>GetWindowTextA</code>，还真有，就它了，在<code>GetWindowTextA</code>上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p><code>F9</code>运行程序，然鹅，输入内容并点击验证按钮后，程序并没有暂停；</p>
</li>
<li><p>界面有按钮，试试消息断点，还是没用，又尝试<code>硬件断点</code>以及<code>内存断点</code>均无效之后，只能去翻大佬的教程，以下内容是学习了<a href="http://xuepojie.com/"><code>Shark恒</code></a>大佬的教程之后自己的总结；</p>
</li>
<li><p>使用一个特殊的<code>API：TranslateMessage</code>，没错，它的功能就是字面的意思<code>翻译虚拟按键消息为字符消息</code>，很好很强大；</p>
</li>
<li><p>在<code>API</code>列表页面搜索，还真有，设置断点，然后在<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，还没有完，在断点上右键<code>断点&gt;&gt;条件记录</code>或者<code>Shift + F4</code>（也就是<code>条件记录断点</code>，毕竟<code>API断点</code>的本质就是<code>CC断点</code>），修改条件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjea06qzj311u0nfad3.jpg" alt="TranslateMessage"></p>
</li>
<li><p>然后运行程序，输入并点击验证，程序在<code>TranslateMessage</code>函数的行首暂停下来，然后<code>Ctrl + F9</code>或者点击菜单栏的调试选项并选择<code>执行到返回</code>，然后<code>F8</code>单步执行到程序领空；</p>
</li>
<li><p>然后在<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，搜索输入的序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjv4k2qij311w0ngn0d.jpg" alt="查找"></p>
<p>找到最接近<code>输入的序列号</code>的内容，设置<code>内存访问断点</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjz6z1umj311m0n7tc9.jpg" alt="内存访问断点"></p>
</li>
<li><p>运行程序，程序暂停在了读取序列号的地方，开始分析：<br>好聪明的“程序”，开始转移数据了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizk98xwaej313w0ncdis.jpg" alt="转移数据"></p>
</li>
<li><p>既然它都挪窝儿了，咱也别闲着了：在<code>EDI</code>上右键选择<code>数据窗口中跟随</code>,果然，输入的序列号在这里了，选择序列号的数据右键<code>断点&gt;&gt;删除内存访问断点</code>删除第一次设置的<code>内存访问断点</code>，也可以理解为设置在<code>ESI</code>上的<code>内存访问断点</code>，既然数据都转移了，断点也就没意义了，所以要重新设置在<code>EDI</code>上，再次选择序列号的数据右键<code>断点&gt;&gt;内存访问</code>，这样就实时掌握了输入的序列号的动向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizko5erudj31450o7gpl.jpg" alt="EDI"></p>
</li>
<li><p>继续运行程序，终于来到来最关键的地方：比较</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizlfw3ua4j313q0s4dky.jpg" alt="比较"></p>
<p>分析完毕，逻辑简单粗暴：</p>
<ul>
<li>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>最后，恢复寄存器的内容并<code>RETN</code>，直接弹出错误的弹窗；</li>
</ul>
</li>
<li><p>分析的时候已经发现了正确的序列号，也就是可疑字符串，试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizm3afyiyj30am0btacd.jpg" alt="完工"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（六）</title>
    <url>/post/1208254864/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件：<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-3">中文搜索引擎</a>和<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-4">ApiBreak</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-6">CrackMe</a>【歪坑牌 CM2.2】来自互联网，仅供学习使用；</li>
<li><a href="http://xuepojie.com/"><code>Shark恒</code></a>大佬教了一种方法，但中间部分内容需要经验判断，才疏学浅的我一直不明白，经过多次失败后总结出了属于自己的方法，So，设置断点的思路来源于大佬，分析的过程属于自己；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
<ul>
<li><p>这个软件的操作有点不同寻常，填写内容之后会提示注册成功，并且通过重启来验证是否正确：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ctzk1nmj30vq089dh5.jpg" alt="流程"></p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻还真不少，搜索一下，<code>GetDlgItemTextA</code>没找到，那就试试<code>GetWindowTextA</code>，还真有，在<code>GetWindowTextA</code>上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p><code>F9</code>运行程序，输入并点击登录之后，还是熟悉的弹窗，点击弹窗的确定按钮之后，嘿，又回到了解放前，这让我很困惑，难道它是在弹窗之后运行吗？毫无头绪；</p>
</li>
<li><p><code>TranslateMessage</code>呢？没有 Buffer，无从下手；</p>
</li>
<li><p>给<code>MessageBox</code>设置断点？皮，它都重启了，断点有什么*用，逆推呢？设置断点跟随之后发现没有什么有价值的内容；</p>
</li>
<li><p>试一试<code>内存断点</code>，暂停的地方不重要而且在断点位置无限循环，根本连登录按钮都点不了，既然都没有登录肯定没有验证，断点的地方当然不重要了；</p>
</li>
<li><p>试试<code>消息断点</code>，暂停了，但没有 Buffer，无从下手；</p>
</li>
<li><p>试试<code>中文搜索引擎</code>，跟了很久，一无所获；</p>
</li>
<li><p>至于<code>硬件断点</code>，一直不懂它的工作原理，不敢乱用，说白了就是用不明白；</p>
</li>
<li><p>既然自己搞不定，关了它放弃又不是我的性格，那还能怎么样？<code>量力而行，虚心请教</code>，以下内容是学习之后的总结：</p>
<ul>
<li><p>原来，<code>中文搜索引擎</code>不只是找关键字的，之前的用法只是个皮毛，还可以找到其它有用的信息，而恰恰这才是重点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0e6c5pycj312m0ksmzu.jpg" alt="关注点"></p>
</li>
<li><p>如果看到<code>software</code>说明这个程序使用了注册表，而关键信息可能就存储在注册表中：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ear0vunj31220kyjsu.jpg" alt="注册表"></p>
</li>
<li><p>既然它将输入的内容存储在注册表中，那么验证的时候一定会去注册表取回内容，所以这个节点才是关键的环节，重载程序，删除之前设置的无用断点，接下来就是重点了；</p>
</li>
<li><p>至于如何设置断点呢，那就要使用今天的主角儿了<code>ApiBreak</code>，点击菜单栏的插件选项并选择<code>ApiBreak &gt;&gt; API断点</code>，然后选择<code>注册表</code>以及<code>RegQueryValueExA</code>选项之后，点击确定;(翻译一下<code>RegQueryValueExA</code>：<code>Reg</code>是注册表，<code>Query</code>是查询，<code>Value</code>是值，<code>ExA</code>是 16 进制，连起来应该是<code>设置查询注册表16进制值的断点</code>，不知道对不对)</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0eovwbz4j312m0kv77d.jpg" alt="设置断点"></p>
<p>当然，也可以直接使用系统 API<code>RegQueryValueExA 或 RegQueryValueExW</code>来设置断点，这个插件就是简化了操作步骤，不用我们去寻找系统 API；</p>
</li>
<li><p>设置好断点之后，运行程序，程序会中断多次，应该是查询了很多次，但我们的关注点只是两个：<code>用户名</code>和<code>密码</code>，那就继续运行程序，直到在堆栈窗口看到需要的信息：</p>
<p><code>用户名</code>出现了两次，第一次<code>Buffer</code>中没有地址，第二次<code>Buffer</code>中才有地址，第二次才是我们关注的重点， 在<code>Buffer</code>上右键<code>数据窗口中跟随</code>，然后<code>Ctrl + F9</code>执行到返回，果然，它获取了我们输入的用户名：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0f4rlxcbj312j0kttc1.jpg" alt="用户名"></p>
<p>同样的情况也会出现在<code>密码</code>身上，继续运行程序，获取密码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0fbu0phrj312i0kvgp0.jpg" alt="密码"></p>
</li>
<li><p>既然它已经获取了用户名和密码，那就上正菜吧：<br>获取密码后，在<code>Buffer</code>上右键<code>数据窗口中跟随</code>，然后<code>Ctrl + F9</code>执行到返回，果然，它获取了我们输入的密码，在<code>数据窗口</code>选中密码数据右键<code>断点 &gt;&gt; 内存访问</code>设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0fkgngw7j312k0kqdi4.jpg" alt="内存访问断点"></p>
</li>
<li><p>然后继续运行程序，程序中断了，但看了看代码发现这里不是重点，而且继续运行还会中断，数一数，中断的次数刚好是密码的长度，并且每运行一次，<code>ESI寄存器</code>中存储的密码都会向后移动一位；</p>
</li>
<li><p>继续运行程序，程序再次中断，重点来了，开始分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1rveiykej312e0rfwj6.jpg" alt="分析完毕"></p>
<p>分析完毕，逻辑似曾相识的感觉，没错，和<code>逆向分析之硬编码寻找序列号（五）</code>中的逻辑一模一样：</p>
<ul>
<li>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>最后，恢复寄存器的内容并<code>RETN</code>，然后弹窗，最后回到解放前；</li>
</ul>
</li>
</ul>
</li>
<li><p>分析完了，那真正的密码是什么呢？当然就是“可疑字符串”：一串看起来杂乱无章的字符，那密码的计算规则又是什么呢？</p>
<p><code>RETN</code>返回的地方永远是调用它的位置的下一行，那如果跟着<code>RETN</code>是不是就能找到调用它的地方，结果是肯定的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0laiieabj312h0rfadz.jpg" alt="调用"></p>
<p>如果<code>JNZ</code>是返回的位置，那上面一行的<code>CALL</code>就是调用的地方，如何证明呢？很简单，<code>JNZ</code>根据<code>ZF 标志位</code>跳转，如果跳转肯定就注册失败了，那不跳转是不是就成功了？试一试，将<code>ZF 标志位</code>置 1，然后运行程序，正如所料，注册成功：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0lezrrqtj30bi067t8s.jpg" alt="注册成功"></p>
<p>这就说明，这个<code>CALL</code>很重要，给<code>CALL</code>的位置设置断点，重载程序，程序在<code>CALL</code>的位置暂停，既然<code>CALL</code>内部是判断，那上面很可能就是获取并处理了，既然正确的密码是一串杂乱无章的字符，那么它应该需要一个<code>CALL</code>去处理，所以，大胆的猜测一下，上面那个<code>CALL</code>可能就是处理程序，给上面那个<code>CALL</code>也设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0lu3l9iuj312g0rfq7j.jpg" alt="处理"></p>
<p>再次重载程序，程序中断，<code>F8</code>向下执行，查看中间那两行代码干了什么，很有可能就是判断<code>CALL</code>（也就是函数）的参数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0m4afip8j312g0rh78w.jpg" alt="参数"></p>
<ul>
<li>两行代码执行后，<code>EAX</code>的数据在<code>寄存器窗口</code>看的很清楚，就是我们输入的假码；</li>
<li>而<code>EDX</code>的数据是什么呢？选中<code>EDX</code>右键<code>数据窗口中跟随</code>，数据一目了然，正是比较时用的可疑字符串；</li>
<li>这也就证明了，上面那个<code>CALL</code>就是处理数据用的；</li>
<li>而密码的规则：在好多个<code>CALL</code>之间跳来跳去分析之后，发现是一串固定的字符串加上用户名的 16 进制表示；</li>
<li>如：<code>yang</code>转换成 16 进制是<code>79616E67</code>，那么密码就是<code>€队蠹易仿耄79616E67</code>；</li>
</ul>
</li>
<li><p>测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0mxfxvr3j30v508p758.jpg" alt="测试"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（四）</title>
    <url>/post/1116999438/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code>插件：<a href="https://github.com/Undeio/undeio.github.io/releases/tag/Plugin-3">中文搜索引擎</a>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-4">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><p>事实证明：不能“以貌取人”。</p>
<p>刚打开软件的时候，心里还想着，这么简陋？分分钟就逆向完毕了，结果，“啪啪啪”实力打脸，针扎的疼。</p>
<p>嗯，还在学习阶段，等我功力深厚之时，定会找回场子！</p>
<ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻，呀呵，看着简陋，用的<code>API</code>还真不少，那就搜索吧，没有<code>GetDlgItemTextA</code>？那就拿<code>GetWindowTextA</code>下手吧：在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>居然没有断下来，也没有弹窗，这让我很尴尬：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8frx378j305905zglj.jpg" alt="尴尬"></p>
</li>
<li><p>嗯，界面有按钮，那就试试消息断点，熟练的设置好<code>消息断点</code>，运行程序，输入，点击按钮，还是没有断下来；</p>
</li>
<li><p>不怕，还有<code>内存断点</code>、<code>硬件断点</code>，挨个试了一遍之后，没有一个成功的，灰心丧气呀，怎么像刺猬 🦔 一样无从下手？</p>
</li>
<li><p>等等，看了看程序的界面，猛的想起了大佬说的一个工具：</p>
<p><code>中文搜索引擎</code>：这玩意儿可以参考，但不要过分依赖，友好的开发者可能只是关闭你的程序不让你调试，至于不友好的，知道为啥要用虚拟机吗？</p>
</li>
<li><p>重载程序，在<code>反汇编窗口</code>右键选择<code>中文搜索引擎</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8ldzoguj311o0njq5w.jpg" alt="中文搜索引擎"></p>
<p>然后<code>Ctrl + F</code>搜索熟悉的字眼儿<code>Wrong Code DUDE</code>，果然有，双击来到<code>反汇编窗口</code>，嘿嘿，这里看起来很重要嘛：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8xso4qtj30m90by402.jpg" alt="关键"></p>
<ul>
<li>一个失败的字样；</li>
<li>一个成功的字样；</li>
<li>紧挨着上面有一个跳转：可以猜测，如果跳转的话，可能就显示成功了；</li>
<li>跳转上面是一个<code>CALL</code>，那它很可能是比较的<code>CALL</code>；</li>
<li>至于更上面的代码，那肯定是获取用的呗，瞎猜的；</li>
</ul>
</li>
<li><p>既然找到了可疑的代码，那就双击<code>CALL</code>给它下一个<code>CC断点</code>，然后运行程序，输入序列号点击验证后，程序暂停在了<code>CALL</code>的位置，那就<code>F7</code>进<code>CALL</code>看看，验证一下猜测；</p>
</li>
<li><p>刚一进<code>CALL</code>，就在寄存器窗口发现了熟悉的字样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz99kl1svj311n0nlgoq.jpg" alt="call"></p>
<p>既然把“序列号”都传进来了，那应该就是比较了，开始分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizaftudazj30xb0u0n15.jpg" alt="分析"></p>
</li>
<li><p>分析完成，比较的部分是常规方法，就是中断程序有点麻烦！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之软编码寻找序列号（一）</title>
    <url>/post/4167455493/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0t1wtpivj308z0anmxb.jpg" alt="开始"></p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，用的<code>API</code>不多，一眼就看到了<code>GetDlgItemTextA</code>，在<code>GetDlgItemTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，输入用户名和注册码，点击确定；</p>
</li>
<li><p>程序断下来了，在堆栈窗口选择<code>Buffer</code>右键<code>数据窗口中跟随</code>，没有数据，因为断点在行首，<code>Ctrl + F9</code>或者点击菜单栏调试选项，选择<code>执行到返回</code>，再去数据窗口中看看，有数据了，是我们输入的用户名；</p>
</li>
<li><p>再次运行程序，程序再次中断，不出意外应该是获取注册码，在堆栈窗口选择<code>Buffer</code>右键<code>数据窗口中跟随</code>，没有数据，<code>Ctrl + F9</code>或者点击菜单栏调试选项，选择<code>执行到返回</code>，再去数据窗口中看看，有数据了，是我们输入的注册码；</p>
</li>
<li><p>能获取到数据就是一个好的开始，<code>F7 或 F8</code>单步执行到程序领空，熟悉的字样映入眼帘：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tc5u51bj312e0t3q6p.jpg" alt="程序领空"><br>既有我们输入的内容，也有提示字样，应该就是这里了，那就开始分析；</p>
</li>
<li><p>前面的代码是堆栈平衡和清除弹窗的代码，进<code>CALL</code>之后，直接<code>ALT + F9</code>或者点击菜单栏调试选项，选择<code>执行到用户代码</code>；</p>
</li>
<li><p>需要分析的代码来了：刚分析了两行，发现了几行特别的代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tni2rn6j30oy03hmxm.jpg" alt="发现"></p>
<p>这几行代码，一个<code>push</code>然后紧跟着一个<code>CALL</code>，而且 push 的是我们输入的内容，这里应该就是关键了；</p>
</li>
<li><p><code>F7</code>进第 1 个<code>CALL</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tswn8jfj30ox01owee.jpg" alt="用户名call"></p>
<ul>
<li><p>刚进来第 1 行代码有困惑的吗？你咋知道是用户名放入<code>ESI 寄存器</code>？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tvmwgxqj312j0satc7.jpg" alt="第一行"></p>
<p>很简单，<code>[ESP+4]</code>告诉我的，<code>ESP 寄存器</code>永远指向堆栈的顶端，那<code>[ESP+4]</code>就是下一行喽，看一眼堆栈窗口，第二行的数据不正是我们输入的用户名吗？</p>
</li>
<li><p>接着，出现了第 2 处令人疑惑的代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0xi158x1j312n0b0q4t.jpg" alt="疑惑1"></p>
<p>机器码和<code>41</code>比较，这到底是啥意思？刚开始我也弄不明白，而且后面的逻辑也显示和<code>41</code>半毛钱关系没有，直到无意中在用户名输入了数字，弹出两次<code>注册失败</code>，才好像明白了这里判断的是啥？我们先看看 16 进制的<code>41</code>到底是什么：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0xochjx2j30b50bs3ys.jpg" alt="41"></p>
<p>原来<code>41</code>是大写字母<code>A</code>，而后面的<code>5A</code>则是大写字母<code>Z</code>，那我好像明白怎么回事儿了，它应该是在判断用户名是否是英文字母；</p>
</li>
<li><p>当字符的机器码大于<code>41</code>并且大于<code>5A</code>时，程序会跳转到一个新的<code>CALL</code>，那它干了什么呢：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0y7pkvqij312l0sc432.jpg" alt="新CALL"></p>
<p>可以看到，这里只有 3 行代码，我们分析一下，小写字母的机器码减去<code>20</code>是什么，没错，是对应的大写字母，这三行代码的作用就是：将用户名转换为大写字母，然后用大写字母替换用户名中的小写字母，然后返回：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0z4k7ifkj312m0sbn3m.jpg" alt="大写"></p>
<p>当用户名全部转为大写字母之后，又来到了一个<code>CALL</code>，这个<code>CALL</code>又是干什么的呢，<code>F7</code>跟进去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0zamesrsj312k0sbwic.jpg" alt="新CALL"></p>
<p>原来，是将转换为大写字母后的用户名的每个字节的机器码累加在一起，然后和<code>5678</code>异或，并把异或后的结果放入<code>EAX</code>并返回：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0zluaydsj312k0se0xd.jpg" alt="返回"></p>
</li>
</ul>
</li>
<li><p>用户名处理完了，接下来就是注册码了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ztl37fnj30oy03daa7.jpg" alt="比较"></p>
<p>刚从用户名的连环<code>CALL</code>里出来就这么刺激吗？把用户名运算后的结果和我们输入的注册码都 push 到了这个<code>CALL</code>里面，这里应该就是比较了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj10dmcv8zj30ox06cwey.jpg" alt="注册码"></p>
<p>结果很打脸啊，不是验证<code>CALL</code>而是运算注册码的<code>CALL</code>，而第一行的<code>PUSH EAX</code>只是个入栈而已。。。</p>
</li>
<li><p>验证环节</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj10q4hzwfj30k6063wf9.jpg" alt="验证"></p>
<p>根据<code>CALL</code>跳转的位置，轻松知道它的用途；</p>
</li>
<li><p>注册码的计算规则：</p>
<ul>
<li>用户名必须是字母；</li>
<li>将每个字母转为大写字母；</li>
<li>把每个字母的 16 进制累加在一起；</li>
<li>累加的结果与 5678 异或；</li>
<li>异或后的结果与 1234 异或；</li>
<li>将最后的结果转为 10 进制，注册码就出来啦；</li>
</ul>
</li>
<li><p>无图无真相</p>
<ul>
<li><p>例如：<code>yang</code>的大写<code>YANG</code>的 16 进制是<code>59 41 4E 47</code>；</p>
</li>
<li><p>加在一起是<code>59 + 41 + 4E + 47 &gt;&gt; 12F</code>；</p>
</li>
<li><p><code>12F</code>与<code>5678</code>异或<code>xor 12F, 5678 &gt;&gt; 5757</code>；</p>
</li>
<li><p><code>5757</code>与<code>1234</code>异或<code>xor 5757, 1234 &gt;&gt; 4563</code>；</p>
</li>
<li><p><code>4563</code>转为 10 进制后<code>17763</code>;</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj119l81wcj30b50csdg7.jpg" alt="上图"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之软编码寻找序列号（三）</title>
    <url>/post/2238585999/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-9">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<ul>
<li><p>这是一个类似于蜘蛛纸牌的程序，需要安装，安装完成打开之后会提示输入注册码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2whju29rj310e0so0sw.jpg" alt="开始"></p>
</li>
<li><p>输入用户名和 6 位数字的注册码之后，发现<code>Ok</code>按钮无法点击：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wjvydm4j30ad07i746.jpg" alt="按钮"></p>
<p>有点意思，看来只有输入正确的序列号按钮才能点击，至于为啥注册码是 6 位数字，它不是已经说明了吗？</p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>猜测一下它的工作原理，如果在输入正确的注册码之后按钮可以点击，那就说明它会实时获取我们输入的内容并进行判断，这样的话，有用的应该就是<code>内存断点</code>了；</p>
</li>
<li><p>说干就干，既然要去内存中找我们输入的内容，那输入就一定得个性一点，起码不是内存中常见的，不然一找一大堆就无从下手了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wrgno31j309q06zmx1.jpg" alt="输入"></p>
</li>
<li><p>然后去<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，输入我们的序列号点击确定开始查找，记得勾选<code>区分大小写</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wtnjbibj30b806dglh.jpg" alt="查找"></p>
</li>
<li><p>输入的还算奇葩，只找到了一个：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wwddjlcj319s0rgaap.jpg" alt="查找结果"></p>
</li>
<li><p>设置<code>内存访问断点</code>，既然它都告诉我们是 6 位了，那就设置 6 个字节：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wytjh8dj319r0rct9e.jpg" alt="设置断点"></p>
</li>
<li><p>然后去程序界面再输入一个字符后，发现程序中断了，回到<code>OD</code>看看，嘿，它居然在转移数据，在数据窗口跟随一下<code>EDI</code>，果然是我们输入的假序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2x6v1zckj319p0qoq3v.jpg" alt="转移数据"></p>
</li>
<li><p>既然数据都挪窝儿了，那之前的断点也就没用了，选择<code>EDI</code>的数据右键<code>断点 &gt;&gt; 内存访问</code>重新设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xbtwkjcj319q0qmq3p.jpg" alt="新断点"></p>
</li>
<li><p>断点设置好之后，<code>F9</code>继续运行程序，程序再次中断，发现又在挪窝儿？怎么回事儿，挪窝儿这么快乐吗？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xgb4q4mj319p0rc3zj.jpg" alt="又一个断点"></p>
<p>重新设置<code>内存访问断点</code>，然后继续运行程序；</p>
</li>
<li><p>程序再次中断，并且有比较有跳转，这儿可能就是重点了，分析一下：</p>
<ul>
<li><p>第 1 行是：<code>EAX</code>的前 4 字节数据拷贝到<code>EDX</code>，<code>F7</code>单步执行，然后查看一下是什么东西：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xsh9gtlj319o0qnwfg.jpg" alt="查看EAX"></p>
<p>原来是我们输入的假序列号，前面还多了个<code>04</code>，应该是长度吧；</p>
</li>
<li><p>第 2 行是：<code>EDX</code>的前 4 字节数据拷贝到<code>EBX</code>，<code>F7</code>单步执行，然后查看一下是什么东西：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xx6m4ydj319o0qnab0.jpg" alt="查看EDX"></p>
<p>嘿嘿，一串可疑的数字，而且是 6 位，和序列号的规则很吻合，而且前面多了个<code>06</code>，应该也是长度；</p>
</li>
<li><p>接着往后分析，逻辑很常规，比较完前四个字节比较长度，都不相等就返回了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2y4ynby5j319s0qlgmp.jpg" alt="返回"></p>
</li>
</ul>
</li>
<li><p>结局没有悬念，用户名对应的序列号就是那串数字，不过，序列号是如何计算出来的呢？我们接着分析：</p>
<ul>
<li><p>我们都知道<code>RETN</code>返回的是调用位置的下一行，那跟着<code>RETN</code>去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2yc0ugkuj319u0qngml.jpg" alt="RETN"></p>
<p>按照程序的流程，既然这里是判断，那上面的就是获取和处理了，上面<code>CALL</code>不少，哪一个才是我们想要的那个呢，按照先获取后处理的流程来看，离我们最近的那个<code>CALL</code>应该是处理用的，但<code>CALL</code>上面那行代码看着也不像是给它传递参数，那就在这个<code>CALL</code>上设置断点，进去看看它是干嘛的；</p>
</li>
<li><p>设置好断点，重载程序并运行程序之后，程序都没有加载完成就中断了，既然都没有输入，那肯定不行啦，<code>F9</code>运行程序，起码运行到我们能输入内容；</p>
</li>
<li><p>然后，我们发现，输入用户名的时候，每输入一个字符都会中断一次，那就说明断点有效，虽然不知道这个<code>CALL</code>具体是干嘛的，但肯定和用户名有关，既然每次都中断，那就输入一次运行一次呗，直到用户名输入完成，还没有完，为了防止它没有完全获取用户名（鬼知道它是怎么获取的，万一是运行之后获取呢？），在输入完用户名最后一个字符之后，程序会再次中断，我们再运行程序一次，在序列号一栏中，输入一个字符，发现它中断了；</p>
</li>
<li><p>管它呢，反正用户名输入完了，也在序列号一栏输入字符了，能保证它获取了完整用户名就行，至于它是干啥的，<code>F7</code>进去看看不就知道了：</p>
<ul>
<li><p>刚分析了几行，发现它用同样的方法转移用户名，既然要知道序列号是怎么计算的，那肯定要跟着用户名喽，给<code>EDI</code>中的用户名数据设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2z03oif9j31ay0qqgmf.jpg" alt="用户名"></p>
</li>
<li><p>接着，<code>F9</code>运行程序，程序跳转到了这里，果然，这里就是用来生成序列号的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj30aheyyqj31az0qomy7.jpg" alt="小循环"></p>
<p>这里是一个完整的小循环，用来运算用户名的每一个字符，并且把结果累加，至于运算规则：</p>
<ul>
<li><p>字节下标从 1 开始；</p>
</li>
<li><p>字节机器码和下标相乘；</p>
</li>
<li><p><code>IMUL DWORD PTR DS:[EDX*4+4EB5D8]</code>这行代码中的所有特殊字符：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
<p>从上面的表格可以看出，用户名最大不能超过 16 进制的 14 位，也就是 10 进制的 20 位，代码中也一直和 14 做比较，当然，这是我的猜测，有兴趣的同学可以试试；</p>
</li>
<li><p>然后字节机器码和下标相乘的结果，和表格中对应下标的字符相乘；</p>
</li>
<li><p>接着，把每个字符运算的结果累加；</p>
</li>
<li><p>就这？这么简单？想多了；</p>
</li>
</ul>
</li>
<li><p>接着往下看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj30sq2vhsj31au0qn3zk.jpg" alt="余数"></p>
<p>在上一步，也就是那个小循环中，按照特定的规则运算了用户名的每一个字节，并把每个字节的运算结果进行累加，然后才是这一步，规则如下：</p>
<ul>
<li><p>上一步累加的最终结果和<code>A 的 6 次方</code>进行求余运算；</p>
</li>
<li><p>如果余数大于<code>A 的 5 次方</code>，进行下一步，也就是开始计算序列号，至于为什么要有这么个规定，如果你还记得序列号的规则，那就不会有什么疑惑了，因为只有余数大于<code>A 的 5 次方</code>，才能计算出 6 位数的序列号，看到这句话，是不是已经想到如何计算序列号了，追随你的心，是的，就是那样计算的；</p>
</li>
<li><p>如果余数小于<code>A 的 5 次方</code>，那么就重复执行上一步中的小循环，只不过，这一次的计算结果会累加在上一次计算的最终结果上，也就是，你只需要计算一个完整小循环，如果计算的结果求余<code>A 的 6 次方</code>小于<code>A 的 5 次方</code>，只需要把你计算的最终结果乘以 2，就是下次循环的计算结果，如果乘以 2 的结果求余<code>A 的 6 次方</code>还是小于<code>A 的 5 次方</code>，那就乘以 3 呗，以此类推；</p>
</li>
<li><p>不要急，下面就开始计算序列号了；</p>
</li>
</ul>
</li>
<li><p>接着，就到了计算序列号的<code>CALL</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj31e7p4jlj31ay0qmjsg.jpg" alt="计算序列号"></p>
<ul>
<li>这一步很简单，用累加结果求余<code>A 的 6 次方</code>，然后就是计算序列号的函数了；</li>
<li>到重点了，当然是<code>F7</code>进去看看喽；</li>
</ul>
</li>
<li><p>进<code>CALL</code>之后，你会很惊讶，因为真正的计算就简简单单几行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj31patcpxj31au0qk75i.jpg" alt="计算"></p>
<ul>
<li>用累加结果求余<code>A 的 6 次方</code>后的余数对<code>A</code>进行求余运算；</li>
<li>然后判断商是否为 0，不是 0 ，继续对<code>A</code>进行求余运算，直到商为 0；</li>
<li>把每次对<code>A</code>求余运算的余数加上 30 存起来；</li>
</ul>
</li>
<li><p>还没有结束，最后一步就是把上一步的结果逆序，然后就是真正的序列号了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj3278binyj31au0qmdh2.jpg" alt="剧终"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>啰哩啰嗦终于分析完了，总结一下注册码的生成规则：</p>
<ul>
<li><p>用户名必须小于 10 进制的 20 位，我也不确定啊，没试；</p>
</li>
<li><p>用户名字节的下标从 1 开始；</p>
</li>
<li><p>取用户名每个字节和它对应的下标进行乘法运算；</p>
</li>
<li><p>用每个字节运算的结果乘以对应下标的给定字符，给定字符如下，序号就是下标：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
</li>
<li><p>然后把每个字节乘以给定字符的结果相加；</p>
</li>
<li><p>用相加的结果求余<code>A 的 6 次方</code>，如果余数大于<code>A 的 5 次方</code>，向下执行；如果余数小于<code>A 的 5 次方</code>，用累加的最终结果乘以它的自然数倍数，如 2 倍或者 3 倍，直到最终结果求余<code>A 的 6 次方</code>的余数大于<code>A 的 5 次方</code>；</p>
</li>
<li><p>然后用上一步中的余数，也就是求余<code>A 的 6 次方</code>后的余数，对<code>A</code>进行求余运算，直到对<code>A</code>的求余运算商为 0；</p>
</li>
<li><p>把每次对<code>A</code>求余运算的余数加 30；</p>
</li>
<li><p>把余数加 30 后的数字逆序排列；</p>
</li>
<li><p>转为 10 进制就是用户名对应的序列号；</p>
</li>
</ul>
</li>
<li><p>说人话：</p>
<ul>
<li>16 进制的<code>A</code>是 10 进制的<code>10</code>;</li>
<li><code>A 的 6 次方</code>是<code>1000000</code>，也就是一百万；</li>
<li><code>A 的 5 次方</code>是<code>100000</code>，也就是十万；</li>
<li>也就是说，用户名累加的结果大于一百万的时候，这条规则才真正有意义，否则，对<code>A 的 6 次方</code>求余的余数永远是它自己；</li>
<li>至于为啥要大于<code>A 的 5 次方</code>，十万不就是最小的 6 位数吗？你不大于<code>A 的 5 次方</code>也就是不够 6 位，肯定不行喽；</li>
<li>至于对 10 求余的结果是什么，不用说了吧？</li>
<li>16 进制的<code>30</code>是什么，是 ASCII 码的<code>0</code>，所以，求余后加 0 的意义是什么？</li>
<li>总结：如果你输入的用户名运算的最终结果，转换为 10 进制是 6 位数字，那这个 6 位的数字就是注册码；如果小于 6 位，就用最终结果乘以 2 或 3 或 N，以此类推，直到是 6 位或更多位，当然，6 位最好，因为更多位需要求余 😊；</li>
</ul>
</li>
<li><p>无图无真相：</p>
<ul>
<li><p>例如：<code>crackme</code>的机器码是<code>63 72 61 63 6B 6D 65</code>；</p>
</li>
<li><p>每个字节和它对应的下标进行乘法运算：</p>
<table>
<thead>
<tr>
<th align="center">63 * 1</th>
<th align="center">72 * 2</th>
<th align="center">61 * 3</th>
<th align="center">63 * 4</th>
<th align="center">6B * 5</th>
<th align="center">6D * 6</th>
<th align="center">65 * 7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">63</td>
<td align="center">E4</td>
<td align="center">123</td>
<td align="center">18C</td>
<td align="center">217</td>
<td align="center">28E</td>
<td align="center">2C3</td>
</tr>
</tbody></table>
</li>
<li><p>用每个字节运算的结果乘以对应下标的给定字符：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">63 * D9</th>
<th align="center">E4 * 63</th>
<th align="center">123 * 58</th>
<th align="center">18C * 22</th>
<th align="center">217 * 3E</th>
<th align="center">28E * 93</th>
<th align="center">2C3 * F0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">53EB</td>
<td align="center">582C</td>
<td align="center">6408</td>
<td align="center">3498</td>
<td align="center">8192</td>
<td align="center">1778A</td>
<td align="center">296D0</td>
</tr>
</tbody></table>
</li>
<li><p>把每个字节乘以给定字符的结果相加：<code>53EB + 582C + 6408 + 3498 + 8192 + 1778A + 296D0 &gt;&gt; 5D4A3</code>；</p>
</li>
<li><p>对 10 求余再加 0 之类的操作就没必要了吧；</p>
</li>
<li><p>将<code>5D4A3</code>转换成 10 进制是<code>382115</code>；</p>
</li>
<li><p>输入用户名和注册码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj35sltkm7j30ld0gp0sz.jpg" alt="无图无真相"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之软编码寻找序列号（二）</title>
    <url>/post/3362832349/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-8">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1lnjinquj307x04v0tf.jpg" alt="开始"></p>
<p>有点意思，输入内容之后没有任何提示，看来只有输入正确的序列号才会有提示；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>既然界面没有按钮，那就得先猜测它的工作原理了，如果它会在输入正确之后提示的话，那么它就是实时获取我们输入的内容并进行判断，这样的话，有用的应该就是<code>内存断点</code>了；</p>
</li>
<li><p>说干就干，既然要去内存中找我们输入的内容，那输入就一定得个性一点，起码不是内存中常见的，不然一找一大堆就无从下手了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1lnjinquj307x04v0tf.jpg" alt="输入"></p>
</li>
<li><p>然后去<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，输入我们的序列号点击确定开始查找，记得勾选<code>区分大小写</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m10r2ncj30b806e74c.jpg" alt="查找"></p>
</li>
<li><p>输入的还算奇葩，只找到了两个，选择第二个吧，虽然第一个是独立的，但它在内存中的范围不太像：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m2ueqnpj312j0nlgp6.jpg" alt="找到"></p>
</li>
<li><p>设置<code>内存访问断点</code>，长度随意，看心情，我就选 5 个字节了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m8qdz03j312i0noadj.jpg" alt="内存断点"></p>
</li>
<li><p>然后去程序界面再输入一个字符后，发现程序中断了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mbkjvz1j312k0npgob.jpg" alt="中断1"></p>
<p>不过中断的地方好像没什么用，我们输入的内容在<code>EDX</code>中，下面的代码段并没有操作它，<code>F9</code>继续运行程序；</p>
</li>
<li><p>刚一进程序领空就发现了亮点，这里好像就是比较了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mgimi9aj312i0nljub.jpg" alt="亮点"></p>
</li>
<li><p>分析一番之后发现，逻辑很常规：</p>
<ul>
<li><p>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</p>
</li>
<li><p>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步</p>
</li>
<li><p>最后，恢复寄存器的内容并<code>RETN</code>，然后就杳无音讯了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mp4qouej312g0qqdjn.jpg" alt="比较"></p>
</li>
</ul>
</li>
<li><p>至于正确的序列号，当然就是那串可疑字符串了，那这串字符是怎么来的呢，不能每次都这么找吧：</p>
<ul>
<li><p>我们都知道<code>RETN</code>返回的是调用位置的下一行，那跟着<code>RETN</code>去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mv3jb6bj312i0qnq6f.jpg" alt="调用位置"></p>
</li>
<li><p>按照程序的流程走，既然这里是判断，那上面的就是获取和处理了，上面有好几个<code>CALL</code>，哪一个才是我们想要的那个呢，按照先获取后处理的流程来看，离我们最近的那个<code>CALL</code>应该是处理用的，那么这个<code>CALL</code>上面那两行代码应该就是它的参数，在参数上设置断点，看看参数是什么就知道这个<code>CALL</code>的用途了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1n7mrqnaj312i0qp0w5.jpg" alt="重点"></p>
<p>设置断点，重载程序并运行后，程序中断了，但重点不在<code>反汇编窗口</code>，而是在<code>堆栈窗口</code>，我们发现了可疑字符串也就是正确的序列号，如果我们设置断点的这个<code>CALL</code>是处理函数的话，那么它还没运行怎么会出现正确的序列号呢？取消断点，在它上面那个<code>CALL</code>的参数上设置断点；</p>
</li>
<li><p>和上面的情况一样，程序中断后，在<code>堆栈窗口</code>，我们又发现了正确的序列号，再次取消断点，给它上面那个<code>CALL</code>设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1niua0lfj312g0qrgp0.jpg" alt="新断点"></p>
<p>这次就好多了，虽然没发现有用的数据但正确的序列号也没有出现，那这个<code>CALL</code>很可能就是生成序列号的函数了，<code>F7</code>跟进去看看，结果很丧气，它也不；</p>
</li>
<li><p>那就接着往上呗，终于，在设置好断点，重载并运行程序之后有了欣喜的收获，用户名当作参数传递了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1o2fra1jj312j0qowhy.jpg" alt="真的重点"></p>
<p>虽然还没有运行代码，但信息窗口已经告诉我们它是什么了；</p>
</li>
<li><p>果断<code>F7</code>跟进去看看，都失败那么多次了，不差这一次：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1o7hfyf0j312h0qr0w3.jpg" alt="进CALL"></p>
<p>进来只有四行代码，但内容非常令人兴奋：这几行代码在检测有没有输入用户名；这就是一个好的开始，因为要操作数据的时候才会检测数据有没有输入；</p>
</li>
<li><p>从这个<code>CALl</code>里出来的窗口很熟悉，因为我们在这里已经操作了 3 次了，也失败了 3 次，这次将会是最后一次了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1ofq31sjj312h0qp78t.jpg" alt="多次操作"></p>
</li>
<li><p>这手灯下黑玩儿的漂亮，它一直在眼皮子底下计算序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1q8fz1njj312g0qmn0r.jpg" alt="序列号运算"></p>
<p>这就完了？那序列号呢？嘿嘿，在这里：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1qc14sgtj312i0qn42d.jpg" alt="序列号"></p>
<p>是的，运算结束后，虽然数据保存到了<code>EBP-C</code>的位置，但我们并没有弹栈，所以<code>EAX</code>没有被覆盖，双击<code>EAX</code>试试，对啦，将运算结果转为 10 进制就是这个用户名对应的序列号；</p>
</li>
</ul>
</li>
<li><p>序列号的算法：</p>
<ul>
<li>用户名最少两位；</li>
<li>用户名的下标从 1 开始；</li>
<li>取用户名每个字节和它对应的下标进行异或运算；</li>
<li>所有字节异或后的结果累加在一起；</li>
<li>取最后一个字节的机器码，与对应下标进行异或运算后，循环左移 C 位；</li>
<li>然后把左移的结果和所有字节异或后累加的结果相加；</li>
<li>最后把最终结果转换成 10 进制就是这个用户名对应的注册码；</li>
</ul>
</li>
<li><p>无图无真相</p>
<ul>
<li><p>例如：用户名<code>feng</code>对应的机器码是<code>66 65 6E 67</code>；</p>
</li>
<li><p>用户名的下标从 1 开始；</p>
</li>
<li><p>每个字节分别与它对应的下标进行异或运算<code>xor 66, 1 &gt;&gt; 67</code>，<code>xor 65, 2 &gt;&gt; 67</code>，<code>xor 6E, 3 &gt;&gt; 6D</code>，<code>xor 67, 4 &gt;&gt; 63</code>;</p>
</li>
<li><p>异或后的结果累加<code>67 + 67 + 6D + 63 &gt;&gt; 19E</code>;</p>
</li>
<li><p>取最后一个字节的机器码，与对应下标进行异或运算后，循环左移 C 位<code>xor 67, 4 &gt;&gt; 63</code>，<code>ROL 63, C &gt;&gt; 63000</code>;</p>
</li>
<li><p>然后把左移的结果和所有字节异或后累加的结果相加<code>63000 + 19E &gt;&gt; 6319E</code>；</p>
</li>
<li><p>转换成 10 进制<code>6319E &gt;&gt; 405918</code>；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1qoidbqcj30e409yq41.jpg" alt="真相"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>VB 调试之修改系统 DLL</title>
    <url>/post/1859998567/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-5">OllyDbg</a>修改版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-19">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先运行软件，了解一下程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxyw10rtdj30w20o4go5.jpg" alt="运行程序"></p>
<p>运行程序后，首先弹出一个 NAG 窗口，点击 Register 后弹出程序主窗口，随机输入注册码并点击 OK 后，弹出错误弹窗；</p>
</li>
<li><p>寻找注册码</p>
<p>了解程序逻辑后，接下来需要解决注册码，因为机器码为自动生成，所以对于本机来说，这是一个硬编码，那就非常简单了；</p>
<ul>
<li><p>所见即所得，既然有弹窗，说明程序使用了<code>rtcMsgBox</code>；</p>
</li>
<li><p>随机输入后弹出错误弹窗，说明程序进行了字符串比较；</p>
</li>
<li><p>将程序倒入<code>OD</code>后，前两行代码说明了这是一个 VB 程序（这不是废话嘛，看文章标题就知道了）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyjydya2ij314u0u0gol.jpg" alt="前两行"></p>
<p>VB 程序有个特点：入口处都是一个 PUSH 指令，然后一个 CALL 指令；而且这里的 CALL 指令中的 JMP 后面跟着 MSVBVM60，也间接说明了这是 VB 程序；</p>
</li>
<li><p>接着，按下<code>Ctrl + N</code>查看函数列表，确定一下字符串比较使用的 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmylqjxfegj31550u0ad8.jpg" alt="函数列表"></p>
<p>在其中发现了<code>__vbaStrCmp</code>，程序应该是用这个函数判断真假注册码的；</p>
</li>
<li><p>既然知道了使用的 API，那就给这两个 API 设置断点，并做好备注，然后运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyocxcyy3j314q0u0tbp.jpg" alt="断点禁用再启用"></p>
<p>运行程序后发现，由于<code>__vbaStrCmp</code>比较常用，多次中断在无关的位置，所以，暂时先禁用这个断点，等输入注册码后再启用，然后点击 OK；</p>
</li>
<li><p>程序中断两次，根据堆栈窗口的参数判断，第 1 次是机器码比较，第 2 次才是注册码比较，然后反汇编窗口跟随来到调用位置，在调用函数的参数上设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyon9iwpdj31510u0aem.jpg" alt="反汇编跟随"></p>
</li>
<li><p>禁用<code>__vbaStrCmp</code>断点，重载并运行程序后，程序中断在预期位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyovae4dmj314v0u0n1k.jpg" alt="重载并运行"></p>
<p>但是通过查看参数，发现这里不是理想的位置，应该是用于判断是否有输入；</p>
<p>既然这里不是需要的位置，那就清除此处的断点，启用<code>__vbaStrCmp</code>断点，继续跟踪，不过，在跟踪多次之后，还是遇到了刚开始时候的问题：由于<code>__vbaStrCmp</code>比较常用，会多次中断在无关的位置，那就放弃<code>__vbaStrCmp</code>吧，不是还有<code>rtcMsgBox</code>吗？</p>
</li>
<li><p>禁用<code>__vbaStrCmp</code>断点，重载并运行程序后，程序中断在<code>rtcMsgBox</code>的行首，反汇编窗口中跟随，来到调用位置，因为接下来就要弹窗了，所以字符串比较肯定在弹窗之前，往上翻阅代码，看看有没有<code>__vbaStrCmp</code>，别说，还真有，那还等什么，给<code>__vbaStrCmp</code>的参数设置断点，重载并运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmypbnl0qkj315f0u0djq.jpg" alt="收获"></p>
<p>单步执行程序后，收获颇丰，这里的第 2 参数不再是空，那这里就相当可疑了；</p>
</li>
<li><p>既然拿到了可疑的字符串，当然要试一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmypgwxn53j313c0ny40g.jpg" alt="满意"></p>
<p>嗯，这个弹窗甚是满意，这串字符就是本机机器码对应的真实注册码；</p>
</li>
</ul>
</li>
<li><p>4C 法移除 NAG 窗口</p>
<p>拿到注册码就结束了？当然不是，不觉得 NAG 窗口很烦人吗？那就去除它！</p>
<p>首先，第 1 想法就是<code>4C法</code>，简单粗暴，do it!</p>
<ul>
<li><p>程序倒入<code>OD</code>后，不要运行，<code>goto</code>到入口 PUSH 指令中的地址加上 4C 后的地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmypztaux7j314z0u0dks.jpg" alt="偏移后的地址"></p>
</li>
<li><p>然后在数据窗口，继续跟踪当前地址中存储的另一个<code>DWORD</code>地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyqa5b1fgj314s0u077j.jpg" alt="跟随 DWORD"></p>
</li>
<li><p>跟随<code>DWORD</code>来到数据窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyqjd343xj314c0diwf4.jpg" alt="结果类似的代码块"></p>
<p>这里有两个结构类似的数据块，每块 50(十六进制)个字节的长度,每块数据的第 24(十六进制)个字节处都有一个标志（第一个是 00，第二个是 04）；</p>
<p>而这个标志指定了代码块（也就是程序启动后要加载的窗体）出现的顺序，先加载 00，再加载 04；</p>
<p>大胆的猜测一下，由于 00 先加载，那 00 可能就是 NAG 窗口，而 04 则是主窗口，至于缺失的 01, 02, 03，可能是<code>Help</code> <code>Wrong</code>和<code>Okey</code>，因为它们都是子窗口，所以就不在这里吧；</p>
</li>
<li><p>所以，为了去掉 NAG 窗口，将此处的两个标志的值互换，即：00 改 04，04 改 00，这样， NAG 窗口就永远也没机会出现了，最后将修改保存到文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyqy5fclnj31550u00xk.jpg" alt="互换值"></p>
</li>
<li><p>最后，运行保存的文件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gmyr2klk5sj312g0nmgn7.jpg" alt="运行"></p>
<p>没有出现 NAG 窗口，而是直接出现程序主窗体，接着，输入注册码，弹出 OK 弹窗；</p>
</li>
<li><p>以为这样就结束了？NO NO NO，4C 法并不是今天的重点，今天的重点是：修改系统 DLL；</p>
</li>
</ul>
</li>
<li><p>修改系统 DLL 移除 NAG 窗口</p>
<ul>
<li><p>首先，要用到修改版的<code>OD</code>，将程序倒入<code>OD</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn47zuerdlj31a80u0n05.jpg" alt="内存访问断点"></p>
<p>在<code>内存窗口</code>给<code>代码段</code>设置内存访问断点，然后运行程序；</p>
</li>
<li><p>多次运行程序后，来到程序的总分支，给所有跳转设置断点，了解它们的功能：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn482zrxcoj31a60u00w8.jpg" alt="总分支"></p>
<p>这好像是 VB 程序的一个特点，有一个类似交通枢纽的地方控制着程序的走向；</p>
</li>
<li><p>设置好断点后，重载并运行程序，程序会在设置断点的<code>JMP</code>位置依次中断，跟踪分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn489harmfj319u0u00vt.jpg" alt="分析JMP"></p>
<p>前三个已经满足了需求，至于其它几个，who cares?</p>
</li>
<li><p>既然已经知道了创建主窗体的跳转，去除 NAG 窗体还不简单，把创建 NAG 窗体的跳转改为创建主窗体的跳转不就结束战斗了？值得一试：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn48ia0i4oj31a30u0jv3.jpg" alt="修改 NAG"></p>
<p>复制创建主窗体的跳转并覆盖创建 NAG 窗体的跳转，然后保存修改到文件；</p>
</li>
<li><p>运行保存的程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn48lt1ea0j30w80kq400.jpg" alt="运行程序"></p>
<p>呃呃，并不是预期的结果，NAG 窗口还是出现了，不过，现在不用点击 Register，程序主窗体也会出现，也就是运行程序后，NAG 窗口和程序主窗体同时显示；</p>
</li>
<li><p>既然这样，以上做的都是无用功啦，直接去修改系统 DLL 它不香吗？</p>
<p>后面的事实证明，这一步是修改系统 DLL 去除 NAG 窗口很关键的一步，至于重要在哪里，接着向下 👇</p>
</li>
<li><p>接下来使用的是原版汉化<code>OD</code>，有很多插件可以使用，<code>工欲善其事，必先利其器</code>嘛，而且修改版<code>OD</code>特殊的<code>内存访问断点</code>已经用不到了，<code>鸟尽弓藏</code>；</p>
</li>
<li><p>然后将保存的程序倒入<code>OD</code>，按下<code>Ctrl + G</code>转到<code>CreateWindowExA</code>函数并双击行首或按下<code>F2</code>设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn496ydgpqj31bd0u00wm.jpg" alt="goto 到 API"></p>
<p>既然程序有窗体，那它怎么也绕不开一个 API<code>CreateWindow</code>，至于这里为什么使用<code>CreateWindowExA</code>，而不是<code>CreateWindow</code>或<code>CreateWindowExW</code>，在<code>goto</code>窗口试试不就知道了；</p>
<p>认识一下<code>CreateWindow</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateWindow</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    该函数创建一个重叠式窗口、弹出式窗口或子窗口。</span><br><span class="line">    它指定窗口类，窗口标题，窗口风格，以及窗口的初始位置及大小（可选的）。</span><br><span class="line">    该函数也指定该窗口的父窗口或所属窗口（如果存在的话），及窗口的菜单。</span><br><span class="line">    若要使用除 CreateWindow 函数支持的风格外的扩展风格，则使用 CreateWindowEx 函数代替 CreateWindow 函数。</span><br><span class="line">    在 winuser.h 中根据是否已定义 Unicode 被分别定义为 CreateWindowW 和 CreateWindowA，然后两者又被分别定义为对 CreateWindowExW 和 CreateWindowExA 函数的调用。</span><br><span class="line">参数</span><br><span class="line">    LPCTSTR lpClassName,    &#x2F;&#x2F; 窗口类名称</span><br><span class="line">    LPCTSTR lpWindowName,   &#x2F;&#x2F; 窗口标题</span><br><span class="line">    DWORD   dwStyle,        &#x2F;&#x2F; 窗口风格，或称窗口格式</span><br></pre></td></tr></table></figure>
<p>参数很多非常多，在这里，关注的是第 2 和第 3 参数，也就是<code>WindowName</code>和<code>Style</code>；</p>
</li>
<li><p>设置好<code>CreateWindowExA</code>断点后，运行程序，程序中断后，在堆栈窗口可以看到：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn49z3divoj31au0u0jwv.jpg" alt="空标题"></p>
<p>前面的中断都不是需要的位置，而原因很简单，不管是 NAG 窗口还是程序主窗体都是有标题的，说明参数<code>WindowName</code>不可能为空；</p>
</li>
<li><p>那就继续运行程序，直到<code>WindowName</code>不为空：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn4a8d1hmcj30qo0kytar.jpg" alt="标题一样"></p>
<p>这次<code>WindowName</code>的值和 NAG 窗口的标题一模一样，就是它了；</p>
</li>
<li><p>然而，麻烦也来了，因为栈顶显示的很明白，调用来自<code>MSVBVM60.DLL</code>，这是个系统文件，所有程序共用此文件，如果因为这个程序而修改了系统文件，其它程序可能就会出错，怎么办？</p>
<p>当然有办法啦，和编程中的变量就近原则一样，调用也遵循这一原则，同名文件，谁离得近就用谁，那复制系统文件<code>MSVBVM60.DLL</code>到程序目录不就 OK👌 了？是的；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn4aqf3j34j31l70u0ae7.jpg" alt="私有 DLL"></p>
<p>复制系统 DLL 到程序目录后，就变成了私有 DLL，修改就不会污染全局了；</p>
</li>
<li><p>搞定了 DLL 文件，就要开始修改了，改什么？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn4az8oieqj31b70u0q6s.jpg" alt="修改 Style"></p>
<p>修改<code>CreateWindowExA</code>的参数<code>Style</code>的值，这里的<code>Style</code>有这么多的值，所以 NAG 窗口是一个有标题、按钮、文本以及层叠属性的窗体，而修改的目的很简单，就是让它成为不能拥有菜单，不能弹出的子窗体，对应的<code>Style</code>属性的值为<code>WS_CHILD</code>;</p>
<p>到了这里，理解深刻的同学可能已经知道了上个问题的答案：为什么要先修改交通枢纽的<code>JMP</code>跳转让程序运行时 NAG 窗口和主窗体同时显示后，然后才能修改系统 DLL 去除 NAG 窗口了；</p>
<p>因为这一步修改后，NAG 窗口不能弹出，没有按钮，那么按照之前程序的逻辑，点击 Register 按钮去触发主窗体就无从谈起了，因为修改后 Register 按钮已经不存在了，问题就来了：如果程序运行时 NAG 窗口和主窗体没有同时显示，如何在没有 Register 按钮的情况下，让主窗体显示？多么痛的领悟，卡了一天才恍然大明白！</p>
</li>
<li><p>修改<code>Style</code>属性，也就是窗口样式：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5g24yw5mj31b40u079i.jpg" alt="修改 Style"></p>
<p>可以看到，将<code>Style</code>的值修改为<code>40000000</code>后的属性值，正是想要的；</p>
<p>然后禁用<code>CreateWindowExA</code>断点，运行程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5gaj1760j31b30u0die.jpg" alt="堆栈修改运行"></p>
<p>程序主窗体直接出现，并没有出现 NAG 窗口，看来，此法可行；</p>
</li>
<li><p>但是，堆栈的修改只对本次运行有效，如何才能保存到文件呢？</p>
<p>那就要在代码上下功夫了，启用<code>CreateWindowExA</code>断点，重载并运行程序，到达理想的断点位置，跟随调用位置去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5h24o1e0j31ba0u0797.jpg" alt="调用位置"></p>
<p>不用看也知道调用是一个 CALL，因为<code>CreateWindowExA</code>是函数，既然要修改函数的<code>Style</code>参数，那肯定要在调用之前参数之后，而且还有一个条件：<code>WindowName</code>的值必须和 NAG 窗口相同，满足了这个条件，才能修改<code>Style</code>让它消失；</p>
<p>既有判断代码，还有操作代码，但这里并没有空代码段来施展，多出来的这些代码要写在哪里呢？设想，如果修改这个 CALL 为跳转，跳转到某个位置，做一些操作之后再跳回来，是否可行？值得一试；</p>
<p>值得注意 ⚠️ 的是，修改既不能影响程序的运行，还需要达到目的，在这里 CALL 只有一行，也就是说，接下来的跳转也只能是一行，只能用间接寻址了；</p>
</li>
<li><p>首先复制原本 CALL 的代码，然后修改 CALL 为 JMP，跳转到空代码段：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5i9ro3lij31b40u0jwe.jpg" alt="修改为 JMP"></p>
<p>因为目的是在 CALL 调用之前添加判断和操作代码，所以调用 CALL 的代码后面还会用到，需要复制到可靠的位置保留下来，至于跳转的空代码段，位置随意，看心情，但地址需要记得住，当然也可以复制地址到可靠的位置保存；</p>
</li>
<li><p>接下来就是到空代码段，写属于自己的逻辑：</p>
<ol>
<li><p>因为是间接寻址，所以，JMP 跳转的其实是当前地址中存储的地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5iqpnonlj31b30u0gqr.jpg" alt="地址为空"></p>
</li>
<li><p>所以要把真正的跳转地址写入当前地址的存储位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5j32i1wxj31au0u0n3m.jpg" alt="写入真实地址"></p>
<p>写入真实跳转地址后，再看 JMP，就发现，左侧的跳转提示有了，信息窗口的跳转地址不再是空了；</p>
</li>
<li><p>然后写属于自己的代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5kwjf4vgj31ba0u0gt1.jpg" alt="自己的代码"></p>
<p>首先，判断<code>WindowName</code>是否为 NULL，如果是 NULL，直接调用<code>CreateWindowExA</code>，如果不是，判断<code>WindowName</code>的前 4 字节和给定字符是否相等，不相等就直接调用<code>CreateWindowExA</code>，如果相等，说明是 NAG 窗口，则修改<code>Style</code>为<code>WS_CHILD</code>，然后调用<code>CreateWindowExA</code>，最后，调用结束后，需要用<code>JMP</code>回到程序原来的位置，至于给定的字符，其实就是 NAG 窗口标题的前 4 字节：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5l4hlhmuj31be0u0jw1.jpg" alt="给定字符"></p>
<p>如果想让程序更严谨一些，可以循环比较<code>WindowName</code>的值和 NAG 窗口的标题是否完全一致；</p>
</li>
</ol>
</li>
<li><p>修改完成后，就是保存修改到文件了，由于这里没有保存全部修改选项，只能分为两次保存：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5l7ihkm8j31b20u0n1f.jpg" alt="保存空代码段"></p>
<p>保存增加的代码到文件；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5liun36pj31b30u0jw8.jpg" alt="修改 CALl 为 JMP"></p>
<p>保存修改的 JMP 到文件；</p>
</li>
<li><p>然后运行程序，嗯？双击程序后，没有任何反应，看来修改出错了，程序被改坏了，不要着急删除，倒入<code>OD</code>看看出错在哪里？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5lyisgxxj31b50u0jw2.jpg" alt="位置不同"></p>
<p>可以看到，程序运行时，窗口标题和样式的堆栈位置前移了 4 个字节，应该就是这里出错了，修改代码并保存，然后重载程序，检查修改：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5m3jzeyij31b60u0wiy.jpg" alt="参数被修改"></p>
<p>程序运行自定义代码后，NAG 窗口在被创建前，<code>Style</code>属性的值已经被修改了；</p>
</li>
<li><p>运行程序并输入注册码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gn5me3bscwj31080u040o.jpg" alt="成功"></p>
<p>直接显示程序主窗体，输入注册码，显示 OK 弹窗！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>VB</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>VB 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳之重建 IAT</title>
    <url>/post/3969158325/</url>
    <content><![CDATA[<blockquote>
<p>破坏原程序的输入表是加密外壳必备的功能，因此在脱壳中，输入表的处理是一个关键环节，这需要脱壳者对 PE 格式中输入表的概念必须非常清楚；</p>
<p>手动修复可以更清晰的理解重建输入表的过程及原理，但很辛苦，需要细心细心再细心，中间因为数值填错而苦苦寻找，想象一下在一堆二进制中找一个数值错误，很可怕，但很值得，弄懂了原理，以后就善用工具了；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-1">OllyDbg 1.10</a>原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases/tag/CrackMe-7">CrackMe</a>来自互联网，仅供学习使用；</li>
<li>加壳工具为<a href="http://www.aspack.com/">ASPACK</a>：收费软件，可以试用；</li>
<li>Dump 工具为 <a href="https://github.com/Undeio/undeio.github.io/releases/tag/Tool-2">LoadPE</a>，来自互联网；</li>
<li>16 进制修改器为 WinHex；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="输入表重建的原理"><a href="#输入表重建的原理" class="headerlink" title="输入表重建的原理"></a>输入表重建的原理</h4><p>在输入表结构中，与实际运行相关的主要是 IAT 结构，这个结构用于保存 API 的实际地址；</p>
<p>PE 文件运行时将初始化输入表的这一部分：</p>
<ul>
<li>Windows 加载器首先搜索 OriginalFirstThunk；</li>
<li>如果存在，加载程序将迭代搜索数组中的每个指针，找到每个 IMAGE_IMPORT_BY_NAME 结构所指向的输入函数的地址；</li>
<li>然后，加载器用函数真正的入口地址代替由 FirstThunk 指向的 IMAGE_THUNK_DATA 数组中元素的值；</li>
<li>初始化结束后，输入表中的其它部分就不重要了，程序依靠 IAT 提供的函数地址就可以正常运行；</li>
</ul>
<p>外壳程序一般都会修改原程序文件的输入，然后自己模仿 PE 装载器来填充 IAT 中的相关数据，也就是说，内存中只有一个 IAT，原程序的输入表不在内存中；</p>
<p>输入表重建就是根据这个 IAT 还原整个输入表的结构，包括 IID 结构以及其它各成员指向的数据等；</p>
<p>一些加密软件为了防止输入表被还原，在 IAT 加密上大作文章，此时，由外壳填充到 IAT 中的不是实际的 API 地址，而是用于 Hook API 的外壳代码的地址；</p>
<p>这样，外壳中的代码一旦完成了加载工作，在进入原程序的代码之后，仍然能够间接获得程序的控制权；</p>
<p>因为程序总要与系统打交道，与系统打交道的途径是 API，而 API 的地址已经被替换为外壳的 Hook API 的地址，所以，每次程序与系统打交道，都会让外壳程序获得一次控制权；</p>
<p>这样，外壳就可以进行反跟踪，从而继续保护软件，同时完成某些特殊任务了；</p>
<p>综上所述，重建输入表的关键是获取未加密的 IAT，一般的做法是跟踪加壳程序对 IAT 的处理过程，修改相关指令，不让外壳加密 IAT；</p>
<h4 id="确定-IAT-的地址和大小"><a href="#确定-IAT-的地址和大小" class="headerlink" title="确定 IAT 的地址和大小"></a>确定 IAT 的地址和大小</h4><p>输入表重建的关键是 IAT 的获得；</p>
<p>一般程序的 IAT 是连续排列的，以一个 DWORD 字的 0 作为结束，因此，只要确定 IAT 的一个点，就能获得整个 IAT 的地址和大小；</p>
<p>程序中的每一个 API 函数在 IAT 中都有自己的位置，这样，无论在代码中调用函数多少次，都会通过 IAT 中的同一个函数指针来完成；</p>
<p>程序调用输入函数分为直接调用和间接调用：</p>
<p>直接调用：<code>CALL DWORD PTR [00401506]</code>，直接调用跳转的地址就是函数的行首；</p>
<p>间接调用：<code>CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt;</code>，间接调用是获取跳转地址存储的内容，然后调用；</p>
<p>以 CM 为例：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnysy0v08kj31eb0u0ads.jpg" alt="间接调用"></p>
<p>此处为间接调用，在选择行按下 Enter 键即可到调用位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyszz3dehj31ef0u00x0.jpg" alt="调用位置"></p>
<p>这里有很多跳转至输入函数的指令，也可以说是 IAT 吧（IAT 跳转表）；</p>
<p>IAT 是一块连续排列的数据，因此，可以向上滚动屏幕，直到没有跳转，就是 IAT 的起始位置；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyt7wfurwj318v0u079r.jpg" alt="IAT 的起始位置"></p>
<p>可以看到，当前地址之前的数据为 0，所以可以确定，这里就是 IAT 的起始位置；</p>
<p>既然起始位置是向上滚动，结束位置肯定是向下滚动：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyteiv2nrj31fq0u0n2f.jpg" alt="IAT 结束位置"></p>
<p>需要注意的是，IAT 中的 IID 结构数组以 NULL 确定数据的结尾，所以，IAT 的结尾不是最后一个跳转指向的地址，而是下一个 DWORD <code>00000000</code>；</p>
<p>为了更直观地观察，可以让数据窗口直接显示这些 API 函数，以确定 IAT 是否正确：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnytpedhm7j31ds0u0tde.jpg" alt="直观地观察"></p>
<p>设置数据窗口显示方式后，可以更直观地看到 IAT 的起始地址和结束地址；</p>
<h4 id="根据-IAT-重建输入表"><a href="#根据-IAT-重建输入表" class="headerlink" title="根据 IAT 重建输入表"></a>根据 IAT 重建输入表</h4><ol>
<li><p>使用 ASPACK 加密 CM，然后导入 OD；</p>
</li>
<li><p>使用栈平衡法定位并跳转至 OEP；</p>
</li>
<li><p>运行 LoadPE，将内存数据 Dump 出来并保存（Dump 过程中不能关闭 OD）：</p>
<p>Dump（转存）是指把内存指定地址的映像文件读出，用文件等形式将其保存下来的过程；</p>
<p>在程序到达 OEP 且没有运行时，Dump 是正确的，而程序运行后，由于一些变量已经初始化了，所以不适合 Dump；</p>
<p>在外壳处理过程中，外壳要把压缩后的全部代码数据释放到内存中，并初始化一些项目，因此，在此过程中也可以选择合适的位置进行 Dump；</p>
<p>常用的 Dump 软件有 LoadPE、PETool- 等，这类工具一般利用 Module32Next 来获取欲 Dump 进程的基本信息；</p>
<p>首先设置 LoadPE，勾选完整转存选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyu1ofv8cj30so0is74t.jpg" alt="设置 LoadPE"></p>
<p>设置完成后，在 LoadPE 的进程窗口中选择 CM 的进程，然后单击右键，在弹出的快捷菜单中执行“完整转存”命令，抓取并保存：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyu86qvv6j30ys0jaab0.jpg" alt="Dump"></p>
<p>注意保存文件的后缀，默认为 .dll 需要修改为 .exe；</p>
</li>
<li><p>运行 dumped.exe 发现不能运行：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyub982ydj30pe0eyq3b.jpg" alt="不能运行"></p>
<p>将 dumped.exe 导入 OD，在弹出错误弹窗后，程序并没有停在 OEP 位置，说明异常是在初始化时产生的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyuihwfs0j31e40u00vv.jpg" alt="异常是在初始化时产生的"></p>
<p>查看 log 窗口，发现创建进程后异常就发生了，程序都没有完成初始化；</p>
</li>
<li><p>回到反汇编窗口，goto 到 OEP，然后来到 IAT 表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyux7yeyaj318b0u00xf.jpg" alt="来到 IAT 表"></p>
<p>发现 PE 加载器在搜索 OriginalFirstThunk 数组时异常了；</p>
<p>这时，就需要修复了；</p>
</li>
<li><p>回到之前的 OD，通过查看 IAT 可以看到，CM 使用了 5 个 DLL，分别是：user32.dll、kernel32.dll、comctl32.dll、GDI32.dll、comdlg32.dll，它们分别对应一个 IAT，IAT 之间以一个 DWORD 类型的 0 隔开，整理 IAT 成员的函数：</p>
<table>
<thead>
<tr>
<th align="center">user32.dll</th>
<th align="center">kernel32.dll</th>
<th align="center">comctl32.dll</th>
<th align="center">GDI32.dll</th>
<th align="center">comdlg32.dll</th>
</tr>
</thead>
<tbody><tr>
<td align="center">KillTimer</td>
<td align="center">GetLocalTime</td>
<td align="center">InitCommonControls</td>
<td align="center">TextOutA</td>
<td align="center">GetSaveFileNameA</td>
</tr>
<tr>
<td align="center">GetSystemMetrics</td>
<td align="center">OpenFile</td>
<td align="center">CreateToolbarEx</td>
<td align="center">StartPage</td>
<td align="center">GetOpenFileNameA</td>
</tr>
<tr>
<td align="center">LoadCursorA</td>
<td align="center">GlobalFree</td>
<td align="center">CreateToolbar</td>
<td align="center">StartDocA</td>
<td align="center">PrintDlgA</td>
</tr>
<tr>
<td align="center">LoadAcceleratorsA</td>
<td align="center">GlobalAlloc</td>
<td align="center"></td>
<td align="center">GetTextMetricsA</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">MessageBeep</td>
<td align="center">lstrlenA</td>
<td align="center"></td>
<td align="center">GetStockObject</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetWindowRect</td>
<td align="center">CloseHandle</td>
<td align="center"></td>
<td align="center">EndPage</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">LoadStringA</td>
<td align="center">WriteFile</td>
<td align="center"></td>
<td align="center">EndDoc</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">LoadIconA</td>
<td align="center">GetModuleHandleA</td>
<td align="center"></td>
<td align="center">DeleteObject</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">LoadBitmapA</td>
<td align="center">ReadFile</td>
<td align="center"></td>
<td align="center">DeleteDC</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SetFocus</td>
<td align="center">ExitProcess</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">MessageBoxA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PostQuitMessage</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">WinHelpA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">InvalidateRect</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TranslateAcceleratorA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">MoveWindow</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TranslateMessage</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">LoadMenuA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ShowWindow</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SendMessageA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SetTimer</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SetWindowPos</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">UpdateWindow</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">RegisterClassA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">BeginPaint</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CreateWindowExA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DefWindowProcA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DialogBoxParamA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DispatchMessageA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DrawMenuBar</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">EndDialog</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">EndPaint</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FindWindowA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetDC</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetDlgItem</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetDlgItemTextA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetMessageA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>接下来就是修复了，使用 WinHex 打开 dumped.exe，在文件中找到一块空白空间，将表中的 DLL 名和函数名写进去：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnywqu2k84j31ue0h0qaq.jpg" alt="函数数据"></p>
<p>为了加深对输入表的理解，手动。。。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnyx9ny4d8j318f0u00vz.jpg" alt="写进去"></p>
<p>写入数据时：</p>
<ul>
<li><p>每个函数前面要留 2 个字节来存放函数的序号，序号可以为 0；</p>
</li>
<li><p>每个函数后的 1 字节为 0，即以 0 结尾；</p>
</li>
<li><p>每个函数名或 DLL 名的起始位置必须按偶数对齐，空隙用 0 填充；</p>
</li>
</ul>
<p>因为 dumped.exe 是内存映像文件，所以文件偏移地址和相对虚拟地址（RVA）是相等的；</p>
<p>整理 DLL 名和 API 名所在的偏移地址：</p>
<table>
<thead>
<tr>
<th align="center">DLL 或 API 名称</th>
<th align="center">地址</th>
<th align="center">API 名称</th>
<th align="center">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user32.dll</td>
<td align="center">00002200</td>
<td align="center">user32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">KillTimer</td>
<td align="center">00002240</td>
<td align="center">GetSystemMetrics</td>
<td align="center">0000224C</td>
</tr>
<tr>
<td align="center">LoadCursorA</td>
<td align="center">00002260</td>
<td align="center">LoadAcceleratorsA</td>
<td align="center">0000226E</td>
</tr>
<tr>
<td align="center">MessageBeep</td>
<td align="center">00002282</td>
<td align="center">GetWindowRect</td>
<td align="center">00002290</td>
</tr>
<tr>
<td align="center">LoadStringA</td>
<td align="center">000022A0</td>
<td align="center">LoadIconA</td>
<td align="center">000022AE</td>
</tr>
<tr>
<td align="center">LoadBitmapA</td>
<td align="center">000022BA</td>
<td align="center">SetFocus</td>
<td align="center">000022C8</td>
</tr>
<tr>
<td align="center">MessageBoxA</td>
<td align="center">000022D4</td>
<td align="center">PostQuitMessage</td>
<td align="center">000022E2</td>
</tr>
<tr>
<td align="center">WinHelpA</td>
<td align="center">000022F4</td>
<td align="center">InvalidateRect</td>
<td align="center">00002300</td>
</tr>
<tr>
<td align="center">TranslateAcceleratorA</td>
<td align="center">00002312</td>
<td align="center">MoveWindow</td>
<td align="center">0000232A</td>
</tr>
<tr>
<td align="center">TranslateMessage</td>
<td align="center">00002338</td>
<td align="center">LoadMenuA</td>
<td align="center">000234C</td>
</tr>
<tr>
<td align="center">ShowWindow</td>
<td align="center">00002358</td>
<td align="center">SendMessageA</td>
<td align="center">00002366</td>
</tr>
<tr>
<td align="center">SetTimer</td>
<td align="center">00002376</td>
<td align="center">SetWindowPos</td>
<td align="center">00002382</td>
</tr>
<tr>
<td align="center">UpdateWindow</td>
<td align="center">00002392</td>
<td align="center">RegisterClassA</td>
<td align="center">000023A2</td>
</tr>
<tr>
<td align="center">BeginPaint</td>
<td align="center">000023B4</td>
<td align="center">CreateWindowExA</td>
<td align="center">000023C2</td>
</tr>
<tr>
<td align="center">DefWindowProcA</td>
<td align="center">000023D4</td>
<td align="center">DialogBoxParamA</td>
<td align="center">000023E6</td>
</tr>
<tr>
<td align="center">DispatchMessageA</td>
<td align="center">000023F8</td>
<td align="center">DrawMenuBar</td>
<td align="center">0000240C</td>
</tr>
<tr>
<td align="center">EndDialog</td>
<td align="center">0000241A</td>
<td align="center">EndPaint</td>
<td align="center">00002426</td>
</tr>
<tr>
<td align="center">FindWindowA</td>
<td align="center">00002432</td>
<td align="center">GetDC</td>
<td align="center">00002440</td>
</tr>
<tr>
<td align="center">GetDlgItem</td>
<td align="center">00002448</td>
<td align="center">GetDlgItemTextA</td>
<td align="center">00002456</td>
</tr>
<tr>
<td align="center">GetMessageA</td>
<td align="center">00002468</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">kernel32.dll</td>
<td align="center">0000220C</td>
<td align="center">kernel32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetLocalTime</td>
<td align="center">00002476</td>
<td align="center">OpenFile</td>
<td align="center">00002486</td>
</tr>
<tr>
<td align="center">GlobalFree</td>
<td align="center">00002492</td>
<td align="center">GlobalAlloc</td>
<td align="center">000024A0</td>
</tr>
<tr>
<td align="center">lstrlenA</td>
<td align="center">000024AE</td>
<td align="center">CloseHandle</td>
<td align="center">000024B8</td>
</tr>
<tr>
<td align="center">WriteFile</td>
<td align="center">000024C6</td>
<td align="center">GetModuleHandleA</td>
<td align="center">000024D2</td>
</tr>
<tr>
<td align="center">ReadFile</td>
<td align="center">000024E6</td>
<td align="center">ExitProcess</td>
<td align="center">000024F2</td>
</tr>
<tr>
<td align="center">comctl32.dll</td>
<td align="center">0000221A</td>
<td align="center">comctl32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">InitCommonControls</td>
<td align="center">00002500</td>
<td align="center">CreateToolbarEx</td>
<td align="center">00002516</td>
</tr>
<tr>
<td align="center">CreateToolbar</td>
<td align="center">00002528</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GDI32.dll</td>
<td align="center">00002228</td>
<td align="center">GDI32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TextOutA</td>
<td align="center">00002538</td>
<td align="center">StartPage</td>
<td align="center">00002544</td>
</tr>
<tr>
<td align="center">StartDocA</td>
<td align="center">00002550</td>
<td align="center">GetTextMetricsA</td>
<td align="center">0000255C</td>
</tr>
<tr>
<td align="center">GetStockObject</td>
<td align="center">0000256E</td>
<td align="center">EndPage</td>
<td align="center">00002580</td>
</tr>
<tr>
<td align="center">EndDoc</td>
<td align="center">0000258A</td>
<td align="center">DeleteObject</td>
<td align="center">00002594</td>
</tr>
<tr>
<td align="center">DeleteDC</td>
<td align="center">000025A4</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">comdlg32.dll</td>
<td align="center">00002232</td>
<td align="center">comdlg32.dll 中的 API 👇👇👇</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GetSaveFileNameA</td>
<td align="center">000025B0</td>
<td align="center">GetOpenFileNameA</td>
<td align="center">000025C4</td>
</tr>
<tr>
<td align="center">PrintDlgA</td>
<td align="center">000025D8</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>接着，构造指向函数名地址的 IMAGE_THUNK_DATA 数组：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz01e8sjhj318c0u0q5p.jpg" alt="IMAGE_THUNK_DATA 数组"></p>
<p>位置随意，两个数组之间的间隔为 2 字节，用 0 填充（小端序构建）；</p>
<p>然后构建其 IID 数组：</p>
<table>
<thead>
<tr>
<th align="center">DLL</th>
<th align="center">OrignalFirstThunk</th>
<th align="center">TimeDateStamp</th>
<th align="center">ForwardChain</th>
<th align="center">Name</th>
<th align="center">FirstThunk</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user32.dll</td>
<td align="center">00290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">00220000</td>
<td align="center">84310000</td>
</tr>
<tr>
<td align="center">kernel32.dll</td>
<td align="center">98290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">0C220000</td>
<td align="center">1C320000</td>
</tr>
<tr>
<td align="center">comctl32.dll</td>
<td align="center">C4290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">1A220000</td>
<td align="center">48320000</td>
</tr>
<tr>
<td align="center">GDI32.dll</td>
<td align="center">D4290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">28220000</td>
<td align="center">58320000</td>
</tr>
<tr>
<td align="center">comdlg32.dll</td>
<td align="center">FC290000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">32220000</td>
<td align="center">80320000</td>
</tr>
<tr>
<td align="center">（结束标志 ）</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
<td align="center">00000000</td>
</tr>
</tbody></table>
<p>接下来，使用 LoadPE 修改输入表地址：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz7h6rl86j30n60lsdg9.jpg" alt="使用 LoadPE修改输入表地址"></p>
<p>修改完成后，运行程序，一切正确，这就完了吗？并没有；</p>
<p>将 dumped.exe 导入 OD：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz7m49balj313806sdg1.jpg" alt="弹出警告"></p>
<p>程序会弹出提示入口点超出代码段范围的警告，所以，还需要修改 OEP：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz7r455y1j31dw0u0n0a.jpg" alt="修改OEP"></p>
<p>修改 OEP 为正常数值，并保存修改到可执行文件；</p>
<p>将保存的文件导入 OD，然后检查 IAT，有数据才算正常：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz7ub6ct2j31jn0u0tb7.jpg" alt="检查IAT"></p>
</li>
<li><p>总结一下：</p>
<ul>
<li>构建 IMAGE_IMPORT_BY_NAME 结构体，用来存储 DLL 名和 API 名；</li>
<li>构建 IMAGE_THUNK_DATA 结构体，指向函数名对应的地址；</li>
<li>构建 IID 结构体，OrignalFirstThunk 指向 IMAGE_THUNK_DATA 对应的起始地址，Name 指向 IMAGE_IMPORT_BY_NAME 对应的地址，FirstThunk 指向原程序的 IAT 表；</li>
<li>构建过程中，每项的注意事项不再赘述；</li>
</ul>
</li>
<li><p>所有修改如下：</p>
<ul>
<li><p>IMAGE_IMPORT_BY_NAME：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8byl9soj31360sqq4g.jpg" alt="1"><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8c1acqcj312y0ti403.jpg" alt="2"><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8c43rquj31300gujs4.jpg" alt="3"></p>
</li>
<li><p>IMAGE_THUNK_DATA：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8fazzagj31340j43yq.jpg" alt="4"></p>
</li>
<li><p>IID：<br><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnz8gumd8lj313409omxd.jpg" alt="5"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>脱壳技术</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>脱壳</tag>
        <tag>IAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PE 文件格式</title>
    <url>/post/1876828466/</url>
    <content><![CDATA[<blockquote>
<p>记录<a href="https://reversecore.com/">逆向工程核心原理</a>一书中对<code>PE 文件格式</code>的描述，辅助阅读<a href="https://bbs.pediy.com/forum-99.htm">加密解密</a>第 11 章节，补充、印证，加强学习，同时作为备忘，初始对很多内容理解不够深刻且容易忘记，日后需多加练习；</p>
</blockquote>
<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>OllyDbg 1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code> <code>汉化</code>和<code>插件</code>均来自互联网；</li>
<li><code>WinHex</code>来自互联网；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h3 id="PE-文件格式"><a href="#PE-文件格式" class="headerlink" title="PE 文件格式"></a>PE 文件格式</h3><p>PE 文件是 Windows 操作系统下的可执行文件格式；</p>
<p>是微软在 UNIX 平台的 COFF（Common Object File Format，通用对象文件格式）基础上制作而成的；</p>
<p>在 Win16 平台上，可执行文件格式是 NE；</p>
<p>在 Win32 平台上，可执行文件格式是 PE（Portable Executable File Format，可移植的执行体）；</p>
<p>PE 文件是指 32 位的可执行文件，也称为 PE32；</p>
<p>64 位的可执行文件称为 PE+ 或 PE32+，是 PE 文件的一种扩展形式，而不是 PE64；</p>
<blockquote>
<p>Tips：⚠️ 为当前参数列表需重点关注</p>
</blockquote>
<h4 id="PE-文件种类"><a href="#PE-文件种类" class="headerlink" title="PE 文件种类"></a>PE 文件种类</h4><table>
<thead>
<tr>
<th align="center">种类</th>
<th align="center">主扩展名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可执行系列</td>
<td align="center">EXE、SCR</td>
</tr>
<tr>
<td align="center">库系列</td>
<td align="center">DLL、OCX、CPL、DRV</td>
</tr>
<tr>
<td align="center">驱动程序系列</td>
<td align="center">SYS、VXD</td>
</tr>
<tr>
<td align="center">对象文件系列</td>
<td align="center">OBJ</td>
</tr>
</tbody></table>
<p>除 OBJ 文件之外的所有文件都是可执行的；</p>
<p>EXE 文件和 DLL 文件的区别完全是语义上的，它们使用完全相同的 PE 格式，唯一的区别就是用一个字段标识出这个文件是 EXE 还是 DLL；</p>
<p>DLL、SYS 文件等虽然不能直接在 Shell 中运行，但可以使用其它方法执行；</p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>PE 文件使用的是一个平面地址空间，所有代码和数据都合并在一起，组成一个很大的结构；</p>
<p>文件的内容被分割为不同的区块（Section，又称区段、节等）；</p>
<p>区块中包含代码或数据，各个区块按页边界对齐；</p>
<p>区块没有大小限制，是一个连续结构；</p>
<p>每个区块都有它自己在内存中的一套属性，如：是否包含代码、是否只读或可读/写等；</p>
<p>Windows 加载器（又称 PE 装载器）遍历 PE 文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移地址映射到较高的内存地址中；</p>
<p>磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的，但数据之间的相对位置可能会改变，某项的偏移地址可能区别于原始的偏移地址；</p>
<p>当 PE 文件通过 Windows 加载器载入内存后，内存中的版本称为模块（Module）；</p>
<p>映射文件的起始地址称为模块句柄（hModule），可以通过模块句柄访问内存中的其它数据结构，这个初始内存地址也称为基地址（ImageBase）；</p>
<p>基地址的值是由 PE 文件本身设定的，按照默认设置，用 Visual C++ 建立的 EXE 文件的基地址是 00400000，DLL 文件的基地址是 10000000；</p>
<p>从 DOS 头到节区头是 PE 头部分，称为 PE 头，下面的节区合称 PE 体；</p>
<p>文件中使用偏移（offset），内存中使用 VA（Virtual Address，虚拟地址）来表示位置；</p>
<p>文件加载到内存时，节区的大小、位置等会发生变化；</p>
<p>文件的内容一般可以分为代码（.text）、数据（.data）、资源（.src）节等，分别保存；</p>
<p>根据所用的不同开发工具与编译选项，节区的名称、大小、个数、存储的内容等都是不同的，它们按照不同的用途，分类保存到不同的节中；</p>
<p>各节区头定义了各节区在文件或内存中的大小、位置、属性等；</p>
<p>PE 头与各节区的尾部存在一个区域，称为 NULL 填充，也就是 PE 头与各节区以 NULL 分割；</p>
<p>计算机中，为了提高处理文件、内存、网络包的效率，使用“最小基本单位”这一概念，PE 文件也类似；</p>
<p>文件 / 内存中各节区的起始位置应该在各文件 / 内存的最小单位的倍数位置上，空白区域将用 NULL 填充；</p>
<h4 id="VA-amp-RVA"><a href="#VA-amp-RVA" class="headerlink" title="VA &amp; RVA"></a>VA &amp; RVA</h4><p>在 Windows 系统中，PE 文件将被系统加载器映射到内存中；</p>
<p>每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址（Virtual Address，VA）；</p>
<p>VA（Virtual Address，虚拟地址） 指的是进程虚拟内存的绝对地址；</p>
<p>RVA（Relative Virtual Address，相对虚拟地址）指的是从基准位置（ImageBase）开始的相对地址；</p>
<p>VA 与 RVA 之间的关系：虚拟地址（VA） = 相对虚拟地址（RVA） + 基地址（ImageBase）；</p>
<p>PE 头内部信息大多以 RVA 形式存在；</p>
<p>原因在于，PE 文件（主要是 DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其它 PE 文件（DLL）；</p>
<p>此时，必须通过重定位将其加载到其它空白的位置，若 PE 头信息使用的是 VA，则无法正常访问；</p>
<p>因此使用 RVA 来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题；</p>
<p>32 位 Windows 系统中，各进程分配有 4GB 的虚拟内存，因此进程中 VA 值的范围是 00000000 ～ FFFFFFFF；</p>
<h3 id="PE-头"><a href="#PE-头" class="headerlink" title="PE 头"></a>PE 头</h3><p>PE 头由许多结构体组成；</p>
<h4 id="DOS-头"><a href="#DOS-头" class="headerlink" title="DOS 头"></a>DOS 头</h4><p>每个 PE 文件都是以一个 DOS 程序开始的，有了它，一旦程序在 DOS 下执行，DOS 就能识别出这是一个有效的执行体，然后运行紧随 MZ Header 的 DOS stub（DOS 块）；</p>
<p>DOS stub（DOS 存根） 实际上是一个有效的 EXE，在不支持 PE 文件格式的操作系统中，它将简单的显示一个错误提示；</p>
<p>通常把 DOS MZ 头与 DOS stub 合并称为 DOS 头；</p>
<p>微软创建 PE 文件格式时，广泛使用的是 DOS 文件，考虑到 PE 文件对 DOS 文件的兼容性，在 PE 头的最前面添加了一个 IMAGE_DOS_HEADER 结构体，用来扩展已有的 DOS EXE 头；</p>
<p>IMAGE_DOS_HEADER 结构体的大小为 64 字节，在该结构体中必须知道 2 个重要的成员：</p>
<ul>
<li>e_magic：DOS 签名（Signature，5A4D，对应的 ASCII 值是“MZ”），也称为 DOS MZ 头；</li>
<li>e_lfanew：指示 NT 头的偏移（根据不同文件拥有可变值），是真正的 PE 文件头的相对偏移（RVA）位置，占用 4 个字节，位于从文件开始偏移 3C 字节处；</li>
</ul>
<p>所有 PE 文件在开始部分（e_magic）都有 DOS 签名（5A4D，“MZ”）；</p>
<p>一个名叫 Mark Zbikowski 的开发人员在微软设计了 DOS 可执行文件，MZ 取自其名字的首字母；</p>
<p>e_lfanew 值指向 NT 头所在位置（NT 头的名称为 IMAGE_NT_HEADERS）;</p>
<p>NOTEPAD.EXE 的 IMAGE_DOS_HEADER 结构体：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqc1thiodj316q0u0q5s.jpg" alt="IMAGE_DOS_HEADER"></p>
<p>文件开始的 2 个字节为 5A4D，e_lfanew 值为 000000E0（Intel x86 CPU，小端序标识法）；</p>
<h4 id="DOS-存根"><a href="#DOS-存根" class="headerlink" title="DOS 存根"></a>DOS 存根</h4><p>DOS 存根（stub）位于 DOS 头下方，是可选项，且大小不固定；</p>
<p>DOS 存根由代码与数据混合而成；</p>
<p>NOTEPAD.EXE 的 DOS 存根：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqcbjzm65j31360ai74r.jpg" alt="NOTEPAD.EXE 的 DOS 存根"></p>
<h4 id="NT-头（PE-Header，PE-头）"><a href="#NT-头（PE-Header，PE-头）" class="headerlink" title="NT 头（PE Header，PE 头）"></a>NT 头（PE Header，PE 头）</h4><p>NT 头的名称为 IMAGE_NT_HEADERS；</p>
<p>IMAGE_NT_HEADERS 结构体由 3 个成员组成，第一个成员为签名（Signature）结构体，其值为 50450000（“PE”00），另外两个成员分别为文件头（File Header）与可选头（Optional Header）结构体；</p>
<p>IMAGE_NT_HEADERS 结构体：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqcqnwemej316p0u0go5.jpg" alt="IMAGE_NT_HEADERS 结构体"></p>
<p>IMAGE_NT_HEADERS 结构体的大小为 F8，相当大；</p>
<h4 id="NT-头：文件头-IMAGE-FILE-HEADER"><a href="#NT-头：文件头-IMAGE-FILE-HEADER" class="headerlink" title="NT 头：文件头 IMAGE_FILE_HEADER"></a>NT 头：文件头 IMAGE_FILE_HEADER</h4><p>文件头是表现文件大致属性的 IMAGE_FILE_HEADER 结构体；</p>
<p>IMAGE_FILE_HEADER 结构体的成员：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqokc8tzsj31640dgq4k.jpg" alt="IMAGE_FILE_HEADER 结构体的成员"></p>
<p>以下成员的前 4 个非常重要，若设置不正确，将导致文件无法正常运行：（偏移量基于 PE 文件头 （IMAGE_NT_HEADERS））</p>
<table>
<thead>
<tr>
<th align="center">偏移量</th>
<th align="center">字段</th>
<th align="center">Size</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">Machine ⚠️</td>
<td align="center">WORD</td>
<td align="center">运行平台</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">NumberOfSections ⚠️</td>
<td align="center">WORD</td>
<td align="center">文件的区块数</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">SizeOfOptionalHeader ⚠️</td>
<td align="center">WORD</td>
<td align="center">IMAGE_OPTIONAL_HEADER 结构体的大小</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">Characteristics ⚠️</td>
<td align="center">WORD</td>
<td align="center">文件属性</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">TimeDateStamp</td>
<td align="center">DWORD</td>
<td align="center">文件创建时间</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">PointerToSymbolTable</td>
<td align="center">DWORD</td>
<td align="center">指向符号表</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">NumberOfSymbols</td>
<td align="center">DWORD</td>
<td align="center">符号表中符号的数量</td>
</tr>
</tbody></table>
<ol>
<li><p>Machine：每个 CPU 都拥有唯一的 Machine 码，兼容 32 位 Intel x86 芯片的 Machine 码为 14C，具体定义位于 winnt.h；</p>
<p>几种典型的机器类型标志：</p>
<table>
<thead>
<tr>
<th align="center">机器</th>
<th align="center">标志</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Intel i386</td>
<td align="center">14C</td>
</tr>
<tr>
<td align="center">MIPS R3000</td>
<td align="center">162</td>
</tr>
<tr>
<td align="center">MIPS R4000</td>
<td align="center">166</td>
</tr>
<tr>
<td align="center">Alpha AXP</td>
<td align="center">184</td>
</tr>
<tr>
<td align="center">Power PC</td>
<td align="center">1F0</td>
</tr>
</tbody></table>
</li>
<li><p>NumberOfSections：用来指出文件中存在的节区（Section）数量，该值一定要大于 0，且当定义的节区数量与实际数量不同时，将发生运行错误；</p>
</li>
<li><p>SizeOfOptionalHeader：IMAGE_NT_HEADERS 结构体的最后一个成员为 IMAGE_OPTIONAL_HEADER 结构体，SizeOfOptionalHeader 成员用来指出 IMAGE_OPTIONAL_HEADER 结构体的长度，表示数据的大小；</p>
<p>Windows 的 PE 装载器需要查看 IMAGE_FILE_HEADER 的 SizeOfOptionalHeader 值，从而识别出 IMAGE_OPTIONAL_HEADER 结构体的大小；</p>
<p>PE32+ 格式的文件中使用的是 IMAGE_OPTIONAL_HEADER64 结构体，而不是 IMAGE_OPTIONAL_HEADER32 结构体；</p>
<p>IMAGE_OPTIONAL_HEADER64 与 IMAGE_OPTIONAL_HEADER32 两个结构体的尺寸不同，所以需要在 SizeOfOptionalHeader 成员中明确指出结构体的大小；</p>
<p>IMAGE_OPTIONAL_HEADER 的大小依赖于当前 PE 文件是 32 位还是 64 位；</p>
<p>对于 32 位 PE 文件，这个域通常是 00E0；<br>对于 64 位 PE 文件，这个域通常是 00F0；</p>
</li>
<li><p>Characteristics：用于标识文件的属性，文件是否为可运行的形态、是否为 DLL 文件等信息，具体定义位于 winnt.h；</p>
<p>属性位字段的含义：</p>
<table>
<thead>
<tr>
<th align="center">特征值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0001</td>
<td align="center">文件中不存在重定位信息</td>
</tr>
<tr>
<td align="center">0002</td>
<td align="center">文件可执行，如果为 0，一般是链接时出问题了 ⚠️</td>
</tr>
<tr>
<td align="center">0004</td>
<td align="center">行号信息被移除</td>
</tr>
<tr>
<td align="center">0008</td>
<td align="center">符号信息被移除</td>
</tr>
<tr>
<td align="center">0020</td>
<td align="center">应用程序可以处理超过 2GB 的地址</td>
</tr>
<tr>
<td align="center">0080</td>
<td align="center">处理机的低位字节是相反的</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">目标平台为 32 位机器</td>
</tr>
<tr>
<td align="center">0200</td>
<td align="center">.DBG 文件的调试信息被移除</td>
</tr>
<tr>
<td align="center">0400</td>
<td align="center">如果映像文件位于可移动介质中，则先复制到交换文件中再运行</td>
</tr>
<tr>
<td align="center">0800</td>
<td align="center">如果映像文件位于网络中，则复制到交换文件后才运行</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">系统文件</td>
</tr>
<tr>
<td align="center">2000</td>
<td align="center">文件是 DLL ⚠️</td>
</tr>
<tr>
<td align="center">4000</td>
<td align="center">文件只能运行在单处理器上</td>
</tr>
<tr>
<td align="center">8000</td>
<td align="center">处理机的高位字节是相反的</td>
</tr>
</tbody></table>
</li>
<li><p>TimeDateStamp：用来记录编译器创建此文件的时间；</p>
</li>
<li><p>PointerToSymbolTable：COFF 符号表的文件偏移位置，若没有符号表存在，将此值设置为 0；</p>
</li>
<li><p>NumberOfSymbols：如果有符号表，它表示其中的符号数目；</p>
</li>
</ol>
<h4 id="NT-头：可选头-IMAGE-OPTIONAL-HEADER"><a href="#NT-头：可选头-IMAGE-OPTIONAL-HEADER" class="headerlink" title="NT 头：可选头 IMAGE_OPTIONAL_HEADER"></a>NT 头：可选头 IMAGE_OPTIONAL_HEADER</h4><p>IMAGE_OPTIONAL_HEADER32 是 PE 头结构体中最大的；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrfb7n93aj316u0u00vu.jpg" alt="IMAGE_OPTIONAL_HEADER32"></p>
<p>首先在 DOS 头中找到 PE 头（NT 头）的偏移量，然后黄色表示的是签名（IMAGE_NT_SIGNATURE）结构体，红色表示 IMAGE_FILE_HEADER 结构体，黑色和蓝色表示 IMAGE_OPTIONAL_HEADER32 结构体，其中，黑色为 IMAGE_OPTIONAL_HEADER32 结构体中需要重点关注的部分（DataDirectory 成员未标注）；</p>
<p>在 IMAGE_OPTIONAL_HEADER32 结构体中需要关注下列成员，这些成员是文件运行必需的，设置错误将导致文件无法正常运行：（偏移量基于 PE 文件头 （IMAGE_NT_HEADERS））</p>
<table>
<thead>
<tr>
<th align="center">偏移量</th>
<th align="center">字段</th>
<th align="center">Size</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">18</td>
<td align="center">Magic</td>
<td align="center">WORD</td>
<td align="center">标志字</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">AddressOfEntryPoint</td>
<td align="center">DWORD</td>
<td align="center">程序执行入口 RVA</td>
</tr>
<tr>
<td align="center">34</td>
<td align="center">ImageBase</td>
<td align="center">DWORD</td>
<td align="center">程序默认载入基地址</td>
</tr>
<tr>
<td align="center">38</td>
<td align="center">SetionAlignment</td>
<td align="center">DWORD</td>
<td align="center">内存中区块的对齐值</td>
</tr>
<tr>
<td align="center">3C</td>
<td align="center">FileAlignment</td>
<td align="center">DWORD</td>
<td align="center">文件中区块的对齐值</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">SizeOfImage</td>
<td align="center">DWORD</td>
<td align="center">映像载入内存后的总尺寸</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">SizeOfHeaders</td>
<td align="center">DWORD</td>
<td align="center">整个 PE 头的大小</td>
</tr>
<tr>
<td align="center">5C</td>
<td align="center">Subsystem</td>
<td align="center">WORD</td>
<td align="center">文件子系统</td>
</tr>
<tr>
<td align="center">74</td>
<td align="center">NumberOfRvaAndSizes</td>
<td align="center">DWORD</td>
<td align="center">数据目录表的项数</td>
</tr>
<tr>
<td align="center">78</td>
<td align="center">DataDirectory</td>
<td align="center"></td>
<td align="center">数据目录表</td>
</tr>
</tbody></table>
<ol>
<li><p>Magic：为 IMAGE_OPTIONAL_HEADER32 结构体时，Magic 码为 10B；为 IMAGE_OPTIONAL_HEADER64 结构体时，Magic 码为 20B，文件为 ROM 映像时，Magic 码为 107；</p>
</li>
<li><p>AddressOfEntryPoint：持有 EP 的 RVA 值，该值指出程序最先执行的代码的起始地址，非常重要；</p>
</li>
<li><p>ImageBase：进程的虚拟内存范围是 00000000 ～ FFFFFFFF（32 位系统），PE 文件被加载到如此大的内存中时，ImageBase 指出文件的优先装载地址，而 ImageBase 就是文件在内存中的首选载入地址，如果 PE 文件是在这个地址载入的，那么加载器将跳过应用基址重定位的步骤；</p>
<ul>
<li><p>EXE、DLL 文件被装载到用户内存的 00000000 ～ 7FFFFFFF 中；</p>
</li>
<li><p>SYS 文件被装载到内核内存的 80000000 ～ FFFFFFFF 中；</p>
</li>
<li><p>一般而言，使用开发工具创建的 EXE 文件，其默认 ImageBase 值为 00400000，DLL 文件的 ImageBase 值为 10000000；（可以指定为其它值）</p>
</li>
<li><p>执行 PE 文件时，PE 装载器先创建进程，再将文件载入内存，然后把 EIP 寄存器的值设置为 <code>ImageBase + AddressOfEntryPoint</code>；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnymrkwex8j31e90u0wj0.jpg" alt="ImageBase + AddressOfEntryPoint"></p>
<p>如图所示，AddressOfEntryPoint 为 0000739D，ImageBase 为 01000000，则 EIP 的值（也就是 EP）为：0100739D；</p>
<p>勘误：<code>#### NT 头：可选头 IMAGE_OPTIONAL_HEADER</code> 开始位置，图中的签名（IMAGE_NT_SIGNATURE）结构体标注错了，有发现的小伙伴吗？</p>
</li>
</ul>
</li>
<li><p>SetionAlignment / FileAlignment</p>
<p>PE 体，也就是 PE 的 Body 部分划分为若干个节区，这些节区存储着不同类别的数据；</p>
<p>SetionAlignment 指定了节区在内存中的最小单位，每个节区被载入的地址必定是此字段指定数值的整数倍；默认的对齐尺寸是目标 CPU 的页尺寸；</p>
<p>FileAlignment 指定了节区在磁盘文件中的最小单位，组成块的原始数据必须保证从本字段的倍数地址开始；</p>
<p>一个文件中，FileAlignment 与 SetionAlignment 的值可能相同，也可能不相同；</p>
<p>磁盘文件或内存的节区大小必定为 FileAlignment 或 SetionAlignment 值的整数倍；</p>
</li>
<li><p>SizeOfImage：加载 PE 文件到内存时，SizeOfImage 指定了 PE 映像在虚拟内存中所占空间的大小；</p>
<p>映像载入内存后的总尺寸，是指载入文件从 ImageBase 到最后一个块的大小，最后一个块根据其大小向上取整；</p>
<p>一般而言，文件的大小与加载到内存中的大小是不同的（节区头中定义了各节装载的位置与占有内存的大小）；</p>
</li>
<li><p>SizeOfHeaders：用来指出整个 PE 头的大小，该值必需是 FileAlignment 的整数倍；</p>
<p>MS-DOS 头部、PE 文件头、区块表的总尺寸，域值四舍五入至文件对齐值的倍数；</p>
<p>第一节区所在位置与 SizeOfHeaders 距文件开始偏移的量相同；</p>
</li>
<li><p>Subsystem：用来区分系统驱动文件（*.sys）与普通的可执行文件（*.exe，*.dll）；</p>
<p>一个标明可执行文件所期望的子系统（用户界面类型）的枚举值，这个值只对 EXE 重要；</p>
<p>成员值如下：</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">含义</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"></td>
<td align="center">未知</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">Driver 文件</td>
<td align="center">不需要子系统，系统驱动（如：ntfs.sys）</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">GUI 文件</td>
<td align="center">图形接口子系统，窗口应用程序（如：notepad.exe）</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">GUI 文件</td>
<td align="center">字符子系统，控制台应用程序（如：cmd.exe）</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"></td>
<td align="center">OS/2 字符子系统</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"></td>
<td align="center">POSIX 字符子系统</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center">保留</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"></td>
<td align="center">Windows CE 图形界面</td>
</tr>
</tbody></table>
</li>
<li><p>NumberOfRvaAndSizes：用来指定 DataDirectory 数组的个数；</p>
<p>数据目录表（DataDirectory）的项数，这个字段的值从 Windows NT 发布以来一直是 16；</p>
<p>PE 装载器通过查看 NumberOfRvaAndSizes 的值来识别数组大小；</p>
</li>
<li><p>DataDirectory：是由 IMAGE_DATA_DIRECTORY 结构体组成的数组，数组的每项都有被定义的值，指向输出表、输入表、资源块等数据；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrfz6q5lqj316w0u0mzs.jpg" alt="DataDirectory"></p>
<p>数据目录表的每个成员占 8 个字节，分别指向相关的结构体，前 4 个字节表示地址，后 4 个字节表示大小，最后一个成员必须为 0；</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">成员</th>
<th align="left">结构</th>
<th align="center">偏移量（PE / PE32+）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="left">Export Table ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_EXPORT</td>
<td align="center">78 / 88</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">Import Table ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_IMPORT</td>
<td align="center">80 / 90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">Resources Table ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_RESOURCE</td>
<td align="center">88 / 98</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">Exception Table</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_EXCEPTION</td>
<td align="center">90 / A0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">Security Table</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_SECURITY</td>
<td align="center">98 / A8</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">Base relocation Table</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_BASERELOC</td>
<td align="center">A0 / B0</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">Debug</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_DEBUG</td>
<td align="center">A8 / B8</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">Copyright</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_COPYRIGHT</td>
<td align="center">B0 / C0</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">Global Ptr</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td>
<td align="center">B8 / C8</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">Thread local storage (TLS) ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_TLS</td>
<td align="center">C0 / D0</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">Load configuration</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td>
<td align="center">C8 / D8</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">Bound Import</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td>
<td align="center">D0 / E0</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">Import Address Table (IAT) ⚠️</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_IAT</td>
<td align="center">D8 / E8</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">Delay Import</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td>
<td align="center">E0 / F0</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">COM descriptor</td>
<td align="left">IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td>
<td align="center">E8 / F8</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">保留，必须为 0</td>
<td align="left"></td>
<td align="center">F0 / 100</td>
</tr>
</tbody></table>
<p>PE 文件在定位输出表、输入表和资源表等重要数据时，就是从 IMAGE_DATA_DIRECTORY 结构体开始的；</p>
</li>
</ol>
<h4 id="节区头-IMAGE-SECTION-HEADER-结构体数组"><a href="#节区头-IMAGE-SECTION-HEADER-结构体数组" class="headerlink" title="节区头 IMAGE_SECTION_HEADER 结构体数组"></a>节区头 IMAGE_SECTION_HEADER 结构体数组</h4><p>PE 文件中的 code（代码）、data（数据）、resource（资源）等按照属性分类存储在不同节区；</p>
<p>节区头中定义了各节区属性；</p>
<p>节区属性中有文件 / 内存的起始位置、大小、访问权限等；</p>
<p>不同内存属性的访问权限：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">访问权限</th>
</tr>
</thead>
<tbody><tr>
<td align="center">code</td>
<td align="center">执行，读取权限</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">非执行，读写权限</td>
</tr>
<tr>
<td align="center">resource</td>
<td align="center">非执行，读取权限</td>
</tr>
</tbody></table>
<p>节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组，每个结构体对应一个节区，每个结构体包含它所关联区块的信息，如位置、长度、属性等，该数组的数目由 IMAGE_NT_HEADERS.IMAGE_FILE_HEADER.NumberOfSections 指出；</p>
<p>IMAGE_SECTION_HEADER 结构体中的重要成员：</p>
<table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">VirtualSize</td>
<td align="center">内存中节区所占大小</td>
</tr>
<tr>
<td align="center">VirtualAddress</td>
<td align="center">内存中节区起始位置（RVA）</td>
</tr>
<tr>
<td align="center">SizeOfRawData</td>
<td align="center">磁盘文件中节区所占大小</td>
</tr>
<tr>
<td align="center">PointerToRawData</td>
<td align="center">磁盘文件中节区起始位置</td>
</tr>
<tr>
<td align="center">Characteristics</td>
<td align="center">节区属性（bit OR）</td>
</tr>
</tbody></table>
<ol>
<li><p>VirtualSize：指出实际被使用的区块的大小，是在进行对齐处理前区块的实际大小；</p>
</li>
<li><p>VirtualAddress：该块装载到内存中的 RVA，这个地址是按照内存页对齐的，它的数值总是 SectionAlignment 的整数倍；</p>
</li>
<li><p>SizeOfRawData：该块在磁盘中所占的空间，在可执行文件中，该字段包含经 FileAlignment 调整的块的大小；</p>
</li>
<li><p>PointerToRawData：该块在磁盘文件中的偏移，程序经编译或汇编后生成原始数据，这个字段用于给出原始数据在文件中的偏移；</p>
<p>如果程序装载自 PE 或 COFF 文件（而不是由操作系统载入的），这一字段将比 VirtualAddress 还重要，在这种情况下，必须完全使用线性映像的方法载入文件，所以需要在该偏移处找到块的数据，而不是 VirtualAddress 字段中的 RVA 地址；</p>
</li>
<li><p>Characteristics：块属性，该字段是一组指出块属性的标志，多个标志值求或即为 Characteristics 的值；</p>
<p>Characteristics 的值由下列值组合而成：</p>
<table>
<thead>
<tr>
<th align="center">定义</th>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IMAGE_SCN_CNT_CODE</td>
<td align="center">00000020</td>
<td align="center">包含代码，常与 10000000 一起设置</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_CNT_INITIALIZED_DATA</td>
<td align="center">00000040</td>
<td align="center">该块包含已初始化的数据</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_CNT_UNINITIALIZED_DATA</td>
<td align="center">00000080</td>
<td align="center">该块包含未初始化的数据</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_DISCARDABLE</td>
<td align="center">02000000</td>
<td align="center">该块可被丢弃，因为它一旦被载入，进程就不再需要它了 <br/> 常见的可丢弃块是 .reloc（重定位块）</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_SHARED</td>
<td align="center">10000000</td>
<td align="center">该块为共享块</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_EXECUTE</td>
<td align="center">20000000</td>
<td align="center">该块可执行，通常当 00000020 标志被设置时，该标志也被设置</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_READ</td>
<td align="center">40000000</td>
<td align="center">该块可读，可执行文件中的块总是设置该标志</td>
</tr>
<tr>
<td align="center">IMAGE_SCN_MEM_WRITE</td>
<td align="center">80000000</td>
<td align="center">该块可写，如果 PE 文件中没有设置该标志，装载程序就会将内存映像页标记为可读或可执行</td>
</tr>
</tbody></table>
</li>
</ol>
<p>VirtualAddress 与 PointerToRawData 不带有任何值，分别由定义在 IMAGE_OPTIONAL_HEADER32 中的 SectionAlignment 与 FileAlignment 确定；</p>
<p>VirtualSize 与 SizeOfRawData 一般具有不同的大小，即磁盘文件中节区的大小与加载到内存中的节区的大小是不同的；</p>
<p>如果 VirtualSize 的值大于 SizeOfRawData 的值，那么 SizeOfRawData 表示来自可执行文件初始化数据的大小，与 VirtualSize 相差的字节用 0 填充；</p>
<p>最后，PE 规范未明确规定节区的 Name，所以可以向其中放入任何值，甚至可以填充 NULL 值，因此，节区的 Name 字段仅供参考，不能保证其百分百的用作某种信息（节区的名称）；</p>
<h3 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h3><p>PE 文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的映射，这种映射一般称为 RVA to RAW；</p>
<p>方法如下：</p>
<ol>
<li><p>查找 RVA 所在节区；</p>
</li>
<li><p>使用简单的公式计算文件偏移（RAW）</p>
<p>根据 IMAGE_SECTION_HEADER 结构体，换算公式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RAW - PointerToRawData = RVA - VirtualAddress</span><br><span class="line">                  RAW = RVA - VirtualAddress + PointerToRawData</span><br></pre></td></tr></table></figure>
<h3 id="IAT（Import-Address-Table，导入地址表）"><a href="#IAT（Import-Address-Table，导入地址表）" class="headerlink" title="IAT（Import Address Table，导入地址表）"></a>IAT（Import Address Table，导入地址表）</h3></li>
</ol>
<p>在 PE 文件内有一组数据结构，它们分别对应于被输入的 DLL，每一个这样的结构体都给出了被输入的 DLL 的名称并指向一组函数指针，这组函数指针称为输入地址表（IAT）；</p>
<p>每一个被引入的 API 在 IAT 里都有保留的位置，在那里它将被 Windows 加载器写入输入函数的地址，也就是调用位置；</p>
<p>一旦模块被载入，IAT 中将包含所要输入函数的地址；</p>
<p>把所有输入函数放在 IAT 中，这样，无论代码中多用一个输入函数多少次，都会通过 IAT 中的同一个函数指针来完成；</p>
<h4 id="DLL（Dynamic-Link-Library，动态链接库）"><a href="#DLL（Dynamic-Link-Library，动态链接库）" class="headerlink" title="DLL（Dynamic Link Library，动态链接库）"></a>DLL（Dynamic Link Library，动态链接库）</h4><p>16 位的 DOS 时代不存在 DLL 这一概念，只有“库”一说，比如在 C 语言中使用 printf() 函数时，编译器会从 C 语言库中读取相应函数的二进制代码，然后插入应用程序的源代码中，也就是说，可执行文件中包含着 printf() 函数的二进制代码；</p>
<p>Windows 系统支持多任务，如果同时运行多个程序，而每个程序包含相同的库，将造成严重的内存浪费和磁盘浪费，因此，Windows 引入了 DLL 这一概念，描述如下：</p>
<ol>
<li>不要把库包含到程序中，单独组成 DLL 文件，需要时调用即可；</li>
<li>内存映射技术使加载后的 DLL 代码、资源在多个进程中实现共享；</li>
<li>更新库时，只要替换相关的 DLL 文件即可，简单易行；</li>
</ol>
<p>加载 DLL 的方式有两种：</p>
<ol>
<li>“显式链接”（Explicit Linking），程序使用 DLL 时加载，使用完毕后释放内存，必须确定目标 DLL 已经被加载，然后才寻找 API 的地址，这几乎总是通过调用 LoadLibrary 和 GetProcAddress 完成的；</li>
<li>“隐式链接”（Implicit Linking），程序开始时即同时加载 DLL，程序终止时再释放占用的内存，Windows 加载器保证 PE 文件所需的任何附加的 DLL 都被载入，调用 LoadLibrary 和 GetProcAddress 的过程由 Windows 加载器完成；</li>
</ol>
<p>IAT 提供的机制与隐式链接有关；</p>
<p>大多程序在调用 API 时，都并非直接调用，而是通过获取指定地址处的值来实现调用，为什么不直接调用呢？</p>
<p>这是由于，程序的制作者编译程序时，无法确定程序的运行环境（XP、Vista、7、10）、语言（ENG、CHS、JPN、KOR）、服务包（Service Pack），不同环境中，使用的 DLL 版本各不相同，指定的 API 的实际位置也会不同；</p>
<p>为了确保能在所有环境中都能正常调用 API，编译器准备并记录要保存 API 的实际地址，执行文件时，PE 装载器会将 API 的地址写入到这个实际地址；</p>
<p>编译器不使用直接指令调用 API 的另一个原因在于 DLL 重定向。</p>
<p>DLL 文件的 ImageBase 值一般为 10000000，比如程序使用了 a.dll 和 b.dll，PE 装载器先将 a.dll 装载到内存的 10000000 处，然后尝试将 b.dll 也装载到该处，但由于该地址已经装载了 a.dll，所以，PE 装载器会查找其它空白的内存空间，然后将 b.dll 装载进去，这就是 DLL 重定向，这就使得无法对实际地址进行硬编码；</p>
<p>还有一个原因在于：PE 头中表示地址时使用 RVA，而不是 VA；</p>
<p>实际操作中，无法保证 DLL 一定会被加载到 PE 头指定的 ImageBase 处，但是 EXE 文件（生成进程的主体）却能准确的加载到自身的 ImageBase 中，这是因为它拥有自己的虚拟空间；</p>
<h4 id="输入函数的调用"><a href="#输入函数的调用" class="headerlink" title="输入函数的调用"></a>输入函数的调用</h4><p>输入函数就是被程序调用但其执行代码不在程序中的函数，这些函数的代码位于相关的 DLL 中，在调用程序中只保留相关的函数信息，如函数名、DLL 文件名等；</p>
<p>对磁盘上的 PE 文件来说，它无法得知这些输入函数在内存中的地址；</p>
<p>只有当 PE 文件载入内存后，Windows 加载器才会将相关 DLL 载入，并将调用输入函数的指令和函数实际所处的地址联系起来；</p>
<p>当应用程序调用一个 DLL 的代码和数据时，它正在被隐式链接到 DLL，这个过程完全由 Windows 加载器完成；</p>
<h4 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR"></a>IMAGE_IMPORT_DESCRIPTOR</h4><p>IMAGE_IMPORT_DESCRIPTOR 结构体中记录着 PE 文件要倒入哪些库文件；</p>
<p>可执行文件使用来自其它 DLL 的代码或数据的动作称为输入（import）；</p>
<p>当 PE 文件被载入时，Windows 加载器的工作之一就是定位所有被输入的函数和数据，并让正在载入的文件可以使用这些地址，这个过程是通过 PE 文件的输入表（Import Table，简称“IT”，也称导入表）完成的；</p>
<p>输入表中保存的是函数名和其驻留的 DLL 名等动态链接库所需的信息；</p>
<p>在 PE 文件头的可选映像头中，数据目录表的第 2 个成员指向输入表，即 IMAGE_NT_HEADERS.IMAGE_OPTIONAL_HEADER.DataDirectory[1]，也就是 IMAGE_DIRECTORY_ENTRY_IMPORT；</p>
<p>输入表（数组）以 IMAGE_IMPORT_DESCRIPTOR（IID） 结构体开始，每个被 PE 文件隐式链接的 DLL 都有一个 IID，这个数组中，没有字段指出该结构体数组的项数，但它的最后一个单元是 NULL，由此可以计算出该数组的项数；</p>
<p>执行一个普通程序时，往往需要导入多个库，导入多少个库就存在多少个 IMAGE_IMPORT_DESCRIPTOR 结构体，这些结构体形成了数组，且结构体数组最后以 NULL 结构体结尾；</p>
<p>IMAGE_IMPORT_DESCRIPTOR 结构体的成员：</p>
<table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OriginalFirstThunk（Characteristics）⚠️</td>
<td align="center">INT 的地址（RVA）</td>
</tr>
<tr>
<td align="center">TimeDateStamp</td>
<td align="center">一个 32 位的时间标志，可忽略</td>
</tr>
<tr>
<td align="center">ForwarderChain</td>
<td align="center">第 1 个被转向的 API 的索引，一般为 0</td>
</tr>
<tr>
<td align="center">Name ⚠️</td>
<td align="center">库名称字符串的地址（RVA）</td>
</tr>
<tr>
<td align="center">FirstThunk ⚠️</td>
<td align="center">IAT 的地址（RVA）</td>
</tr>
</tbody></table>
<blockquote>
<p>INT：输入名称表（Import Name Table）；</p>
<p>IAT：输入地址表（Import Address Table）；</p>
</blockquote>
<ol>
<li>OriginalFirstThunk（INT）：包含指向输入名称表（INT）的 RVA；<br>INT 是一个包含导入函数信息（Ordinal，Name）的结构体指针数组，只有获得了这些信息，才能在加载到进程内存的库中准确求得相应函数的起始地址；<br>INT 是一个 IMAGE_THUNK_DATA 结构的数组，数组中的每个 IMAGE_THUNK_DATA 结构都指向 IMAGE_IMPORT_BY_NAME 结构，数组尾部以 NULL 结束，即数组以一个内容为 0 的 IMAGE_THUNK_DATA 结构体结束；</li>
<li>TimeDateStamp：一个 32 位的时间标志，可忽略；</li>
<li>ForwarderChain：这是第 1 个被转向的 API 的索引，一般为 0，在程序中引用一个 DLL 中的 API，而这个 API 又在引用其它 DLL 的 API 时使用；</li>
<li>Name：DLL 名字的指针，是一个以 “00” 结尾的 ASCII 字符的 RVA 地址，该字符包含输入 DLL 的名称；<br>Name 是一个字符串指针，它指向导入函数所属的库文件的名称；</li>
<li>FirstThunk（IAT）：包含指向输入地址表（IAT）的 RVA；</li>
</ol>
<p>OriginalFirstThunk 与 FirstThunk 相似，它们分别指向两个本质上相同的数组 IMAGE_THUNK_DATA 结构；</p>
<p>两个数组中都有 IMAGE_THUNK_DATA 结构类型的元素，它是一个指针大小的联合（union）；</p>
<p>每个 IMAGE_THUNK_DATA 元素对应与一个从可执行文件输入的函数；</p>
<p>两个数组的结束都是由一个值为 0 的 IMAGE_THUNK_DATA 元素表示；</p>
<p>IMAGE_THUNK_DATA 结构实际上是一个双字，该结构在不同时刻有不同的含义，定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IMAGE_THUNK_DATA STRUCT</span><br><span class="line">    union ul</span><br><span class="line">        ForwarderString     DWORD   ?       ; 指向一个转向者字符串的 RVA</span><br><span class="line">        Function            DWORD   ?       ; 被输入的函数的内存地址</span><br><span class="line">        Ordinal             DWORD   ?       ; 被输入的 API 的序数值</span><br><span class="line">        AddressOfData       DWORD   ?       ; 指向 IMAGE_IMPORT_BY_NAME</span><br><span class="line">    ends</span><br><span class="line">IMAGE_THUNK_DATA ENDS</span><br></pre></td></tr></table></figure>
<p>当 IMAGE_THUNK_DATA 值的最高位（双字的最高位）为 1 时，表示函数以序号方式输入，这时低 31 位（或这 64 位可执行文件的低 63 位）被看成一个函数序号；</p>
<p>当 IMAGE_THUNK_DATA 值的最高位（双字的最高位）为 0 时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个 RVA，指向一个 IMAGE_IMPORT_BY_NAME 结构；</p>
<p>IMAGE_IMPORT_BY_NAME 结构仅有 1 个字大小，存储了一个输入函数的相关信息，定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IMAGE_IMPORT_BY_NAME STRUCT</span><br><span class="line">    Hint     WORD   ?</span><br><span class="line">    Name     BYTE   ?</span><br><span class="line">IMAGE_IMPORT_BY_NAME ENDS</span><br></pre></td></tr></table></figure>
<ol>
<li>Hint：本函数在其所驻留 DLL 的输入表中的序号，该域被 PE 装载器用来在 DLL 的输出表里快速查询函数；<br>该值不是必需的，一些链接器将它设为 0；</li>
<li>Name：含有输入函数的函数名，函数名是一个 ASCII 字符串，以 NULL 结尾；<br>这里虽然将 Name 的大小以字节为单位进行定义，但其实它是一个可变尺寸域，由于没有更好的表示方式，只好在定义中写成 BYTE；</li>
</ol>
<p>PE 装载器把导入函数输入至 IAT 的顺序：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 读取 IID 的 Name 成员，获取库名称字符串；</span><br><span class="line">2. 装载相应库：LoadLibrary(&quot;库名称.dll&quot;)</span><br><span class="line">3. 读取 IID 的 OriginalFirstThunk 成员，获取 INT 地址；</span><br><span class="line">4. 逐一读取 INT 数组中的值，获取相应的 IMAGE_IMPORT_BY_NAME（RVA）；</span><br><span class="line">5. 使用 IMAGE_IMPORT_BY_NAME 的 Hint 项或 Name 项，获取相应函数的起始位置；</span><br><span class="line">6. 读取 IID 的 FirstThunk 成员，获得 IAT 地址；</span><br><span class="line">7. 将上面获得的函数地址输入相应 IAT 数组中；</span><br><span class="line">8. 重复以上步骤 4～7，直到 INT 表结束（遇到 NULL）；</span><br></pre></td></tr></table></figure>
<h4 id="以-NOTEPAD-EXE-为例，梳理思路，强化学习"><a href="#以-NOTEPAD-EXE-为例，梳理思路，强化学习" class="headerlink" title="以 NOTEPAD.EXE 为例，梳理思路，强化学习"></a>以 NOTEPAD.EXE 为例，梳理思路，强化学习</h4><ol>
<li><p>在 PE 文件头的可选映像头中，数据目录表的第 2 个成员指向输入表；</p>
</li>
<li><p>数据目录表是 IMAGE_DIRECTORY_ENTRY_IMPORT，位于 IMAGE_OPTIONAL_HEADER32.DataDirectory[1]；</p>
</li>
<li><p>而 IMAGE_OPTIONAL_HEADER32 位于 IMAGE_NT_HEADERS，也就是 PE 头；</p>
</li>
<li><p>使用 WinHex 打开 NOTEPAD.EXE，找到 PE 头的偏移位置（位于从文件开始偏移 3C 字节处）；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsqzcsjsnj316r0u041k.jpg" alt="PE头的偏移位置"></p>
</li>
<li><p>找到 PE 头后，IMAGE_OPTIONAL_HEADER32 是其的第 3 个成员，所以，直接定位到第 3 个成员，然后找到 DataDirectory：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsrf4o9j1j316q0u0dih.jpg" alt="IMAGE_DIRECTORY_ENTRY_IMPORT"></p>
<p>绿色是 IMAGE_NT_SIGNATURE；</p>
<p>黄色是 IMAGE_FILE_HEADER；</p>
<p>蓝色是 IMAGE_OPTIONAL_HEADER32 的其它成员，从 158 位置开始，是 DataDirectory 数组成员，也就是数据目录表成员，最后的红色则表示 DataDirectory[1]；</p>
<p>数据目录表的每个成员占 8 个字节，分别指向相关的结构体，前 4 个字节表示地址，后 4 个字节表示大小；</p>
<p>所以在这里，IMAGE_DIRECTORY_ENTRY_IMPORT 的相对虚拟地址是<code>7604</code>;</p>
</li>
<li><p>由于得到的地址是 RVA，所以还需要转换为 RAW，先来看看 RAW 的计算公式：RAW = RVA - VirtualAddress + PointerToRawData，这其中的 RVA 是已知的，也就是 <code>7604</code>，而 VirtualAddress 和 PointerToRawData 如何得知呢？</p>
<p>VirtualAddress 和 PointerToRawData 位于 IMAGE_SECTION_HEADER 结构体；</p>
<p>IMAGE_SECTION_HEADER 结构体在 PE 头的下方，所以 DataDirectory 数组之后就是 IMAGE_SECTION_HEADER 结构体，也就是 节区表（区块表）；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsypkauskj316x0u0wgw.jpg" alt="节区表（区块表）"></p>
<p>图中选中部分是 DataDirectory 数组；</p>
<p>红色是第 1 个节区的部分参数，第 3 个参数说明，此节区（.text）在内存中的起始位置（VirtualAddress）是 00001000，第 5 个参数说明，此节区在磁盘文件中的偏移（PointerToRawData）是 00000400；</p>
<p>绿色是第 2 个节区的部分参数，第 3 个参数说明，此节区（.data）在内存中的起始位置（VirtualAddress）是 00009000，这里为什么要看第 2 节区的 VirtualAddress 呢？因为确定了第 2 节区的起始位置，也就确定了第 1 节区的结束位置，也就是范围，很显然，1000 &lt; 7604 &lt; 9000，位于第 1 节区（.text）；</p>
<p>根据公式计算，第 1 节区的 RAW = 7604 - 1000 + 400，结果是<code>6A04</code>；</p>
</li>
<li><p>既然已知第 1 节区的 RAW，按下<code>ALT + G</code>或者菜单栏选择<code>位置 &gt;&gt; 转到偏移位置</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsz701irwj316u0u0tbj.jpg" alt="第 1 节区的 RAW"></p>
<p>图中所示就是第 1 节区 IID，共有 5 个成员，分别来看一下：</p>
<ul>
<li><p>第 1 个成员是 OriginalFirstThunk：INT 的地址（RVA）；根据计算，其 RAW 是<code>6D90</code>；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnszcrj5gij316x0u00vr.jpg" alt="OriginalFirstThunk"></p>
<p>跳转到<code>6D90</code>可以看到输入名称表数组，最后一个单元为 NULL，跟随第 1 个成员，查看其名称，RVA：7A7A -&gt; RAW：6E7A</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnsznj6kkfj316m0u041z.jpg" alt="跟随第 1 个成员"></p>
<p>初始的 2 个字节为 Ordinal，是库中函数的固有编号，Ordinal 后面是导入函数的名称字符串<code>PageSetupDlgW</code>（末尾以 Terminating NULL[‘\0’]结尾）；</p>
</li>
<li><p>第 2 个成员是 TimeDateStamp，由于这里的值为 0，故忽略；</p>
</li>
<li><p>第 3 个成员是 ForwarderChain，其值也为 0，忽略；</p>
</li>
<li><p>第 4 个成员是 Name：DLL 名字的指针；RVA：7AAC -&gt; RAW：6EAC；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnt02pzailj316s0u0n09.jpg" alt="DLL 名字的指针"></p>
<p>可以看到，包含<code>PageSetupDlgW</code>的库文件是<code>comdlg32.dll</code>；</p>
</li>
<li><p>第 5 个成员是 FirstThunk（IAT）：包含指向输入地址表（IAT）的 RVA；RVA：12C4 -&gt; RAW：6C4；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnt0aevkwrj316s0u0dim.jpg" alt="FirstThunk（IAT）"></p>
<p>选中区域即为 IAT 数组区域，对应于 cmdlg32.dll 库，与 INT 类似，由结构体指针组成，且以 NULL 结尾；</p>
</li>
</ul>
</li>
</ol>
<h3 id="EAT（Export-Address-Table，导出地址表）"><a href="#EAT（Export-Address-Table，导出地址表）" class="headerlink" title="EAT（Export Address Table，导出地址表）"></a>EAT（Export Address Table，导出地址表）</h3><p>在 Windows 系统中，“库”是为了方便其它程序调用而集中包含相关函数的文件（DLL / SYS）；</p>
<p>创建 DLL 时，实际上创建了一组能让 EXE 或其它 DLL 调用的函数；</p>
<p>程序运行时， PE 装载器会根据 DLL 文件中输出的信息修正被执行文件的 IAT；</p>
<p>当一个 DLL 函数能够被 EXE 或其它 DLL 文件使用时，它就被“输出了（Exported）”；</p>
<p>输出信息被保存在输出表中，DLL 文件通过输出表向系统提供输出函数名、序号和入口地址等信息；</p>
<p>EAT 是一种核心机制，它使不同的应用程序可以调用库文件中提供的函数，也就是说，只有通过 EAT 才能准确获得从相应库中导出函数的起始地址；</p>
<h4 id="IMAGE-EXPORT-DESCRIPTOR"><a href="#IMAGE-EXPORT-DESCRIPTOR" class="headerlink" title="IMAGE_EXPORT_DESCRIPTOR"></a>IMAGE_EXPORT_DESCRIPTOR</h4><p>与 IAT 一样，PE 文件内特定结构体（IMAGE_EXPORT_DESCRIPTOR）保存着导出信息，且 PE 文件中仅有一个用来说明库 EAT 的 IMAGE_EXPORT_DESCRIPTOR 结构体；</p>
<p>输出表的主要内容是一个表格，其中包括函数名称、输出序数等，序数是指 DLL 中某个函数的 16 位数字，在所指向的 DLL 中是独一无二的；<br>输出表是数据目录表的第 1 个成员，指向 IMAGE_EXPORT_DESCRIPTOR（简称 IED）结构；</p>
<p>IMAGE_EXPORT_DESCRIPTOR 结构体的重要成员：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">Size</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Name</td>
<td align="center">DWORD</td>
<td align="center">模块（DLL）的真实名称</td>
</tr>
<tr>
<td align="center">NumberOfFunctions ⚠️</td>
<td align="center">DWORD</td>
<td align="center">实际 Export 函数的个数</td>
</tr>
<tr>
<td align="center">NumberOfNames ⚠️</td>
<td align="center">DWORD</td>
<td align="center">Export 函数中具名函数的个数（ENT）</td>
</tr>
<tr>
<td align="center">AddressOfFunctions ⚠️</td>
<td align="center">DWORD</td>
<td align="center">Export 函数地址数组（数组元素个数 = NumberOfFunction）</td>
</tr>
<tr>
<td align="center">AddressOfNames ⚠️</td>
<td align="center">DWORD</td>
<td align="center">函数名称地址数组（数组元素个数 = NumberOfNames）</td>
</tr>
<tr>
<td align="center">AddressOfNameOrdinals ⚠️</td>
<td align="center">DWORD</td>
<td align="center">序号地址数组（数组元素个数 = NumberOfNames）</td>
</tr>
</tbody></table>
<blockquote>
<p>ENT：输出函数名称表（Export Name Table）；</p>
<p>EAT：输出地址表（Export Address Table）；</p>
</blockquote>
<ol>
<li>Name：指向一个 ASCII 字符串的 RVA，这个字符串是与输出函数相关联的 DLL 的名字；</li>
<li>NumberOfFunctions： EAT 中的条目数量，0 表示没有代码或数据被输出；</li>
<li>NumberOfNames：输出函数名称表（Export Name Table，ENT），NumberOfNames 的值总是小于或等于 NumberOfFunctions 的值；</li>
<li>AddressOfFunctions：EAT 的 RVA，EAT 是一个 RVA 数组，数组中的每一个非零 RVA 都对应于一个被输出的序号；</li>
<li>AddressOfNames：ENT 的 RVA，ENT 是一个指向 ASCII 字符串的 RVA 数组，每一个 ASCII 字符串对应于一个通过名字输出的序号；</li>
<li>AddressOfNameOrdinals：输出序数表的 RVA，这个表是字（WORD）的数组，这个表将 ENT 中的数组索引映射到相应的输出地址表条目；</li>
</ol>
<p>设计输出表是为了方便 PE 装载器工作；</p>
<p>模块必须保存所有输出函数的地址，供 PE 装载器查询；</p>
<p>模块将这些信息保存在 AddressOfFunctions 域指向的数组中，而数组元素的数量存放在 NumberOfFunctions 域中；</p>
<p>如果有些函数是通过名字引出的，这些名字的 RVA 值会存放在 AddressOfNames 域指向的数组中，数组元素的数量存放在 NumberOfNames 域中，以供 PE 装载器查询；</p>
<p>AddressOfNames 域指向的数组中仅包含函数名，并不包含函数的地址；</p>
<p>AddressOfNameOrdinals 域指向的数组中包含（AddressOfNames 数组中）函数名对应的（在 AddressOfFunctions 数组中的）索引，所以，序数表和名称表的元素数量相同；</p>
<p>PE 装载器会通过 AddressOfNameOrdinals 域指向的数组获取 AddressOfNames 域指向的数组中的函数名在 AddressOfFunctions 域指向的数组中对应的索引，从而获取函数地址；</p>
<h4 id="以-KERNEL32-DLL-为例，梳理思路，强化学习"><a href="#以-KERNEL32-DLL-为例，梳理思路，强化学习" class="headerlink" title="以 KERNEL32.DLL 为例，梳理思路，强化学习"></a>以 KERNEL32.DLL 为例，梳理思路，强化学习</h4><ol>
<li><p>使用 WinHex 打开 KERNEL32.DLL，找到 IMAGE_EXPORT_DESCRIPTOR，位于 IMAGE_OPTIONAL_HEADER32.DataDirectory[0]；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntuzfk614j316s0u0q5d.jpg" alt="IMAGE_EXPORT_DESCRIPTOR"></p>
<p>可以看到，IMAGE_EXPORT_DESCRIPTOR 的 RVA 为<code>262C</code>，则 RAW 为<code>1A2C</code>;</p>
</li>
<li><p>跳转到<code>1A2C</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntv12k5gvj316i0u0773.jpg" alt="`1A2C`"></p>
<p>选中部分为 IMAGE_EXPORT_DESCRIPTOR 所有成员，红色部分依次是 Name、AddressOfFunctions、AddressOfNames 以及 AddressOfNameOrdinals；</p>
</li>
<li><p>首先，查看 Name，RVA：4B98 -&gt; RAW：3F98：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntv5oue9xj316t0u0diu.jpg" alt="3F98"></p>
<p>可以看到，库名称为<code>KERNEL32.dll</code>（以’\0’结尾）；</p>
</li>
<li><p>返回<code>1A2C</code>，然后查看 AddressOfFunctions，RVA：2654 -&gt; RAW：1A54：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvbhgjx1j316q0u0n00.jpg" alt="1A54"></p>
<p>可以看到，第 1 个输出函数的 RAV 为：A6E4；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvei6fjpj316q0u0acp.jpg" alt="ImageBase"></p>
<p>KERNEL32.DLL 的 ImageBase 为：7C800000，故第 1 个输出函数的实际地址（VA）为：7C800000 + A6E4 = 7C80A6E4；</p>
<p>使用<code>OD</code>打开 KERNEL32.DLL：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvlbcvxfj31b40u0tbx.jpg" alt="使用`OD`打开 KERNEL32.DLL"></p>
<p>发现 7C80A6E4 对应的函数名为<code>ActivateActCtx</code>；</p>
</li>
<li><p>返回<code>1A2C</code>，接着查看 AddressOfNames，RVA：353C -&gt; RAW：293C：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvp6hfftj316j0u00vk.jpg" alt="293C"></p>
<p>指向函数名字符串的指针是：4BA5，则 RAW 为：3FA5：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvr1cbzqj316s0u041i.jpg" alt="3FA5"></p>
<p>对应的函数名为<code>ActivateActCtx</code>，与查看 AddressOfFunctions 时获取的函数名一致；</p>
</li>
<li><p>返回<code>1A2C</code>，最后来看 AddressOfNameOrdinals，RVA：4424 -&gt; RAW：3824：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntvuyl8g5j316x0u0acs.jpg" alt="3824"></p>
<p>对应的索引值为 0，没问题；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
</search>
