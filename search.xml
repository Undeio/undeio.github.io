<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 添加 Utterance 评论功能</title>
    <url>/post/3357819964/</url>
    <content><![CDATA[<blockquote>
<p>每逢看到大佬们的精彩文章，感慨甚多之际，不能留言把欢甚是遗憾。<br>缺少了留言支持、请教解惑、互相探讨，总感觉博客没有灵魂。</p>
</blockquote>
<a id="more"></a>

<h4 id="废话连篇"><a href="#废话连篇" class="headerlink" title="废话连篇"></a>废话连篇</h4><p>曾记得，2016 年端午节，在<code>Github Pages</code>上写下了人生中的第一篇博客，那时就用的<code>Hexo + Next</code>主题，时至今日，一直对<code>Hexo + Next</code>甚是喜爱，感谢大佬，感谢开源 🙏 。</p>
<p>期间，经历了换工作、换电脑、换域名、换托管，诸多原因导致博客遗失，不过也是甚好，不能守着过去，要拥抱现在和未来（不应该是拥抱开源吗？）。</p>
<p>之前使用过<code>网易云跟帖</code>，大家都戏称灌水专用，现在业已关闭。</p>
<p>接着使用了<code>来必力</code>，一个来自韩国的评论插件，国内访问甚是感人，至于大佬们的反向代理，那时心有余而力不足，遂卒。</p>
<p>后来使用了<code>valine</code>，依托于<a href="https://www.leancloud.cn/">LeanCloud</a>在国内运营，对用户甚是友好，界面也是简洁清新，让人看一眼就喜爱，而且支持阅读统计等诸多功能，之后便一直使用。</p>
<p>偶然间，在<code>知乎</code>上闲逛时，发现了一位大兄关于评论插件的分析和感想，现在依稀记得的一句话就是“无论第三方插件的使用有多友好，数据都存在第三方，哪天他们歇业停工了，数据一样丢失。”，之后就对此耿耿于怀（当然不是对说这句话的仁兄耿耿于怀）。</p>
<p>重建博客之际，对评论插件抱着谨慎的态度选之又选，决定将数据存在<code>Github</code>上，至于歇业停工，既然博客数据都不存在了，还留着评论数据作甚，就让他们同生共死吧。</p>
<p><code>Gitalk</code>和<code>Gitment</code>最先映入眼帘，之后在<code>Github</code>上发现<code>Gitment</code>好久没有更新了，只剩下一个选择。</p>
<p><code>Hexo</code>官方集成了<code>Gitalk</code>，轻车熟路的做好设置，<code>hexo clean | g | s</code>三部曲之后，熟悉的框框出现，然鹅，发现每篇文章都要手动初始化，翻阅<a href="https://github.com/gitalk/gitalk/wiki/%E8%AF%84%E8%AE%BA%E5%88%9D%E5%A7%8B%E5%8C%96">官方 Wiki</a>发现了自动初始化的脚本，底部有<a href="https://draveness.me/git-comments-initialize/">原作者</a> 的链接，遂前往，准备学习膜拜一番，看了大佬的思路解析，大呼过瘾之际也感落寞，原因无他，就是自己不会<code>Ruby</code>。在准备留言评论之际，发现又有<a href="https://www.lshell.com/post/use-github-action-and-python-to-automatically-initialize-gitalk-comments/">大佬</a>给出了使用<code>Python</code>初始化的思路，用轮子不是目的，读懂造轮子的思路学习造轮子，岂不快哉。</p>
<p>进入文章，阅读之际，大佬既感且叹地推荐了一个新的评论插件<code>utterances</code>，揣着疑惑的心去<a href="https://utteranc.es/">官网</a>，去<a href="https://github.com/utterance/utterances">官方仓库</a>查看了一番，发现没有 Wiki，也没有文档，善用搜索引擎的我，搜索一番之后发现，似乎<code>Next</code>主题之前的某个版本集成过，但翻阅了现在的版本又毫无所获，教程都是根据集成时的方法写的，对我无用。</p>
<p>在这里，不得不提的是<code>Hexo</code>的一项前瞻性功能<code>代替配置文件</code>和<code>代替主题配置文件</code>，再也不用像之前一样，想要实现某个功能就去修改官方文件，它不破坏官方文件的完整性，可以无痛更新，之前最头疼的一件事儿就是<code>拉取官方更新之后合并冲突</code>。</p>
<p>这次重建博客，所有非官方功能，如 404、音乐、footer，都使用<code>注入</code>实现，我对这项功能的称呼，暂且这么叫吧。</p>
<p>以上都是废话，下面进入正题：</p>
<h4 id="首先，需要一个用来存储评论的仓库"><a href="#首先，需要一个用来存储评论的仓库" class="headerlink" title="首先，需要一个用来存储评论的仓库"></a>首先，需要一个用来存储评论的仓库</h4><ul>
<li>你可以新建一个仓库；</li>
<li>当然，也可以像我一样，存放在博客仓库的 Issues 中，毕竟我已经承诺了它们同生共死，说到就要做到；</li>
<li>Issues 无法删除，请谨慎选择，防止过多的无用 Issues 带来烦恼（设置 utterances 的时候，这句话依然有效！）；</li>
</ul>
<h4 id="安装-utterances"><a href="#安装-utterances" class="headerlink" title="安装 utterances"></a>安装 utterances</h4><ul>
<li><p>点击<a href="https://github.com/apps/utterances">这里</a>打开安装页面，然后点击右上角的<code>安装</code>；</p>
</li>
<li><p>按下安装按钮，（不不不，不够严谨，按下是 201，抬起才是 202），你会跳转到：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giukvthjlpj30fy0oqtbi.jpg" alt="第二步"></p>
<p>如图所示的页面，选择第一步中创建的仓库或已有的仓库，然后点击<code>安装</code>，请记住仓库名，因为接下来要用；</p>
</li>
<li><p>接下来，会跳转到设置页面；</p>
</li>
</ul>
<h4 id="设置-utterances"><a href="#设置-utterances" class="headerlink" title="设置 utterances"></a>设置 utterances</h4><ul>
<li><p>在这里，请务必填写你在上一步中选择的仓库，并在前面加上仓库的所有者：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giul8ahfszj30k60bfwfv.jpg" alt="第三步"></p>
</li>
<li><p>当然，如果你比较调皮，没有填写上一步中选择的仓库，还是有补救办法的，点击<a href="https://github.com/apps/utterances">这里</a>，其实就是安装页面，你会跳转到安装页面，你发现右上角的<code>安装</code>不见了，取而代之的是<code>配置</code>，就是它了，去配置页面修改吧；</p>
</li>
<li><p>至于这里，是配置 utterances 创建新的 Issues 时，给 Issues 起的名儿：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giullxjlwfj30jo0i2q65.jpg" alt="配置"></p>
<p>请自由发挥，因为使用了<a href="https://github.com/rozbo/hexo-abbrlink">abbrlink</a>，链接并不显示文章名称，所以我就选图中所示的选项了，自由发挥的同学，玩的开心；</p>
</li>
<li><p>这里是选填选项，给 utterances 创建的 Issues 设置标签：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giulsj64dxj30jt072dgf.jpg" alt="设置标签"></p>
</li>
<li><p><code>Theme</code>就不用说了吧，主题选自己喜欢的，没喜欢的？给官方提交一个新主题；</p>
</li>
<li><p>接下来就是重头戏了，上面所有的选项都是为它服务的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giulyonf3xj30jz09lq41.jpg" alt="script"></p>
<p>复制 script 并添加到你想要评论出现的地方，bingo！</p>
</li>
</ul>
<h4 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h4><p>因为要用<code>注入</code>来实现评论功能，那就不能修改官方的模板，自己撸了个 js 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* utterances 评论插件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  query2add();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pjax 使用 pushState() 不会触发 hashchange 事件，需要拦截</span></span><br><span class="line"><span class="keyword">var</span> _wr = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> orig = history[type];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="keyword">new</span> Event(type);</span><br><span class="line">    e.arguments = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">window</span>.dispatchEvent(e);</span><br><span class="line">    <span class="comment">// 注意事件监听在url变更方法调用之前 也就是在事件监听的回调函数中获取的页面链接为跳转前的链接</span></span><br><span class="line">    <span class="keyword">var</span> rv = orig.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState = _wr(<span class="string">&quot;pushState&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 change 事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;pushState&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e &amp;&amp; e.arguments.length &gt; 2 &amp;&amp; e.arguments[2]</span></span><br><span class="line">  query2add();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 utterance 插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadUtterance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> js = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  <span class="comment">/* 以下内容改成第三步生成的配置 */</span></span><br><span class="line">  js.setAttribute(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;https://utteranc.es/client.js&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;repo&quot;</span>, <span class="string">&quot;Undeio/undeio.github.io&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;issue-term&quot;</span>, <span class="string">&quot;title&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;theme&quot;</span>, <span class="string">&quot;github-light&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;crossorigin&quot;</span>, <span class="string">&quot;anonymous&quot;</span>);</span><br><span class="line">  js.setAttribute(<span class="string">&quot;async&quot;</span>, <span class="string">&quot;async&quot;</span>);</span><br><span class="line">  <span class="comment">/* 以上内容需要修改 */</span></span><br><span class="line">  <span class="comment">// 添加到主体部分的末尾</span></span><br><span class="line">  <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;main-inner&quot;</span>)[<span class="number">0</span>].appendChild(js);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已存在组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query2add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有正文页面才有 post-copyright，也就是最后的版权声明</span></span><br><span class="line">  <span class="comment">// 当然，你也可以找一个自己正文才有的标识进行判断</span></span><br><span class="line">  <span class="keyword">let</span> postCopyRight = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;post-copyright&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (postCopyRight &amp;&amp; postCopyRight[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="comment">// 存在评论就放弃添加</span></span><br><span class="line">    <span class="keyword">let</span> utterances = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;utterances&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (utterances &amp;&amp; utterances[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loadUtterance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无图无真相</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giumvnbuw0j30gu0hm0vd.jpg" alt="真相"></p>
<p>最终效果</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giun047pynj30w10admy8.jpg" alt="效果"></p>
<blockquote>
<p>才疏学浅，实现比较粗糙，如果你有更好的实现，请给我留言。</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Utterance</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器小记</title>
    <url>/post/592731679/</url>
    <content><![CDATA[<h3 id="通用寄存器拆分"><a href="#通用寄存器拆分" class="headerlink" title="通用寄存器拆分"></a>通用寄存器拆分</h3><p>EAX / EBX / ECX / EDX</p>
<p>例如：</p>
<ul>
<li>EAX = 12345678</li>
<li>&nbsp;&nbsp;&nbsp;AX = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5678</li>
<li>&nbsp;&nbsp;&nbsp;AH = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;56</li>
<li>&nbsp;&nbsp;&nbsp;AL = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;78<a id="more"></a></li>
<li>ESP 永远指向堆栈的最顶端；</li>
<li>堆栈顶端为 ESP，依次向下为 ESP + 4、ESP + 8 ，以此类推；</li>
<li>EIP 永远指向 CPU 即将执行的地址；</li>
<li><code>FS 寄存器</code>从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 存放的是起始位置的地址；</li>
</ul>
<h3 id="标志位寄存器"><a href="#标志位寄存器" class="headerlink" title="标志位寄存器"></a>标志位寄存器</h3><ul>
<li><p>OF 是<code>溢出标志位</code>;</p>
<ul>
<li>当指令改变了符号位且返回错误值的时候，OF 为 1，表示溢出成立；</li>
<li>运算结果超出机器能够表示的范围称为溢出；</li>
</ul>
</li>
<li><p>PF 是 <code>奇偶标志位</code>；</p>
<ul>
<li>当指令的<code>返回值的二进制</code>表现形式中<code>1</code>的个数为偶数个时，PF 为 1；</li>
<li>运算结果的最低 16 位中含 1 的个数为偶数；</li>
<li>如：11，101，110，1001，1010，1100，1111</li>
</ul>
</li>
<li><p>ZF 是<code>0 标志符</code>.</p>
<ul>
<li>当前指令的运算结果为 0，则 ZF 为 1；</li>
</ul>
</li>
<li><p>SF 是<code>符号位标志符</code>;</p>
<ul>
<li>当指令的运算结果为负数时，SF 为 1；</li>
<li>SF 与运算结果的最高位相同；</li>
</ul>
</li>
<li><p>CF 是<code>进位标志符</code>；</p>
<ul>
<li>当指令的无符号运算结果超过最大值时，CF 为 1；</li>
<li>最高位产生进位或借位；</li>
</ul>
</li>
<li><p>AF 是<code>辅助进位标志符</code>；</p>
<ul>
<li>当指令的运算结果的低 4 位向高 4 位有进位或借位时，AF 为 1；</li>
</ul>
</li>
<li><p>TF 是<code>跟踪标志符</code>；</p>
<ul>
<li>用于调试单步操作；</li>
<li>若 TF 为 1，则每条指令执行结束后，产生中断；</li>
</ul>
</li>
<li><p>DF 是<code>方向标志符</code>；</p>
<ul>
<li>用来控制串处理指令的处理方向；</li>
<li>若 DF 为 1，则串处理中地址自动递减，否则自动自增；</li>
<li>若 DF 为 1，每次操作后使 SI 和 DI 递减，DF 为 0 时则自增；</li>
</ul>
</li>
<li><p>IF 是<code>中断标志符</code>；</p>
<ul>
<li>用来控制 CPU 是否响应可屏蔽中断；</li>
<li>若 IF 为 1 则允许中断，否则禁止中断；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的汇编指令</title>
    <url>/post/1025109479/</url>
    <content><![CDATA[<h3 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h3><h4 id="NOP"><a href="#NOP" class="headerlink" title="NOP"></a>NOP</h4><ul>
<li>NOP 的机器码是<code>90</code>；</li>
<li>NOP 是空指令，就是没有操作，无操作；</li>
<li>使用 <code>NOP</code> 来填充指令执行后多出来的字节，而不是用<code>00</code>来填充；</li>
</ul>
<a id="more"></a>

<h4 id="PUSH-压入堆栈"><a href="#PUSH-压入堆栈" class="headerlink" title="PUSH 压入堆栈"></a>PUSH 压入堆栈</h4><p>PUSH 的用法：</p>
<ul>
<li><code>PUSH 0x1 / 0xF</code>：把十六进制数字压入堆栈顶部；</li>
<li><code>PUSH EAX / EBX</code>：把指定寄存器中的数据压入堆栈顶部；</li>
<li><code>PUSH [00401000]</code>：把指定内存地址中的数据压入堆栈顶部；</li>
</ul>
<h4 id="POP-弹出堆栈"><a href="#POP-弹出堆栈" class="headerlink" title="POP 弹出堆栈"></a>POP 弹出堆栈</h4><p>POP 的用法：</p>
<ul>
<li><code>POP EAX / EBX</code>：将堆栈顶部的内容弹出并放入指定的寄存器；</li>
</ul>
<h4 id="PUSHAD"><a href="#PUSHAD" class="headerlink" title="PUSHAD"></a>PUSHAD</h4><ul>
<li>通用寄存器指：EAX / ECX / EDX / EBX / ESP / EBP / ESI / EDI；</li>
<li>PUSHAD 保护现场 / 备份现场，将通用寄存器的数据自上而下依次压入堆栈，最后一个寄存器的数据处于堆栈顶部；</li>
<li>PUSHAD 是 32 位操作；</li>
<li><code>PUSHAD</code> 相当于是<code>PUSH EAX, PUSH ECX, PUSH EDX, PUSH EBX, PUSH ESP, PUSH EBP, PUSH ESI, PUSH EDI</code>八条命令的合集；</li>
</ul>
<h4 id="POPAD"><a href="#POPAD" class="headerlink" title="POPAD"></a>POPAD</h4><ul>
<li>通用寄存器指：EAX / ECX / EDX / EBX / ESP / EBP / ESI / EDI；</li>
<li>POPAD 还原现场，将堆栈顶部的数据依次弹出并自下而上依次填充到通用寄存器；</li>
<li>POPAD 是 32 位操作；</li>
<li><code>POPAD</code> 相当于是<code>POP EDI, POP ESI, POP EBP, POP ESP, POP EBX, POP EDX, POP ECX, POP EAX</code>八条命令的合集；</li>
</ul>
<h4 id="PUSHA"><a href="#PUSHA" class="headerlink" title="PUSHA"></a>PUSHA</h4><ul>
<li>PUSHA 和 PUSHAD 功能相同，用于备份现场；</li>
<li>PUSHA 是 16 位操作；</li>
<li><code>PUSHA</code> 相当于是<code>PUSH AX, PUSH CX, PUSH DX, PUSH BX, PUSH SP, PUSH BP, PUSH SI, PUSH DI</code>八条命令的合集；</li>
</ul>
<h4 id="POPA"><a href="#POPA" class="headerlink" title="POPA"></a>POPA</h4><ul>
<li>POPA 和 POPAD 功能相同，用于还原现场；</li>
<li>POPA 是 16 位操作；</li>
<li><code>POPA</code> 相当于是<code>POP DI, POP SI, POP BP, POP SP, POP BX, POP DX, POP CX, POP AX</code>八条命令的合集；</li>
</ul>
<h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h4><ul>
<li>MOV 本意为<code>move，移动</code>，但功能相当于复制/赋值；</li>
<li><code>MOV EAX, ECX</code>：两个操作数的长度必须相同；</li>
<li><code>MOV EAX, ECX</code>：复制<code>ECX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，4 字节操作；</li>
<li><code>MOV AX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>AX（第一个参数）</code>，2 字节操作；</li>
<li><code>MOV AL, CL</code>：复制<code>CL（第二个参数）</code>的数据到<code>AL（第一个参数）</code>，1 字节操作；</li>
<li><code>MOV [00402000], EAX</code>：复制<code>EAX（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，4 字节操作；</li>
<li><code>MOV [00402000], AX</code>：复制<code>AX（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，2 字节操作；</li>
<li><code>MOV [00402000], AH</code>：复制<code>AH（第二个参数）</code>的数据到<code>[指定内存地址]（第一个参数）</code>，1 字节操作；</li>
</ul>
<h4 id="MOVSX"><a href="#MOVSX" class="headerlink" title="MOVSX"></a>MOVSX</h4><ul>
<li><code>MOVSX EAX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，如果<code>EAX（第一个参数）</code>的长度比<code>CX（第二个参数）</code>长，剩余的长度用<code>CX（第二个参数）</code>的符号位填充；</li>
<li>正数用 0 填充，负数用 F 填充；</li>
</ul>
<h4 id="MOVZX"><a href="#MOVZX" class="headerlink" title="MOVZX"></a>MOVZX</h4><ul>
<li><code>MOVZX EAX, CX</code>：复制<code>CX（第二个参数）</code>的数据到<code>EAX（第一个参数）</code>，如果<code>EAX（第一个参数）</code>的长度比<code>CX（第二个参数）</code>长，剩余的长度用 0 填充；</li>
<li>带 0 扩展传送命令；</li>
</ul>
<h4 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h4><ul>
<li>LEA：复制<code>第二个参数的内存地址</code> 或 <code>第二个参数运算后的内存地址</code>到<code>第一个参数</code>；</li>
<li><code>LEA EAX, [00401000]</code>：第一个参数必须是通用寄存器，第二个参数必须是内存地址；</li>
<li><code>LEA EAX, [ECX + 16]</code>：第一个参数必须是通用寄存器，第二个参数必须是内存地址；</li>
</ul>
<h4 id="XCHG-互换-交换"><a href="#XCHG-互换-交换" class="headerlink" title="XCHG 互换 / 交换"></a>XCHG 互换 / 交换</h4><ul>
<li><code>XCHG EAX, ECX</code>：第一个参数可以是通用寄存器或内存地址，第二个参数必须是通用寄存器；</li>
<li><code>XCHG [00401000], ECX</code>：第一个参数可以是通用寄存器或内存地址，第二个参数必须是通用寄存器；</li>
</ul>
<h4 id="SHR-二进制右移"><a href="#SHR-二进制右移" class="headerlink" title="SHR 二进制右移"></a>SHR 二进制右移</h4><h4 id="SHL-二进制左移"><a href="#SHL-二进制左移" class="headerlink" title="SHL 二进制左移"></a>SHL 二进制左移</h4><h4 id="CLD"><a href="#CLD" class="headerlink" title="CLD"></a>CLD</h4><ul>
<li>用来操作方向标志位 DF，CLD 使 DF 复位，即让 DF = 00；</li>
</ul>
<h4 id="STD"><a href="#STD" class="headerlink" title="STD"></a>STD</h4><ul>
<li>用来操作方向标志位 DF，STD 使 DF 置位，即让 DF = 01；</li>
</ul>
<h3 id="数学指令"><a href="#数学指令" class="headerlink" title="数学指令"></a>数学指令</h3><h4 id="ADD-SUB-加法-减法"><a href="#ADD-SUB-加法-减法" class="headerlink" title="ADD / SUB | 加法 / 减法"></a>ADD / SUB | 加法 / 减法</h4><ul>
<li><code>ADD / SUB</code>的返回结果放在第一个参数中；</li>
</ul>
<h4 id="ADC-带进位的加法"><a href="#ADC-带进位的加法" class="headerlink" title="ADC 带进位的加法"></a>ADC 带进位的加法</h4><ul>
<li><code>ADC EAX, ECX</code> = <code>EAX + ECX + 0 | 1</code>：两个参数累加并且加上<code>进位标识符CF</code>的值为最终结果；</li>
</ul>
<h4 id="SBB-带进位的减法"><a href="#SBB-带进位的减法" class="headerlink" title="SBB 带进位的减法"></a>SBB 带进位的减法</h4><ul>
<li><code>SBB EAX, ECX</code> = <code>EAX - ECX - 0 | 1</code>：两个参数相减并且减去<code>进位标识符CF</code>的值为最终结果；</li>
</ul>
<h4 id="INC-DEC-自增-自减"><a href="#INC-DEC-自增-自减" class="headerlink" title="INC / DEC | 自增 / 自减"></a>INC / DEC | 自增 / 自减</h4><ul>
<li><code>INC EAX</code>：每执行一次该指令，参数的值自增 1；</li>
<li><code>DEC EAX</code>：每执行一次该指令，参数的值自减 1；</li>
</ul>
<h4 id="MUL-无符号乘法"><a href="#MUL-无符号乘法" class="headerlink" title="MUL 无符号乘法"></a>MUL 无符号乘法</h4><ul>
<li><code>MUL ECX</code>：<code>MUL CL | CX | ECX</code>默认和 <code>AL | AX | EAX</code>做乘法运算，运算结果分别存放到<br><code>AL | DX:AX | EDX:EAX</code>中，其中<code>DX 或 EDX</code>存放高位，<code>AX 或 EAX</code>存放低位；</li>
</ul>
<h4 id="DIV-无符号除法"><a href="#DIV-无符号除法" class="headerlink" title="DIV 无符号除法"></a>DIV 无符号除法</h4><ul>
<li><code>DIV CL</code>：默认的被除数为<code>EAX</code>，如果 <code>CL（除数）</code>是 8 位，那么<code>商</code>放在<code>AL</code>中，<code>余数</code>放在<code>AH</code>中；</li>
<li><code>DIV CX</code>：默认的被除数为<code>EAX</code>，如果 <code>CX（除数）</code>是 16 位，那么<code>商</code>放在<code>AX</code>中，<code>余数</code>放在<code>DX</code>中；</li>
<li><code>DIV ECX</code>：默认的被除数为<code>EAX</code>，如果 <code>ECX（除数）</code>是 32 位，那么<code>商</code>放在<code>EAX</code>中，<code>余数</code>放在<code>EDX</code>中；</li>
</ul>
<h4 id="IMUL-有符号乘法"><a href="#IMUL-有符号乘法" class="headerlink" title="IMUL 有符号乘法"></a>IMUL 有符号乘法</h4><ul>
<li>立即数：自然数；</li>
<li>单操作数：<code>IMUL CL | CX | ECX</code>默认和 <code>AL | AX | EAX</code>做乘法运算，运算结果分别存放到<br><code>AL | DX:AX | EDX:EAX</code>中，其中<code>DX 或 EDX</code>存放高位，<code>AX 或 EAX</code>存放低位；</li>
<li>双操作数：<code>IMUL AX, CX | 0x2</code>：第一个参数必须是通用寄存器，第二个参数可以是通用寄存器、内存地址或立即数，运算结果存放到第一个参数中；</li>
<li>三操作数：<code>IMUL AX, CX, 0x2</code>：第一个参数必须是通用寄存器，第二个参数可以是通用寄存器或内存地址，第三个参数必须是立即数，将第二个参数和第三个参数的运算结果存放到第一个参数中；</li>
</ul>
<h4 id="IDIV-有符号除法"><a href="#IDIV-有符号除法" class="headerlink" title="IDIV 有符号除法"></a>IDIV 有符号除法</h4><ul>
<li><code>IDIV CL</code>：默认的被除数为<code>EAX</code>，如果 <code>CL（除数）</code>是 8 位，那么<code>商</code>放在<code>AL</code>中，<code>余数</code>放在<code>AH</code>中；</li>
<li><code>IDIV CX</code>：默认的被除数为<code>EAX</code>，如果 <code>CX（除数）</code>是 16 位，那么<code>商</code>放在<code>AX</code>中，<code>余数</code>放在<code>DX</code>中；</li>
<li><code>IDIV ECX</code>：默认的被除数为<code>EAX</code>，如果 <code>ECX（除数）</code>是 32 位，那么<code>商</code>放在<code>EAX</code>中，<code>余数</code>放在<code>EDX</code>中；</li>
</ul>
<h4 id="XADD-先交换后相加"><a href="#XADD-先交换后相加" class="headerlink" title="XADD 先交换后相加"></a>XADD 先交换后相加</h4><ul>
<li><code>XADD EAX, ECX</code>：先交换两个参数的值，然后进行加法运算，运算结果保存在第一个参数中；</li>
</ul>
<h4 id="NEG-取反"><a href="#NEG-取反" class="headerlink" title="NEG 取反"></a>NEG 取反</h4><ul>
<li><code>NEG EAX</code>：如题，取反</li>
</ul>
<h3 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h3><h4 id="AND-OR-XOR-NOT"><a href="#AND-OR-XOR-NOT" class="headerlink" title="AND / OR / XOR / NOT"></a>AND / OR / XOR / NOT</h4><ul>
<li>全部以二进制形式进行比较 / 操作；</li>
<li><code>AND EAX, ECX</code>：双 1 为 1，否则为 0；</li>
<li><code>OR EAX, ECX</code>：逢 1 为 1，否则为 0；</li>
<li><code>XOR EAX, ECX</code>：不同为 1，相同为 0；</li>
<li><code>NOT EAX</code>：二进制取反；</li>
</ul>
<h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h4><ul>
<li><code>CMP EAX, ECX</code>：两个参数相减进行比较，如果运算结果为 0，则 <code>ZF（0 标志位）</code>为 1；</li>
<li>通用寄存器、内存地址和立即数之间可以相互比较；</li>
</ul>
<h4 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h4><ul>
<li><code>TEST EAX, EAX</code>：判断 EAX 自身是否为 0；</li>
<li>如果运算结果为 0，且 ZF（0 标志位）为 1，则说明 EAX 自身为 0；</li>
</ul>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h4 id="JMP-无条件跳转"><a href="#JMP-无条件跳转" class="headerlink" title="JMP 无条件跳转"></a>JMP 无条件跳转</h4><ul>
<li><code>JMP 00401018</code>：无条件跳转；</li>
</ul>
<h4 id="JE-JZ"><a href="#JE-JZ" class="headerlink" title="JE / JZ"></a>JE / JZ</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>ZF（0 标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNE-JNZ"><a href="#JNE-JNZ" class="headerlink" title="JNE / JNZ"></a>JNE / JNZ</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>ZF（0 标志位）</code>为 0 则跳转；</li>
<li>与<code>JE / JZ</code>相反；</li>
</ul>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><ul>
<li><code>SF（符号位标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNS"><a href="#JNS" class="headerlink" title="JNS"></a>JNS</h4><ul>
<li><code>SF（符号位标志位）</code>为 0 则跳转；</li>
<li>与<code>JS</code>相反；</li>
</ul>
<h4 id="JP-JPE"><a href="#JP-JPE" class="headerlink" title="JP / JPE"></a>JP / JPE</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>PF（奇偶标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNP-JPO"><a href="#JNP-JPO" class="headerlink" title="JNP / JPO"></a>JNP / JPO</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>PF（奇偶标志位）</code>为 0 则跳转；</li>
<li>与<code>JP / JPE</code>相反；</li>
</ul>
<h4 id="JO"><a href="#JO" class="headerlink" title="JO"></a>JO</h4><ul>
<li><code>OF（溢出标志位）</code>为 1 则跳转；</li>
</ul>
<h4 id="JNO"><a href="#JNO" class="headerlink" title="JNO"></a>JNO</h4><ul>
<li><code>OF（溢出标志位）</code>为 0 则跳转；</li>
<li>与<code>JO</code>相反；</li>
</ul>
<h4 id="JB"><a href="#JB" class="headerlink" title="JB"></a>JB</h4><ul>
<li><code>CF（进位 / 借位 标志位）</code>为 1 则跳转；</li>
<li>JB 不关注符号位，只关注无符号位的运算；</li>
</ul>
<h4 id="JNB"><a href="#JNB" class="headerlink" title="JNB"></a>JNB</h4><ul>
<li><code>CF（进位 / 借位 标志位）</code>为 0 则跳转；</li>
<li>与<code>JB</code>相反；</li>
</ul>
<h4 id="JL"><a href="#JL" class="headerlink" title="JL"></a>JL</h4><ul>
<li><code>SF（）符号位标志位</code>为 1 则跳转；</li>
<li>与 JB 不同的是，JL 关注有符号位的运算；</li>
<li>JL 会忽略<code>CF（进位 / 借位 标志位）</code>的变化；</li>
</ul>
<h4 id="JBE"><a href="#JBE" class="headerlink" title="JBE"></a>JBE</h4><ul>
<li><code>OF（溢出标志位）为 1</code>或<code>ZF（0 标志位）为 0</code>则跳转；</li>
<li>小于等于；</li>
</ul>
<h4 id="JNBE-JA"><a href="#JNBE-JA" class="headerlink" title="JNBE / JA"></a>JNBE / JA</h4><ul>
<li>名称不同，功能相同；</li>
<li><code>OF（溢出标志位）为 0</code>并且<code>ZF（0 标志位）为 1</code>则跳转；</li>
<li>必须是大于；</li>
</ul>
<h4 id="CALL-RETN"><a href="#CALL-RETN" class="headerlink" title="CALL / RETN"></a>CALL / RETN</h4><ul>
<li>CALL 可以理解为 CALLBACK；</li>
<li>CALL 会执行一个子程序，可以理解为执行了一个函数；</li>
<li>RETN 在 CALL 所执行的子程序中时，会返回该 CALL 所在的主程序，并继续向下执行；</li>
<li>RETN 与其他指令单独使用时，和 JMP 的功能相同；</li>
</ul>
<h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><ul>
<li><p>LOOP 相当于</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">XOR</span> <span class="built_in">ECX</span>, <span class="built_in">ECX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">ECX</span>, <span class="number">6</span></span><br><span class="line"><span class="keyword">DEC</span> <span class="built_in">ECX</span></span><br><span class="line"><span class="comment">; CMP ECX, 0</span></span><br><span class="line"><span class="keyword">TEST</span> <span class="built_in">ECX</span>, <span class="built_in">ECX</span></span><br><span class="line"><span class="keyword">JNZ</span> [<span class="keyword">DEC</span> <span class="built_in">ECX</span> 所在的地址]</span><br></pre></td></tr></table></figure>
</li>
<li><p>与以上指令不同的是：LOOP 执行时第一次循环计数器不会自减；</p>
</li>
<li><p>约定俗成：使用 ECX 作为计数器；</p>
</li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>直接寻址：指令后面直接写出此次运算使用的地址，称为直接寻址；</li>
<li>间接寻址：只有执行到某一行指令才能知道此次运算使用的地址，称为间接寻址；</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（一）</title>
    <url>/post/1969921723/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
<li>参考教程：<code>反调试之IsDebuggerPresent</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7morb9trj3087083mx8.jpg" alt="打开"></p>
<ul>
<li>ID 不可输入，应该是根据电脑硬件的某些特征生成的；</li>
<li>输入随机注册码点击 Check 之后，没有任何反馈；</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>既然程序有输入，有按钮，那可用的 API 可就多了。按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，用的<code>API</code>不多，一眼就看到了<code>GetWindowTextA</code>，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，嘿嘿，程序窗口一闪而过，而且<code>OD</code>的右下角也显示了程序的状态：<code>已终止</code>，;</p>
</li>
<li><p>如果说程序损坏的话，那么刚开始的时候应该也是打不开的；</p>
</li>
<li><p>如果说<code>OD</code>出现了问题，那么程序应该倒入不进来，而且查看不了 API 列表；</p>
</li>
<li><p>到底是什么问题呢？不绕弯子，程序有反调试，至于是如何反调试的？它就是今天的主角儿<code>IsDebuggerPresent</code>:</p>
<ul>
<li><p>先了解一下这个 API：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IsDebuggerPresent</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">     确定调用进程是否由用户模式的调试器调试。</span><br><span class="line"> 返回值</span><br><span class="line">     如果当前进程运行在调试器的上下文，返回值为非零值。</span><br><span class="line">     如果当前进程没有运行在调试器的上下文，返回值为零。</span><br></pre></td></tr></table></figure>

<p>看着好绕，大白话：检测当前程序是否正在被调试，没有被调试返回 0，只要返回值不是 0，那就表示程序正在被调试；</p>
</li>
</ul>
</li>
<li><p>既然知道它是一个 Windows API，那我们不妨按下<code>Ctrl + N</code>去函数列表看看这个程序是否调用了<code>IsDebuggerPresent</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7nnd0jurj316d0n974i.jpg" alt="API"></p>
<p>果然，在函数列表中发现了<code>IsDebuggerPresent</code>，不过，怎么证明它被调用了，而不是放在函数列表中迷惑我们呢？</p>
</li>
<li><p>很简单，给它设置一个断点，然后运行程序，没有意外，程序中断了，那就说明程序调用了这个 API：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7o1rwvmpj316b0n8dgl.jpg" alt="中断"></p>
<p>我们都知道<code>API 断点</code>会中断在函数的行首，也就是说，<code>IsDebuggerPresent</code>这个函数并没有执行，如果<code>Ctrl + F9</code>执行到返回，这个函数才算执行完毕了，而一旦它执行完毕，就意味着程序是否被调试它已经检测完成了，但从代码上看，只有区区 4 行，它是如何检测的呢，分析一下；</p>
</li>
<li><p>分析一下这 4 行代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">FS</span>:[<span class="number">18</span>]       <span class="comment">; 将 FS:[18] 中的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">EAX</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">30</span>]   <span class="comment">; 将 EAX 中的地址加 0x30 之后的地址拷贝到 EAX</span></span><br><span class="line"><span class="keyword">MOVZX</span> <span class="built_in">EAX</span>,<span class="built_in">BYTE</span> <span class="built_in">PTR</span> <span class="built_in">DS</span>:[<span class="built_in">EAX</span>+<span class="number">2</span>]   <span class="comment">; 将 EAX 中的地址，存储的第 2 个字节的数据拷贝到 EAX</span></span><br><span class="line"><span class="keyword">RETN</span>                            <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>

<p>嘛意思？往下分析；</p>
<ul>
<li><p><code>FS:[18]</code>中的<code>FS 寄存器</code>的地址是什么呢？</p>
<p><code>SF 标志位</code>指向<code>FS 寄存器</code>的地址；</p>
</li>
<li><p>开始分析代码，先是第 1 行代码<code>MOV EAX,DWORD PTR FS:[18]</code>：将<code>FS:[18]</code>中的地址拷贝到 <code>EAX</code>；</p>
<blockquote>
<p><code>FS 寄存器</code>从第 18 位开始，存放的是该寄存器从起始位置依次向后的地址，即第 18 存放的是起始位置的地址；</p>
</blockquote>
<p>对这句话很困惑？那我们按下<code>Ctrl + G</code>跟随一下这个地址，在这里，我的机器上，<code>FS</code>的地址是<code>7FFDF000</code>，那<code>FS:[18]</code>的地址就显而易见了，是<code>7FFDF018</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7pi19cnvj316d0nz0ua.jpg" alt="FS"></p>
<p><code>FS:[18]</code>的地址是<code>7FFDF018</code>，按下<code>F7</code>，单步执行代码，同时查看<code>EAX 寄存器</code>，丝毫不差，<code>FS:[18]</code>存放的正是<code>FS 寄存器</code>的起始地址<code>7FFDF000</code>，既然第 1 行代码搞定，那就开始分析第二行；</p>
</li>
<li><p>第 2 行代码<code>MOV EAX,DWORD PTR DS:[EAX+30]</code>：将 EAX 中的地址加 0x30 之后的地址拷贝到<code>EAX</code>；</p>
<p>与上一步相同，按下<code>Ctrl + G</code>跟随<code>7FFDF030</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7puc1wkhj316e0o0ta1.jpg" alt="加30"></p>
<p>没有意外，运行结果与我们分析的一致：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7pzqqa7hj316f0o0t9r.jpg" alt="运行后"></p>
</li>
<li><p>第 3 行代码<code>MOVZX EAX,BYTE PTR DS:[EAX+2]</code>：将 EAX 中的地址，存储的第 2 个字节的数据拷贝到 EAX；</p>
<p>跟随一下这个地址，看看它存储的是什么内容：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7q63xhhtj316c0ncwfo.jpg" alt="数据"></p>
<p>它存储的数据很简单，第二个字节是<code>01</code>，而根据<code>没有被调试返回 0，只要返回值不是 0，那就表示程序正在被调试</code>这句话来看，很明显，它检测到我们正在调试程序：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7q9nu35cj316b0nzgmb.jpg" alt="返回"></p>
<p>至此，恍然大明白，原来这 4 行代码就可以检测程序有没有被调试，至于为什么这里存放的是<code>01</code>这个数据，不得而知；</p>
</li>
<li><p>顺带提一嘴，如果程序倒入<code>OD</code>没有运行，那么<code>EBX 寄存器</code>指向的地址就是以上三行代码执行后需要取出数据的地址，也就是存放 01 的地址；</p>
</li>
</ul>
</li>
<li><p>既然已经明白了它是如何检测的以及知道了它的返回值，那如何绕过呢？</p>
<p>当然是修改返回值，也就是<code>EAX 寄存器</code>的值喽，没有调试返回 0，那返回 0 就是没有调试；</p>
</li>
<li><p>原理也明白了，也能绕过了，那么，它检测到程序被调试后，是如何退出程序的呢？意犹未尽；</p>
<p>不修改返回值，跟随一下<code>RETN</code>，看看它接下来会做什么？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7qkxbg5mj31690nbq3n.jpg" alt="退出消息"></p>
<p>哦豁，它用<code>PostQuitMessage</code>提交了退出消息，接着跟；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7qpagltqj316a0ncwf9.jpg" alt="退出进程"></p>
<p>然后，调用退出进程函数<code>ExitProcess</code>，再运行一下下，结束！</p>
</li>
<li><p>由于本文重点是了解反调试，那么分析找到对应用户名的序列号之后就到此为止吧；</p>
</li>
<li><p>至于序列号的算法，既然用户名都是计算出来的，那肯定是软编码喽；不过，换个角度，在机器没有任何变动的情况下，相对于这台机器，它是硬编码；</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（三）</title>
    <url>/post/140693809/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><code>OD</code>补丁程序<code>re-pair</code>；</li>
<li>类名检测工具<code>Greatis WinDowse</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
<li>参考教程：<code>反调试之检测类名与标题名</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>依然是学习完毕后的总结；</p>
</li>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glil6ahwdjj206u05wjrb.jpg" alt="打开软件"></p>
<p>如果没有打开<code>OD</code>，程序可以打开并显示如上，如果打开了<code>OD</code>，程序则无法打开；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先，<code>Ctrl + N</code>查看一下 API 列表，很意外，出奇的干净，只有区区两个 API：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glilavu0fxj223w18adov.jpg" alt="API列表"></p>
<p>还好有一个我们认识的<code>ExitProcess</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExitProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    结束调用的进程及其所有的线程；</span><br></pre></td></tr></table></figure>

<p>那就只能从它下手了：设置 CC 断点并设置好备注；</p>
</li>
<li><p>接着，运行程序，程序会中断在我们设置的断点<code>ExitProcess</code>函数的行首，然后在<code>堆栈窗口</code>右键<code>反汇编窗口中跟随</code>来到调用这个函数的位置：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1gliljf7ujcj223w18a145.jpg" alt="反汇编窗口中跟随"></p>
<p>这里很困惑？困惑的同学没学懂，再复习一下 API 吧；</p>
<p>常规操作是：<code>Ctrl + F9</code>执行到返回，然后看它获取的数据，再进行下一步操作；</p>
<p>然鹅，别忘了<code>ExitProcess</code>的功能：结束进程及其所有的线程。</p>
<p>如果我们<code>Ctrl + F9</code>执行到返回，是不是意味着我们手动执行了结束进程的函数，那么，这个断点的意义是什么？</p>
<p>所以，我们要跟随函数到调用它的地方，往上看，为什么要调用它？</p>
</li>
<li><p>来到<code>反汇编窗口</code>，发现调用位置的同时，也发现了很多 API，其中大部分都不认识，但是有一根救命稻草<code>GetProcAddress</code>:</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glilw2i3xjj223w18a14a.jpg" alt="反汇编窗口"></p>
<p>既然 API 列表没有内容的同时发现了<code>GetProcAddress</code>，那是不是说明，大多数函数都被隐藏了，而<code>GetProcAddress</code>就是关键呢？</p>
<p>再来复习一下<code>GetProcAddress</code>的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetProcAddress</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定的动态链接库中的输出库函数地址；</span><br><span class="line">    （获取函数列表中不显示且被调用的隐藏函数的地址；）</span><br><span class="line">    （捕捉间接加载或调用的其他隐藏函数；）</span><br><span class="line">参数</span><br><span class="line">    hModule：包含此函数的 DLL 模块的句柄；</span><br><span class="line">    （程序的句柄）</span><br><span class="line">    IpProcName：包含函数名的以 NULL 结尾的字符串；</span><br><span class="line">    （程序的名字）</span><br></pre></td></tr></table></figure>

<p>毫无疑问，给<code>GetProcAddress</code>设置断点并做好备注，看看都有哪些隐藏的函数：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glim3yyyutj223w18a7fg.jpg" alt="GetProcAddress"></p>
</li>
<li><p>然后重载并运行程序后程序会中断，接着多次运行直到中断在了<code>ExitProcess</code>后，发现只是调用了以下隐藏函数：<code>CreateToolhelp32Snapshot</code>、<code>OpenProcess</code>、<code>Process32First</code>、<code>Process32Next</code>、<code>TerminateProcess</code>、<code>lstrcmpA</code>、<code>FindWindowA</code>；</p>
<ul>
<li><p>其中，<code>OpenProcess</code>、<code>TerminateProcess</code>、<code>lstrcmpA</code>很熟悉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知 PID 获取程序的句柄；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TerminateProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过进程句柄终止指定进程及其所有线程；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lstrcmpA</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    区分大小写的字符串比较；</span><br><span class="line"></span><br><span class="line">lstrcmpi</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    不区分大小写的字符串比较；</span><br></pre></td></tr></table></figure>
</li>
<li><p>至于其他几个，需要学习一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateToolhelp32Snapshot</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    给所有进程的详细信息拍摄快照，返回快照句柄供其他 API调用；</span><br><span class="line">参数</span><br><span class="line">    dwFlags：用来指定“快照”中需要返回的对象；</span><br><span class="line">    th32ProcessID：指定将要快照的进程ID；</span><br><span class="line">        - 该参数只有在dwFlags设置了TH32CS_SNAPHEAPLIST或者TH32CS_SNAPMODULE后才有效；</span><br><span class="line">        - 该参数为 0 则获取当前进程快照；</span><br><span class="line">        - 其他情况下参数会被忽略，所有的进程都会被快照；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process32First</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    获取进程快照第一个进程的句柄；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process32Next</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    获取进程快照下一个进程的句柄；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FindWindowA</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">    lpClassName：指向类名的字符串或一个可以确定类名字符串的原子；</span><br><span class="line">    lpWindowName：指向窗口名（即窗口标题）的字符串；</span><br><span class="line">作用</span><br><span class="line">    检索并处理顶级窗口的类名和窗口标题匹配指定的字符串；</span><br><span class="line">    不搜索子窗口；</span><br><span class="line">    不区分大小写；</span><br><span class="line">    如果有指定的类名或窗口标题则表示成功返回一个窗口的句柄；否则返回零；</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>了解这些 API 后，重载并运行程序，程序中断后，分别给这些 API 设置断点并做好备注：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glimvt0kmrj223w18a12g.jpg" alt="设置断点并做好备注"></p>
<p>至于断点及备注的设置方法，请翻阅上一篇文章；</p>
</li>
<li><p>设置好所有断点后，再次运行程序，发现程序并不是和刚才一样中断在<code>ExitProcess</code>，而是中断在新设置的断点<code>CreateToolhelp32Snapshot</code>：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glin0170xlj223w18aalh.jpg" alt="CreateToolhelp32Snapshot"></p>
<ul>
<li><p>根据<code>CreateToolhelp32Snapshot</code>的用法，发现它的参数<code>Flags</code>并不是<code>TH32CS_SNAPHEAPLIST或TH32CS_SNAPMODULE</code>二者中的任何一个，那么它的所有参数将被忽略，所以，在这里它会获取所有进程的快照，并返回快照的句柄供其他 API 调用；</p>
</li>
<li><p>接着，<code>Ctrl + F9</code>执行到返回，在<code>EAX</code>中有一个返回值，那么它是不是一个句柄呢？去<code>句柄窗口</code>看看：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glinbepny1j223w18agw9.jpg" alt="句柄窗口有"></p>
<p>可以看到，<code>句柄窗口</code>有一个相同的句柄，结果不言而喻；</p>
</li>
</ul>
</li>
<li><p>继续运行程序，程序再次中断，这次是中断在<code>Process32First</code>：</p>
<ul>
<li><p>可以看到，它要获取的第一个进程的句柄是<code>hSnapshot = 00000038</code>，而它的第二参数是一个指向进程详细信息的指针，<code>数据窗口</code>中跟随一下：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glinqanwu2j223w18a7g3.jpg" alt="数据窗口中跟随"></p>
</li>
<li><p>接着<code>Ctrl + F9</code>执行到返回，可以看到，它获取到了信息并且信息一致：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glinyuh2a7j223w18adrl.jpg" alt="信息一致"></p>
</li>
</ul>
</li>
<li><p>接着运行程序，程序中断在<code>FindWindowA</code>，而它给定的参数是<code>Class = &quot;OllyDbg&quot;</code>:</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glio46o1fgj223w18aal6.jpg" alt="FindWindowA"></p>
<ul>
<li><p>根据<code>FindWindowA</code>的用法<code>如果有指定的类名或窗口标题则表示成功返回一个窗口的句柄；否则返回零；</code>，如果接下来<code>Ctrl + F9</code>执行到返回后，<code>EAX</code>是非零的值，是不是意味着找到了与<code>Class = &quot;OllyDbg&quot;</code>指定的类名匹配的窗口，并且拿到了它的句柄？</p>
</li>
<li><p>先来看看<code>OD</code>的类名与标题是什么，这里要借助一个软件<code>Greatis WinDowse</code>：</p>
<p><code>Greatis WinDowse</code>需要安装；<br><code>Greatis WinDowse</code>的用法是：将鼠标悬停在需要检测的窗口的标题栏即可；</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1gliohjwd8hj223w18a4ax.jpg" alt="类名与标题"></p>
<p>可以看到，检测到的标题与窗口标题完全一致，那类名不言而喻；</p>
</li>
<li><p>接下来<code>Ctrl + F9</code>执行到返回后，发现<code>EAX</code>里的确有一个非零的值，如何证明它就是<code>OD</code>的句柄呢，再次打开<code>Greatis WinDowse</code>：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glioowr26nj223w18atk6.jpg" alt="OD的句柄"></p>
<p>检测到的句柄与<code>EAX</code>的值完全相同，那<code>OD</code>可就危险了；</p>
</li>
</ul>
</li>
<li><p>到了这里，如果继续运行程序，肯定会获得一个程序结束的大礼包，有继续运行程序冲动的同学需要加强学习了，既然拿到了<code>OD</code>的句柄，也就是生杀大权，那么，应该跟着它，看看它拿着句柄要干什么？So，<code>F8</code>单步执行程序：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glip4qbaopj223w18adqa.jpg" alt="来到了这里"></p>
<p>程序来到了这里，先不要执行代码，观察一下，如果没有猜错，下面的<code>ExitProcess</code>就是刚运行程序设置的第一个断点调用的位置；</p>
<ul>
<li><p>再来查看一下代码，前三行，两个比较一个跳转，既然找到了与指定类名相同的窗口，那么句柄也就是<code>EAX</code>肯定不为 0，所以第三行的跳转一定会成立；</p>
</li>
<li><p>紧接着看看下面两个跳转，除了起始位置不同，都完美的跳过了<code>ExitProcess</code>：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glipb954ibj21qs0ms76z.jpg" alt="两个跳转"></p>
</li>
<li><p>当然，以上都只是推论，代码并没有执行，如何证实推论？当然是将句柄也就是<code>EAX</code>置 0：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glipi6u5eaj223w18agwj.jpg" alt="EAX置0"></p>
</li>
<li><p>然后继续<code>F8</code>单步执行程序，果不其然，程序跳过了<code>ExitProcess</code>，来到了<code>lstrcmpA</code>：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glipmnmpjrj223w18ak2t.jpg" alt="字符串比较"></p>
<p>用获取到的第一个进程的标题名和给定字符串做比较；</p>
</li>
<li><p>继续向下执行，逻辑瞬间清晰：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1gliptoxivij223w18a4aj.jpg" alt="逻辑清晰"></p>
<p>至此，终于理清了它反调试的套路：</p>
<ol>
<li>首先使用<code>CreateToolhelp32Snapshot</code>获取进程快照；</li>
<li>接着使用<code>Process32First</code>获取进程快照第一个进程的句柄；</li>
<li>然后使用<code>FindWindowA</code>获取给定类名或标题的进程的句柄，如果获取成功，则使用句柄关闭这个程序的所有进程及线程；</li>
<li>如果使用<code>FindWindowA</code>获取失败，则通过<code>Process32First</code>获取的第一个进程的标题与给定字符串进行比较，相同则关闭这个程序；</li>
<li>如果第一个进程的信息比较不相同，则使用<code>Process32Next</code>获取进程快照的下一个进程，并用其标题与给定字符串比较，相同则关闭程序，不同则取下一个，直到进程快照中的所有进程比较完毕；</li>
</ol>
</li>
</ul>
</li>
<li><p>既然已经跳过了这个程序对<code>OD</code>的检测，是不是意味着现在可以看到最开始的弹窗呢？禁用所有断点并运行程序：<br><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1gliqg4s2qtj223w18ak0o.jpg" alt="弹窗"></p>
<p>完工！</p>
</li>
<li><p>不不不，没有完工，既然知道了这个程序的反调试原理，如何绕过呢，不能每次都手动吧？这里需要借助一个<code>OD</code>补丁程序<code>re-pair</code>：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1gliqwryra2j223w18an8v.jpg" alt="补丁程序"></p>
<p>补丁程序会生成了一个名称随机的<code>OD</code>主程序，试试效果如何：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glir28rxr6j223w18a4ap.jpg" alt="完工啦"></p>
<p>再多句嘴，插件<code>HideDebugger</code>虽然也有<code>FindWindow/EnumWindows</code>选项，但只能绕过标题名检测，无法绕过类名检测：</p>
<p><img data-src="https://ww1.sinaimg.cn/large/7ed7d3dfly1glir6m957bj223w18awqt.jpg" alt="HideDebugger"></p>
<p>这次是真的完工了！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（二）</title>
    <url>/post/1165783651/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
<li>参考教程：<code>反调试之检测进程名</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>本次内容是学习完毕之后脑海里的回放，原因无他，不了解 Windows API，不知道每个函数的具体作用以及是否需要特别关注，所以，只能跟着大佬学习思路以及 Windows API；</p>
</li>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhnceosakj30aq07ot8q.jpg" alt="打开软件"></p>
<p>既然是学习反调试，那么注册码当然不是重点，重点是它对<code>OD</code>的影响，打开<code>OD</code>，发现闪了一下然后被关闭了，嗯，反调试了；</p>
<p>还有一个现象就是：给<code>OD</code>改个名后，就不会被反调试了，即使是<code>OD</code>载入程序并运行，也不会被反调试；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先，<code>Ctrl + N</code>查看 API 列表，API 很多，搜索<code>GetProcAddress</code>设置 CC 断点；</p>
<ul>
<li><p>了解一下 Windows API <code>GetProcAddress</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetProcAddress</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定的动态链接库中的输出库函数地址；</span><br><span class="line">    （获取函数列表中不显示且被调用的隐藏函数的地址；）</span><br><span class="line">    （捕捉间接加载或调用的其他隐藏函数；）</span><br><span class="line">参数</span><br><span class="line">    hModule：包含此函数的 DLL 模块的句柄；</span><br><span class="line">    （程序的句柄）</span><br><span class="line">    IpProcName：包含函数名的以 NULL 结尾的字符串；</span><br><span class="line">    （程序的名字）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>接着，<code>F9</code>运行程序，程序会在设置断点的 API 上中断多次，每中断一次，都代表获取了一个隐藏的函数；</p>
</li>
<li><p>在大约中断了 143 次后，对接下来获取到的 3 个重要的 API 设置 CC 断点：<code>EnumProcesses</code>、<code>EnumProcessesModules</code>、<code>GetModuleBaseNameA</code>；</p>
<ul>
<li><p>国际惯例，分别了解一下这几个 API ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnumProcesses</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索进程列表中每一个进程的标识符；</span><br><span class="line">    （枚举进程的 PID；）</span><br><span class="line">    （获取进程列表所有进程的 PID；）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnumProcessesModules</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定进程中每个模块的句柄；</span><br><span class="line">    （获取进程的基址；）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetModuleBaseNameA</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索指定模块的基本名称；</span><br><span class="line">    （获取进程名；）</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置断点的方法：</p>
<p>程序中断后，在<code>堆栈窗口</code>确认是需要的 API 后，在函数名称所在行右键菜单选择复制到剪贴板，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqpoeyaqj31ff0u013m.jpg" alt="复制"></p>
<p>接着<code>Ctrl + F9</code>执行到返回，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqqvhbvhj31ff0u0n80.jpg" alt="执行到返回"></p>
<p>然后<code>bp EAX</code>设置断点，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqrzoin0j31ff0u0qf2.jpg" alt="设置断点"></p>
<p>在断点窗口双击断点进入汇编窗口，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqrsjy18j31ff0u0n6k.jpg" alt="断点窗口"></p>
<p>在注释栏双击并粘贴复制的函数名，也就是给断点设置备注，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqtz1wgmj31ff0u0gxm.jpg" alt="注释"></p>
<p>断点设置完成；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhqupj78mj31ff0u0gum.jpg" alt="注释完成"></p>
<p>至于为什么要设置备注，如果有 10 个没有设置备注的断点，那就傻傻分不清了；</p>
</li>
</ul>
</li>
<li><p>这里不得不提一下 PID，它的全称是<code>Process ID</code>，通俗易懂嘛，<code>进程 ID</code>；</p>
<ul>
<li><p>至于怎么查看 PID，打开任务管理器，选择<code>进程</code>列，就显示了当前所有程序的诸如程序名、PID、用户名等等信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrn2d1q8j30mc0vcq46.jpg" alt="任务管理器"></p>
<p>而我们使用的<code>OD</code>也赫然在列；</p>
</li>
<li><p>当然，如果你的进程列表中没有 PID 这一列，不要慌，你的电脑没问题，点击菜单栏中的<code>查看</code>按钮并选择<code>选择列</code>选项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrqp0c07j30me0v8t9y.jpg" alt="选择列"></p>
</li>
<li><p>然后勾选<code>PID</code>复选框并确定，你的进程列表中就有 PID 这一列了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhrsbmu0qj30mc0v6jst.jpg" alt="复选框"></p>
</li>
</ul>
</li>
<li><p>了解并知道如何查看 PID 之后，就要进入正题了：</p>
<p>以我的机器为例，<code>OD</code>的 PID 是<code>1380</code>，这是一个 10 进制数，要在<code>OD</code>里使用它，当然要转换为 16 进制：</p>
<p>进制转换的方法很多，比如使用网页提供的进制转换器，使用系统内置的计算器，使用<code>OD</code>自带的进制转换，这里以<code>OD</code>为例：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhs12msd7j30d408qjrf.jpg" alt="16进制"></p>
<p>随便双击一个寄存器，然后修改它的<code>无符号</code>值，<code>十六进制</code>栏就会显示对应的 16 进制数，这里<code>OD</code>的 PID 对应的 16 进制数就是<code>00000564</code>；当然，修改寄存器的值只是为了进制转换，一定不要点击确定哦；</p>
</li>
<li><p>设置好 3 个函数的断点后，继续运行程序，程序会再次中断，不过，不再是中断在<code>GetProcAddress</code>，而是中断在新设置的第一个断点，也就是<code>EnumProcesses</code>：</p>
<ul>
<li><p>我们已经了解了<code>EnumProcesses</code>的功能：获取进程列表所有进程的 PID；</p>
</li>
<li><p>既然<code>EnumProcesses</code>不需要参数，那么堆栈窗口<code>ESP + 4</code>的位置，存储的就是它的返回值，数据窗口中跟随一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhssuz2luj31ff0u0k33.jpg" alt="数据窗口"></p>
</li>
<li><p>接着<code>Ctrl + F9</code>执行到返回，发现以基址为起始位置的部分地址的内容被覆盖了，而<code>OD</code>的 PID 也在其中：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhsu51my1j31ff0u0n90.jpg" alt="od16"></p>
</li>
</ul>
</li>
<li><p>既然是要了解反调试对<code>OD</code>的影响，当然要跟随<code>OD</code>的数据了，在<code>OD</code>的 PID 上设置<code>内存访问断点</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhsx5pxacj31ff0u013l.jpg" alt="内存访问断点"></p>
</li>
<li><p>继续运行程序，程序再次中断，一眼就看到了<code>OD</code>的 PID 被当作参数传递给了函数<code>OpenProcess</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhtbacm5dj31ff0u0gx2.jpg" alt="参数"></p>
<ul>
<li><p><code>OpenProcess</code>这个函数的作用是什么呢，了解一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知 PID 获取程序的句柄；</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>OD</code>危险了，因为这个<code>CrackMe</code>拿到了它的句柄，也就是它的生杀大权；</p>
</li>
<li><p><code>F8</code>单步步过执行程序，看看是否如是：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhthr6mxdj31ff0u0al0.jpg" alt="拿到句柄"></p>
<p>因为函数的返回值一般都在<code>EAX</code>，所以我们大胆猜测，<code>EAX</code>中应该就是<code>OD</code>的句柄，如何证明呢？去<code>句柄窗口</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhtm3151xj31ff0u0tjy.jpg" alt="句柄窗口"></p>
<p><code>句柄窗口</code>中有一个数值相同的句柄，而这个函数是用来获取句柄的，又把<code>OD</code>的 PID 当作了参数，那么它返回的应该就是<code>OD</code>的句柄，所以可以确定，<code>EAX</code>中就是<code>OD</code>的句柄也就是<code>000000C4</code>;</p>
</li>
</ul>
</li>
<li><p>继续运行程序，程序再次中断，来到了我们设置的三个函数断点中的其二，也就是<code>EnumProcessesModules</code>：获取指定进程的基址</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvdso10zj31ff0u0wpw.jpg" alt="获取基址"></p>
<p>在数据窗口中跟随存放函数执行结果的地址，然后<code>Ctrl + F9</code>执行到返回后，可以发现<code>OD</code>的基址是<code>00400000</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvfcc0plj31ff0u0ams.jpg" alt="基址"></p>
</li>
<li><p>继续<code>F9</code>运行程序，程序再次中断，这次是<code>GetModuleBaseNameA</code>：</p>
<p>执行到返回发现，它通过进程和基址获取到了<code>OD</code>的名称：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvrs35erj31ff0u0dr0.jpg" alt="名称"></p>
</li>
<li><p>接下来就不能直接<code>F9</code>运行程序了，因为再运行下去程序可能就结束了，所以使用<code>F8</code>单步执行，看看它获取了进程名之后要做什么：</p>
<ul>
<li><p>咦，又一个把<code>OD</code>句柄当作参数传递的函数，了解一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhvyuodhhj31ff0u0n8h.jpg" alt="close"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CloseHandle</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过已知对象的句柄关闭句柄；</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续执行后，去<code>句柄窗口</code>查看，已经找不到<code>OD</code>的句柄了，说明它被关闭了；</p>
</li>
<li><p>接着向下运行，发现一个把<code>OD</code>的名称当作参数的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhw42p6njj31ff0u0n8g.jpg" alt="名称"></p>
<p>使用<code>F7</code>步入跟进后，发现它是将<code>OD</code>的名称转换为 UpperCase，紧跟着下一个函数把转换后的名称和给定字符进行了比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwc8u9y2j31ff0u07g5.jpg" alt="比较"></p>
</li>
<li><p>上一步执行完毕后，由于比较的结果相同，跳转失败，程序又重新通过<code>OpenProcess</code>使用<code>OD</code>的 PID 获取了<code>OD</code>的句柄：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwl1yxpvj31ff0u0tkk.jpg" alt="重新获取"></p>
</li>
<li><p>接着，把<code>OD</code>的句柄作为参数传递给<code>TerminateProcess</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glhwpt69mlj31ff0u0k2p.jpg" alt="句柄当做参数"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TerminateProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    通过进程句柄终止指定进程及其所有线程；</span><br></pre></td></tr></table></figure>

<p>了解了这个 API 的用途后，继续运行程序，结果不言而喻：灵光一闪，程序关闭！</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之反调试（四）</title>
    <url>/post/3209676884/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><code>OD</code>插件<code>HideDebugger</code>和<code>HideOD</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
<li>参考教程：<code>反调试之ZwQueryInformationProcess</code>；<a id="more"></a>

</li>
</ul>
<h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li><p>本节内容理解不是很透彻，也没有以往的<code>链式操作</code>：也就是初始找到切入点，然后根据切入点确定下一步的操作，只能跟随大佬的教程去理解、操作，同时查询微软官方文档，本次使用的 API<code>ZwQueryInformationProcess</code>未来可能会弃用，所以目前暂不做深入研究，有需要之时再做深入；</p>
</li>
<li><p>这次使用的反调试 API 很独特：它本身的设计初衷应该是用作异常处理，但却被<code>CrackMe</code>的作者用在了验证方面，不得不说，这位高人对 API 理解的很透彻，很独到，同时也提醒了我，反向思维很重要；</p>
</li>
<li><p>这里就说说本次使用的 API：<code>SetUnhandledExceptionFilter</code>、<code>UnhandledExceptionFilter</code>、<code>ZwQueryInformationProcess</code>；</p>
<ul>
<li><p>先来说说第二个 API <code>UnhandledExceptionFilter</code>：</p>
<p>这是官方文档的描述：</p>
<blockquote>
<p>An application-defined function that passes unhandled exceptions to the debugger, if the process is being debugged. Otherwise, it optionally displays an Application Error message box and causes the exception handler to be executed. This function can be called only from within the filter expression of an exception handler.</p>
</blockquote>
<p>对这段文档的理解：通过判断当前进程是否正在被调试，如果正在被调试，就把异常交给调试器，如果没有，就把异常交给进程的 UnhandledExceptionFilter 处理；</p>
<p>这里就不禁产生了一个疑问：如何判断当前进程是否正在被调试？</p>
</li>
<li><p>再来看第三个 API <code>ZwQueryInformationProcess</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZwQueryInformationProcess</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    检索有关指定进程的信息</span><br><span class="line">参数</span><br><span class="line">    ProcessInformationClass：要检索的过程信息的类型</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在官方说明的开始有这么一段话：</p>
<blockquote>
<p><code>[ZwQueryInformationProcess may be altered or unavailable in future versions of Windows. Applications should use the alternate functions listed in this topic.]</code></p>
</blockquote>
<p>意思是：这个 API 可能会在未来的 Windows 版本中被更改或弃用，若要开发应用，请使用本文列出的其他替代 API。</p>
</li>
<li><p>这个 API 的第二参数<code>ProcessInformationClass</code>：<code>要检索的过程信息的类型</code>，本身有很多可选的值，而<code>ProcessDebugPort，值是 7</code>是我们关注的重点：</p>
<blockquote>
<p>Retrieves a DWORD_PTR value that is the port number of the debugger for the process. A nonzero value indicates that the process is being run under the control of a ring 3 debugger.</p>
</blockquote>
<p>意思是：检索四子节长度的值，该值是该进程的调试器的端口号。非零值表示该进程正在 Ring 3 调试器的控制下运行。</p>
<p>也就是说，调用这个函数，在把第二参数设置为<code>7</code>的情况下，只要返回非零值就表示我们正在调试程序，很好很强大，同时也解释了在学习上一个 API 时留下的疑惑；</p>
</li>
</ul>
</li>
<li><p>最后来看看第一个 API <code>SetUnhandledExceptionFilter</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SetUnhandledExceptionFilter</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">    设置异常捕获函数</span><br><span class="line">参数</span><br><span class="line">    lpTopLevelExceptionFilter：指向顶级异常处理函数的指针，只要 UnhandledExceptionFilter 函数获得控制权且未在调试过程，该指针就会被调用</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这是官方对 API 的说明；</p>
<blockquote>
<p>Enables an application to supersede the top-level exception handler of each thread of a process.</p>
</blockquote>
<blockquote>
<p>After calling this function, if an exception occurs in a process that is not being debugged, and the exception makes it to the unhandled exception filter, that filter will call the exception filter function specified by the lpTopLevelExceptionFilter parameter.</p>
</blockquote>
</li>
<li><p>这是官方对参数<code>lpTopLevelExceptionFilter</code>的说明，请自行理解；</p>
<blockquote>
<p>A pointer to a top-level exception filter function that will be called whenever the UnhandledExceptionFilter function gets control, and the process is not being debugged. A value of NULL for this parameter specifies default handling within UnhandledExceptionFilter.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>学习完这三个 API，说说自己的理解：</p>
<ol>
<li><p><code>SetUnhandledExceptionFilter</code>可以为异常设置处理函数，参数<code>lpTopLevelExceptionFilter</code>指向自定义的异常处理函数，但要触发这个函数，必须满足一个条件：<code>UnhandledExceptionFilter</code>被调用；</p>
</li>
<li><p>同时，要想<code>UnhandledExceptionFilter</code>被调用，也得满足两个条件：程序没有被调试，并且这个异常没有被处理；</p>
</li>
<li><p>当同时满足以上条件时，就会触发自定义的异常处理函数来处理异常；</p>
</li>
<li><p>那么，程序是如何检测程序是否被调试呢？那就要用到<code>ZwQueryInformationProcess</code>了，也就是说，本次的反调试主角其实是<code>ZwQueryInformationProcess</code>（虽然它就要被弃用了）；</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>下面开始进入正题：</p>
<ul>
<li><p>打开<code>CrackMe</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzea2h39j30h807uaa4.jpg" alt="打开软件"></p>
<p>很常规的软件，随便输入内容并点击 Check 后，没有任何反馈；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<p>既然已经学习了需要的 API，那就不用去 API 窗口看了，直接给三个函数设置断点并做好备注：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzq6vknpj31ff0u012b.jpg" alt="设置断点并做好备注"></p>
<p>其实地址栏已经显示了地址对应的 API 名称，不过无法保证任何时候都会显示，况且，做备注是一个好的习惯，不是吗？</p>
<p>同时需要先禁用<code>ZwQueryInformationProcess</code>断点，否则程序会多次中断，但不会中断在理想的位置，况且按照对 API 的理解，只有<code>UnhandledExceptionFilter</code>调用它的时候才会检测程序是否被调试，所以，在<code>UnhandledExceptionFilter</code>出现后再启用也为时不晚；</p>
</li>
<li><p>接着<code>F9</code>运行程序，程序会中断在<code>SetUnhandledExceptionFilter</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1gljzxn8v3hj31ff0u0tkf.jpg" alt="SetUnhandledExceptionFilter"></p>
<p>同时，根据 API 说明，它的参数指向自定义异常处理函数，那么就在它的参数地址上设置断点，看看我们是否会触发这个自定义函数；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk01ign7fj31ff0u0484.jpg" alt="参数设置断点"></p>
</li>
<li><p>继续运行程序，程序窗口会弹出，输入内容并点击 Check 后，程序再次中断，这次是中断在了<code>UnhandledExceptionFilter</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk05cb5zxj31ff0u0k39.jpg" alt="UnhandledExceptionFilter"></p>
<p>其实，细心的同学一眼就看到了它调用了另一个 API <code>ZwQueryInformationProcess</code>；</p>
<p>既然它都要调用<code>ZwQueryInformationProcess</code>了，那我们就需要去启用<code>ZwQueryInformationProcess</code>断点了；</p>
</li>
<li><p>激活<code>ZwQueryInformationProcess</code>断点并运行程序，程序会再次中断：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0bobp81j31ff0u04ag.jpg" alt="ZwQueryInformationProcess"></p>
<p>可以看到，<code>堆栈窗口</code>中，它的第二参数<code>InfoClass=7</code>，那就说明它本次执行的目的就是检测程序是否正在被调试，而它的第三参数<code>Buffer=0012F5E4</code>则存放的是返回值，<code>数据窗口</code>中跟随一下；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0htm7h8j31ff0u0wq1.jpg" alt="数据窗口"></p>
<p>事实上，我们确实正在调试这个这个程序，那我们就看看它的返回值是否是非零值；</p>
</li>
<li><p>既然要看它的返回值，那就不能直接运行程序了，<code>Ctrl + F9</code>执行到返回，同时查看<code>数据窗口</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0sudvwnj31ff0u0wpw.jpg" alt="执行到返回"></p>
<p>果然，返回值是一个非零值，也就说检测到正在调试程序；</p>
<p>既然检测到了正在调试程序，如何触发自定义的异常处理函数呢？当然是将返回值置 0；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk0xlkckij31ff0u0k2k.jpg" alt="置0"></p>
<p>选中返回值用 00 填充，直接修改也是可以的；</p>
</li>
<li><p>既然已经修改了返回值，也就是绕过了检测，那么<code>ZwQueryInformationProcess</code>断点也就没用了，禁用<code>ZwQueryInformationProcess</code>断点并运行程序，程序会中断在：为<code>SetUnhandledExceptionFilter 的参数</code>设置的断点位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk14tbrvij31ff0u0n9e.jpg" alt="参数断点"></p>
</li>
<li><p>毫无悬念了，这里就是用来验证的关键代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2bmg6nqj31ff0u0wqc.jpg" alt="验证"></p>
<p>把我们输入的内容进行一系列操作之后，去和一个指定的内容做比较；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2h1fpwqj31ff0u0n8f.jpg" alt="比较"></p>
<p>到这里就可以理解为什么点击 Check 之后没有任何反馈了，是因为验证失败后没有任何操作；</p>
<p>既然已经知道会跳转到失败，如何看到成功的弹窗呢？当然是修改<code>ZF</code>标志位，让<code>JNZ</code>不成立：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2n9tg0jj31ff0u0k2k.jpg" alt="修改"></p>
<p>继续向下执行，期待已久的成功弹窗：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk2rmsxwmj31ff0u0146.jpg" alt="成功"></p>
</li>
<li><p>既然已经知道了它的反调试原理，但又不想每次都手动修改，那该如何绕过能，这里需要借助插件：<code>HideDebugger</code>和<code>HideOD</code>，设置如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk39bp648j31ff0u0qeb.jpg" alt="插件"></p>
<p>无图无真相：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwly1glk3e9o4irj31ff0u07g4.jpg" alt="无图无真相"></p>
<p>插件的作用就是永远保持<code>ZwQueryInformationProcess</code>的参数为<code>7</code>时的返回值为 0；</p>
</li>
<li><p>总结：不得不说，能人背后有能人，这波操作很清奇，也就是说：如果从事物的多个角度去观察，去思考，可能会有不一样的理解与收获；</p>
<p>期待自己早日变得更加强大，加油 💪💪💪❗️</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之断点</title>
    <url>/post/2731277808/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版；</li>
<li>简称<code>OD</code>；</li>
</ul>
<a id="more"></a>

<h4 id="断点的分类"><a href="#断点的分类" class="headerlink" title="断点的分类"></a>断点的分类</h4><h5 id="F2-断点"><a href="#F2-断点" class="headerlink" title="F2 断点"></a>F2 断点</h5><ul>
<li><code>F2断点</code>又叫<code>普通断点</code>、<code>CC断点</code>、<code>int3断点</code>；</li>
<li>在<code>OD</code>反汇编窗口（<code>C</code>窗口）中，双击语句的某一行或按下 F2 会设置（触发）一个<code>int3 断点</code>；</li>
<li><code>int3</code>是一个断点（中断）指令，在汇编中机器码是<code>CC</code>，所以，<code>F2断点</code>又可以称为<code>int3断点</code>或<code>CC断点</code>；</li>
<li>在使用 F2 设置断点后，CPU 会引发一个异常，而 OD 会捕获这个异常，从而中断程序；</li>
<li>可以使用命令<code>bp xxxxxxxx</code>快速设置一个<code>CC断点</code>；</li>
<li><code>bp</code>可以为内存地址设置断点，也就是为某条语句设置断点；</li>
<li><code>bp</code>当然也可以为<code>API（函数）</code>设置一个断点，如<code>bp MessageBoxA</code>，断点会设置在 API 的行首，也就是函数的第一行；</li>
<li>通常情况下，当使用<code>bp</code>为<code>API</code>设置断点时，该<code>API</code>应该是可见的，也就是在反汇编窗口按下<code>Ctrl + N</code>后，在函数窗口能找得到时，才能使用<code>bp</code>设置断点，不过偶尔在找不到的情况下，也能使用<code>bp</code>设置断点，这种情况时可以买一注彩票；</li>
<li>使用<code>bp MessageBoxA</code>也就是为<code>API</code>设置断点后，会在系统领空下，这个<code>API</code>的行首设置断点；</li>
<li>使用<code>bpx MessageBoxA</code>也就是为<code>API</code>设置断点后，会在程序领空下，所有调用这个<code>API</code>的位置设置断点；</li>
<li><code>F2断点</code>的设置没有数量限制，可以设置无数个；</li>
<li><code>F2断点</code>很容易被检测，从而触发反调试；</li>
<li><code>F2断点</code>重载程序后不会丢失；</li>
</ul>
<h5 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h5><ul>
<li><code>内存断点</code>是通过修改内存属性为不可访问、不可执行来实现的；</li>
<li><code>内存断点</code>同时只能存在一个；</li>
<li><code>内存断点</code>在重载程序后会丢失，需要重新设置；</li>
<li><code>内存断点</code>会影响程序的运行速度；</li>
</ul>
<h5 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h5><ul>
<li><code>硬件断点</code>最多可以设置 4 个；</li>
<li><code>硬件断点</code>在设置位置的下一条指令中断；</li>
<li>可以使用命令<code>HE xxxxxxxx</code>快速设置一个<code>硬件断点</code>；</li>
<li>可以使用命令<code>HE MessageBoxA</code>在<code>API</code>的行首快速设置一个<code>硬件断点</code>；</li>
</ul>
<h5 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h5><ul>
<li>满足某个条件的<code>CC断点</code>;</li>
<li>使用<code>shift + F2</code>快速设置条件断点；</li>
</ul>
<h5 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h5><ul>
<li>和条件断点类似，多了记录日志等功能，更加详细的设置条件；</li>
<li>使用<code>shift + F4</code>快速设置条件断点；</li>
</ul>
<h5 id="API-断点"><a href="#API-断点" class="headerlink" title="API 断点"></a>API 断点</h5><ul>
<li>给系统提供的 API 设置的<code>CC断点</code>；</li>
<li><code>MessageBoxA</code>中的<code>A</code>表示使用<code>ASCII</code>编码；</li>
<li><code>MessageBoxW</code>中的<code>W</code>表示使用<code>Unicode</code>编码；</li>
</ul>
<h5 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h5><ul>
<li>消息断点实际上就是条件记录断点；</li>
<li>在操作窗口或控件时，都会发送一个消息；</li>
<li>在<code>OD</code>的<code>W</code>窗口刷新来获取交互消息；</li>
<li>检测交互（消息循环）来设置<code>消息断点</code>，如<code>101 按键抬起</code>、<code>202 鼠标左键抬起</code>等；</li>
<li>断点生效后，修改条件来记录操作日志，在<code>OD</code>的<code>L</code>窗口查看记录的日志或将日志输出到指定文件来进一步进行分析；</li>
</ul>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>断点</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（一）</title>
    <url>/post/2293324257/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy1j9yekwj30oc065t9q.jpg" alt="分析"></p>
<p>就是它了，选中它并右键<code>在输入函数上切换断点</code>，然后去<code>断点窗口（B 窗口）</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后运行程序，“随便输入”一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序停在了设置断点的<code>API</code>的行首，在堆栈窗口可以看到<code>API</code>的各种参数，而参数<code>Buffer</code>里存放着函数返回的数据，选中<code>Buffer</code>右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy267st5oj30t00drq4u.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下<code>Ctrl + F9</code>或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现<code>Buffer</code>对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下<code>F7 或 F8</code>，返回到调用<code>API</code>的程序，发现接下来将要执行的代码很可疑：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy2kqa9a0j30sz0dt0uo.jpg" alt="程序"></p>
<p>一个比较，一个跳转，并且文字显示和序列号有关；</p>
</li>
<li><p>分析一下这几行可疑的代码：</p>
<ul>
<li><p><code>MOV EDX,CrackMe.00403008</code>将<code>00403008</code>这个地址拷贝到<code>EDX</code>，执行一下这行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy2xlpyn3j308805374d.jpg" alt="EDX"></p>
<p>在<code>EDX</code>存放的地址中发现一串可疑字符串，选中<code>EDX</code>右键<code>数据窗口中跟随</code>，原来可疑字符串只是前面几位，而后面那几个字符是我们输入的字符；</p>
</li>
<li><p><code>MOV EBX,DWORD PTR DS:[403010]</code>将<code>00403010</code>这个地址中的数据的前四个字节拷贝到<code>EBX</code>，执行一下这行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy3ehrs27j30as0ay3zf.jpg" alt="EBX"></p>
<p>既然<code>EBX</code>中存放的是数据，而数据又看不懂，怎么知道是什么呢？<code>OD</code>很强大，选择那行代码并右键<code>数据窗口中跟随，然后选择内存地址</code>或者在数据窗口选中那行代码的数据并选择<code>数据窗口中跟随地址</code>就可以看到<code>EBX</code>中存放的内容了，原来是我们输入的“序列号”；</p>
</li>
<li><p><code>CMP EBX,DWORD PTR DS:[403008]</code>这行代码就没什么好说的了，减法比较是否相等，还使用了一个障眼法，<code>EDX</code>放地址，<code>EBX</code>放数据，在这里再取出<code>EDX</code>的数据进行比较；</p>
</li>
<li><p><code>JE SHORT CrackMe.00401087</code>这行也没啥说的，<code>JE</code>根据<code>ZF 标志位</code>进行跳转，而如果上一步的计算结果为<code>0</code>，则<code>ZF</code>为<code>1</code>，<code>JE</code>跳转成立，也就是说，如果<code>EDX</code>和<code>EBX</code>中的数据相同，那么序列号就是对的，<code>JE</code>跳转并向下执行，最后弹出<code>正确！</code>，反之则不跳转向下执行，弹出<code>序列号错误！</code>，看来第一步中发现的可疑字符串就是真正的序列号了；</p>
</li>
<li><p>如果想要输入啥都能通过验证，那么可以将<code>JE</code>改为<code>JMP</code>无条件跳转，保存修改到文件就获得了一个新的程序；</p>
</li>
<li><p>但我们的目的是找出真正的序列号，所以嘛，复制那串字符去试一下，果然，一切如我们所料！</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（二）</title>
    <url>/post/3097998650/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy5o1g2gpj30g90bwjsq.jpg" alt="函数"></p>
<p>很好的开始，在<code>GetDlgItemTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy5y9rif4j30sr0fsq51.jpg" alt="运行"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，哇，密密麻麻全是汇编语句，往下翻了翻，也没发现什么关键字、有用的信息，接着<code>F9</code>运行，直接弹出了错误信息：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy69uwm08j303z03z0sn.jpg" alt="弹窗"></p>
</li>
<li><p>看来此路不通啊，但是“程序给我们关上了一扇门，同时又开了一扇窗”，没错，就是它，弹窗，在最开始的函数列表中也有它的身影<code>MessageBoxA</code>，那就从它入手试试；</p>
</li>
<li><p>禁用<code>GetDlgItemTextA</code>并设置<code>MessageBoxA</code>断点，重新运行程序，输入并运行程序后，拦截到了即将要弹出的信息，信息显示在堆栈窗口：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy6hpjnooj30ug0i0wgm.jpg" alt="错误"></p>
<p>如果程序继续运行，将弹出<code>错误！</code>弹窗；</p>
</li>
<li><p>堆栈窗口的顶部显示的是调用信息，包括调用地址、返回地址等</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy6m2r60qj30cw05q0t2.jpg" alt="堆栈"></p>
</li>
<li><p>堆栈顶端，也就是当前<code>ESP</code>指向的堆栈中则是调用地址，也就是说这个地址调用了<code>MessageBoxA</code>这个<code>API</code>，根据程序的流程：程序经过比较之后，发现序列号不对，所以调用<code>MessageBoxA</code>并弹出错误窗口。<br>按照这个逻辑，如果跟随调用地址，是不是就能找到程序进行比较的代码？那还等什么，右键堆栈顶端的地址（堆栈中被标注黑色背景的地址就是堆栈顶端）选择<code>反汇编窗口中跟随</code>，就来到了调用<code>MessageBoxA</code>的程序，查看上面的代码，发现了一些端倪：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy7fm1cz5j30ue0j8jur.jpg" alt="调用"></p>
<p>上面有一个<code>JNZ</code>跳转进来，从而调用了<code>MessageBoxA</code>，所以弹出了错误弹窗，而<code>JNZ</code>的下面还有一个<code>MessageBoxA</code>，那可以猜测，如果不跳转继续向下执行，很有可能弹出的就是注册成功的弹窗，<code>JNZ</code>根据<code>ZF 标志位</code>进行跳转，如果修改<code>ZF 标志位</code>为<code>1</code>，就可以验证一下猜测是否正确，如何修改呢，继续往上翻代码，嘿嘿，发现一个有用的东西<code>GetDlgItemTextA</code>，在调用地址双击数据窗口设置<code>CC断点</code>，重载程序</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy84b4uhoj30uc0j7acn.jpg" alt="重载"></p>
</li>
<li><p>输入并运行程序后，在最后设置断点的地方停了下来，那下面就是要执行的代码了，分析一下看能不能找到隐藏的序列号：</p>
<ul>
<li><p>才分析了几行代码，有一种上了恶当的感觉，感觉它在转移某些内容，就暂且将它转移的内容称为“可疑字符串”：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy8q1uc0zj30p50740ts.jpg" alt="序列号"></p>
</li>
<li><p>不管了，继续分析，依然没有收获：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy90t76crj30om05zjrs.jpg" alt="没有收获"></p>
</li>
<li><p>直到分析了一个轮回，终于有了收获，程序会用我们输入的序列号的每一个字节的机器码减 14 后，和指定的机器码进行比较：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy9zbazz5j30p10ac75f.jpg" alt="循环"></p>
</li>
<li><p>而我们利用<code>MessageBoxA</code>断点，分析的<code>JNZ</code>的跳转条件是：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyb22if59j30p10hewgy.jpg" alt="JNZ"></p>
</li>
<li><p>如何让条件成立呢？恰恰在我们没有分析到的代码，因为我们输入的序列号是错误的，所以正确的代码根本不会执行，更谈不上分析了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybg7od2pj30p20acjsn.jpg" alt="正确"></p>
<p>在这里，如果是正确的序列号，那么每次比较完成后，<code>EBP - 10</code>和<code>EBP - 34</code>作为两个计数器，它们会正确的同时自增，在最后的比较长度时也就会相等了；</p>
</li>
</ul>
</li>
<li><p>所以，正确的序列号是什么呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybxcwm3ej30p00abjtb.jpg" alt="序列号"></p>
<ul>
<li>在比较的位置设置断点，获取每次比较时给定的字符的机器码，然后加上 14，最后转为 ASCII 码，就是正确的序列号；</li>
<li>获取到的给定字符的机器码：<code>1D 1E 1F 44 61 51 3C 5B 36 55 51</code>；</li>
<li>字符的机器码加 14 之后的值：<code>31 32 33 58 75 65 50 6F 4A 69 65</code>；</li>
<li>转换为 ASCII 码后的值：123XuePoJie；</li>
</ul>
</li>
<li><p>最后，完整的分析图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyciwo9jqj30y80u0tf0.jpg" alt="完整图"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（三）</title>
    <url>/post/4122547819/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><h5 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h5><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
<ul>
<li><p>这个 CrackMe 不一般，有两个部分，两个按钮，那就分两部分分析喽（这句话绕不绕）：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeer5jilj309a0740su.jpg" alt="CrackMe"></p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，咦，发现可疑函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyek762n6j30k20cgq4j.jpg" alt="第一部分"></p>
<p>很好的开始，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeq2lafej311s0kx415.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，多么令人兴奋的内容，这么简单吗，会不会有诈？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyeumc7cqj30m60bbmyl.jpg" alt="第一部分找到了"></p>
</li>
<li><p>那就分析一下，看看到底是啥：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyf5uv9tsj30nc0b1gms.jpg" alt="第一部分结束"></p>
<p>看来第一部分很简单，逻辑简单粗暴，只要不对直接弹出错误；<br>第一部分到此结束。<br>既然第一部分这么简单，那难点肯定在第二部分，去看看！</p>
</li>
</ul>
</li>
</ol>
<h5 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h5><ul>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，还是那个可疑的函数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfexxb79j30kc0cmabo.jpg" alt="第二部分"></p>
<p>很好的开始，在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>程序断在了设置断点的 API 的行首，在堆栈窗口可以看到 API 的各种参数，而参数 Buffer 里存放着函数返回的数据，选中 Buffer 右键<code>数据窗口中跟随</code>，可以看到，由于断点中断在了函数的第一行，所以这个地址里什么也没有：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfhdwjazj311o0l076u.jpg" alt="Buffer"></p>
</li>
<li><p>接着按下 Ctrl + F9 或点击菜单栏的调试选项并选择<code>执行到返回</code>，然后发现 Buffer 对应的地址里有数据了，并且是我们输入的字符串；</p>
</li>
<li><p>在上一步中，我们<code>执行到返回</code>，那就意味着接下来登场的将会是<code>RETN</code>了，按下 F8，返回到调用 API 的程序，哦豁，好像没啥有用的内容，等等，下面还有个<code>GetWindowTextA</code>，对对，我们输入了用户名和密码，那就得获取两次，而第一次获取的是密码，那就<code>F9</code>再运行程序；</p>
</li>
<li><p>是的，又获取了一次，而这次获取的是用户名，执行到用户代码，果然是下面这个<code>GetWindowTextA</code>，那下面就是比较的代码了呗，毕竟它位于获取和弹窗之间；</p>
</li>
<li><p>那就分析一下它的流程：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyfxtvb0yj30ng0ecq43.jpg" alt="开始"></p>
<ul>
<li><p>第一行<code>TEST EAX, EAX</code>不迷茫，<code>TEST EAX, EAX</code>表示检查<code>EAX</code>自身是否为 0，而第二行的<code>JE SHORT 硬编码寻.0040167E</code>指向了一个<code>MessageBoxA</code>，那就说明<code>EAX</code>很重要，既然弹窗提示的是<code>必须输入用户名才可以</code>，那它不是用户名的长度是什么，况且<code>EAX</code>里的数据刚好和用户名长度相同；</p>
</li>
<li><p>接下来，它对用户名做了一系列的运算，并把运算的结果放到了指定的内存中，暂时还不知道它想干嘛：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyh5fsj3gj30ox082753.jpg" alt="用户名"></p>
</li>
<li><p>同样的，又对输入的假序列号进行了一系列运算，并把运算结果放到了指定的内存中，不过相对于用户名，序列号的处理比较简单，只是进行了除法运算，并存储了余数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyh8v4k4vj30oz05faah.jpg" alt="假码"></p>
</li>
<li><p>直到序列号运算完毕，一个<code>JMP</code>跳下来，分析之后，终于知道了它要干什么：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyhc0gpmtj30oy08ddgr.jpg" alt="比较"></p>
<p>原来，它上面进行的一系列运算，是为这一步的比较做准备；</p>
</li>
<li><p>至此，终于分析出了结果：这里没有硬编码，而是软编码，序列号是根据用户名计算出来的</p>
</li>
<li><p>至于计算的规则：</p>
<ul>
<li><p>用户名的运算规则：用户名的下标从零开始，每个字节依次和<code>A</code>进行除法运算，然后用余数和下标异或之后的值加 2；</p>
</li>
<li><p>序列号的运算规则：序列号的每个字节和<code>A</code>进行除法运算，然后用余数和用户名运算的结果进行比较；</p>
</li>
<li><p>序列号的算法：任意数字和<code>A</code>进行乘法运算，并加上用户名每个字符运算的结果就是这个用户名对应的序列号，运算的结果必须可以转为<code>ASCII</code>码中的数字；</p>
</li>
<li><p>例如：</p>
<ul>
<li><p>用户名： yang</p>
</li>
<li><p>运算的结果：03 08 04 02</p>
</li>
<li><p>序列号算法：<code>5 * A + 3 = 35</code> <code>4 * A + 8 = 30</code> <code>5 * A + 4 = 36</code> <code>5 * A + 2 = 34</code></p>
</li>
<li><p>转成 ASCII：5064</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyhyvwfqlj30d2074aaa.jpg" alt="成功"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（五）</title>
    <url>/post/755681865/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；</li>
</ul>
<a id="more"></a>

<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻还真不少，善用搜索，<code>GetDlgItemTextA</code>没找到，那就试试<code>GetWindowTextA</code>，还真有，就它了，在<code>GetWindowTextA</code>上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p><code>F9</code>运行程序，然鹅，输入内容并点击验证按钮后，程序并没有暂停；</p>
</li>
<li><p>界面有按钮，试试消息断点，还是没用，又尝试<code>硬件断点</code>以及<code>内存断点</code>均无效之后，只能去翻大佬的教程，以下内容是学习了<a href="http://xuepojie.com/"><code>Shark恒</code></a>大佬的教程之后自己的总结；</p>
</li>
<li><p>使用一个特殊的<code>API：TranslateMessage</code>，没错，它的功能就是字面的意思<code>翻译虚拟按键消息为字符消息</code>，很好很强大；</p>
</li>
<li><p>在<code>API</code>列表页面搜索，还真有，设置断点，然后在<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，还没有完，在断点上右键<code>断点&gt;&gt;条件记录</code>或者<code>Shift + F4</code>（也就是<code>条件记录断点</code>，毕竟<code>API断点</code>的本质就是<code>CC断点</code>），修改条件：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjea06qzj311u0nfad3.jpg" alt="TranslateMessage"></p>
</li>
<li><p>然后运行程序，输入并点击验证，程序在<code>TranslateMessage</code>函数的行首暂停下来，然后<code>Ctrl + F9</code>或者点击菜单栏的调试选项并选择<code>执行到返回</code>，然后<code>F8</code>单步执行到程序领空；</p>
</li>
<li><p>然后在<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，搜索输入的序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjv4k2qij311w0ngn0d.jpg" alt="查找"></p>
<p>找到最接近<code>输入的序列号</code>的内容，设置<code>内存访问断点</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizjz6z1umj311m0n7tc9.jpg" alt="内存访问断点"></p>
</li>
<li><p>运行程序，程序暂停在了读取序列号的地方，开始分析：<br>好聪明的“程序”，开始转移数据了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizk98xwaej313w0ncdis.jpg" alt="转移数据"></p>
</li>
<li><p>既然它都挪窝儿了，咱也别闲着了：在<code>EDI</code>上右键选择<code>数据窗口中跟随</code>,果然，输入的序列号在这里了，选择序列号的数据右键<code>断点&gt;&gt;删除内存访问断点</code>删除第一次设置的<code>内存访问断点</code>，也可以理解为设置在<code>ESI</code>上的<code>内存访问断点</code>，既然数据都转移了，断点也就没意义了，所以要重新设置在<code>EDI</code>上，再次选择序列号的数据右键<code>断点&gt;&gt;内存访问</code>，这样就实时掌握了输入的序列号的动向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizko5erudj31450o7gpl.jpg" alt="EDI"></p>
</li>
<li><p>继续运行程序，终于来到来最关键的地方：比较</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizlfw3ua4j313q0s4dky.jpg" alt="比较"></p>
<p>分析完毕，逻辑简单粗暴：</p>
<ul>
<li>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>最后，恢复寄存器的内容并<code>RETN</code>，直接弹出错误的弹窗；</li>
</ul>
</li>
<li><p>分析的时候已经发现了正确的序列号，也就是可疑字符串，试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizm3afyiyj30am0btacd.jpg" alt="完工"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（六）</title>
    <url>/post/1208254864/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><code>OD</code>插件：<code>中文搜索引擎</code>和<code>ApiBreak</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>【歪坑牌 CM2.2】来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li><a href="http://xuepojie.com/"><code>Shark恒</code></a>大佬教了一种方法，但中间部分内容需要经验判断，才疏学浅的我一直不明白，经过多次失败后总结出了属于自己的方法，So，设置断点的思路来源于大佬，分析的过程属于自己；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
<ul>
<li><p>这个软件的操作有点不同寻常，填写内容之后会提示注册成功，并且通过重启来验证是否正确：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ctzk1nmj30vq089dh5.jpg" alt="流程"></p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻还真不少，搜索一下，<code>GetDlgItemTextA</code>没找到，那就试试<code>GetWindowTextA</code>，还真有，在<code>GetWindowTextA</code>上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p><code>F9</code>运行程序，输入并点击登录之后，还是熟悉的弹窗，点击弹窗的确定按钮之后，嘿，又回到了解放前，这让我很困惑，难道它是在弹窗之后运行吗？毫无头绪；</p>
</li>
<li><p><code>TranslateMessage</code>呢？没有 Buffer，无从下手；</p>
</li>
<li><p>给<code>MessageBox</code>设置断点？皮，它都重启了，断点有什么*用，逆推呢？设置断点跟随之后发现没有什么有价值的内容；</p>
</li>
<li><p>试一试<code>内存断点</code>，暂停的地方不重要而且在断点位置无限循环，根本连登录按钮都点不了，既然都没有登录肯定没有验证，断点的地方当然不重要了；</p>
</li>
<li><p>试试<code>消息断点</code>，暂停了，但没有 Buffer，无从下手；</p>
</li>
<li><p>试试<code>中文搜索引擎</code>，跟了很久，一无所获；</p>
</li>
<li><p>至于<code>硬件断点</code>，一直不懂它的工作原理，不敢乱用，说白了就是用不明白；</p>
</li>
<li><p>既然自己搞不定，关了它放弃又不是我的性格，那还能怎么样？<code>量力而行，虚心请教</code>，以下内容是学习之后的总结：</p>
<ul>
<li><p>原来，<code>中文搜索引擎</code>不只是找关键字的，之前的用法只是个皮毛，还可以找到其它有用的信息，而恰恰这才是重点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0e6c5pycj312m0ksmzu.jpg" alt="关注点"></p>
</li>
<li><p>如果看到<code>software</code>说明这个程序使用了注册表，而关键信息可能就存储在注册表中：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ear0vunj31220kyjsu.jpg" alt="注册表"></p>
</li>
<li><p>既然它将输入的内容存储在注册表中，那么验证的时候一定会去注册表取回内容，所以这个节点才是关键的环节，重载程序，删除之前设置的无用断点，接下来就是重点了；</p>
</li>
<li><p>至于如何设置断点呢，那就要使用今天的主角儿了<code>ApiBreak</code>，点击菜单栏的插件选项并选择<code>ApiBreak &gt;&gt; API断点</code>，然后选择<code>注册表</code>以及<code>RegQueryValueExA</code>选项之后，点击确定;(翻译一下<code>RegQueryValueExA</code>：<code>Reg</code>是注册表，<code>Query</code>是查询，<code>Value</code>是值，<code>ExA</code>是 16 进制，连起来应该是<code>设置查询注册表16进制值的断点</code>，不知道对不对)</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0eovwbz4j312m0kv77d.jpg" alt="设置断点"></p>
<p>当然，也可以直接使用系统 API<code>RegQueryValueExA 或 RegQueryValueExW</code>来设置断点，这个插件就是简化了操作步骤，不用我们去寻找系统 API；</p>
</li>
<li><p>设置好断点之后，运行程序，程序会中断多次，应该是查询了很多次，但我们的关注点只是两个：<code>用户名</code>和<code>密码</code>，那就继续运行程序，直到在堆栈窗口看到需要的信息：</p>
<p><code>用户名</code>出现了两次，第一次<code>Buffer</code>中没有地址，第二次<code>Buffer</code>中才有地址，第二次才是我们关注的重点， 在<code>Buffer</code>上右键<code>数据窗口中跟随</code>，然后<code>Ctrl + F9</code>执行到返回，果然，它获取了我们输入的用户名：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0f4rlxcbj312j0kttc1.jpg" alt="用户名"></p>
<p>同样的情况也会出现在<code>密码</code>身上，继续运行程序，获取密码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0fbu0phrj312i0kvgp0.jpg" alt="密码"></p>
</li>
<li><p>既然它已经获取了用户名和密码，那就上正菜吧：<br>获取密码后，在<code>Buffer</code>上右键<code>数据窗口中跟随</code>，然后<code>Ctrl + F9</code>执行到返回，果然，它获取了我们输入的密码，在<code>数据窗口</code>选中密码数据右键<code>断点 &gt;&gt; 内存访问</code>设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0fkgngw7j312k0kqdi4.jpg" alt="内存访问断点"></p>
</li>
<li><p>然后继续运行程序，程序中断了，但看了看代码发现这里不是重点，而且继续运行还会中断，数一数，中断的次数刚好是密码的长度，并且每运行一次，<code>ESI寄存器</code>中存储的密码都会向后移动一位；</p>
</li>
<li><p>继续运行程序，程序再次中断，重点来了，开始分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1rveiykej312e0rfwj6.jpg" alt="分析完毕"></p>
<p>分析完毕，逻辑似曾相识的感觉，没错，和<code>逆向分析之硬编码寻找序列号（五）</code>中的逻辑一模一样：</p>
<ul>
<li>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步；</li>
<li>最后，恢复寄存器的内容并<code>RETN</code>，然后弹窗，最后回到解放前；</li>
</ul>
</li>
</ul>
</li>
<li><p>分析完了，那真正的密码是什么呢？当然就是“可疑字符串”：一串看起来杂乱无章的字符，那密码的计算规则又是什么呢？</p>
<p><code>RETN</code>返回的地方永远是调用它的位置的下一行，那如果跟着<code>RETN</code>是不是就能找到调用它的地方，结果是肯定的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0laiieabj312h0rfadz.jpg" alt="调用"></p>
<p>如果<code>JNZ</code>是返回的位置，那上面一行的<code>CALL</code>就是调用的地方，如何证明呢？很简单，<code>JNZ</code>根据<code>ZF 标志位</code>跳转，如果跳转肯定就注册失败了，那不跳转是不是就成功了？试一试，将<code>ZF 标志位</code>置 1，然后运行程序，正如所料，注册成功：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0lezrrqtj30bi067t8s.jpg" alt="注册成功"></p>
<p>这就说明，这个<code>CALL</code>很重要，给<code>CALL</code>的位置设置断点，重载程序，程序在<code>CALL</code>的位置暂停，既然<code>CALL</code>内部是判断，那上面很可能就是获取并处理了，既然正确的密码是一串杂乱无章的字符，那么它应该需要一个<code>CALL</code>去处理，所以，大胆的猜测一下，上面那个<code>CALL</code>可能就是处理程序，给上面那个<code>CALL</code>也设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0lu3l9iuj312g0rfq7j.jpg" alt="处理"></p>
<p>再次重载程序，程序中断，<code>F8</code>向下执行，查看中间那两行代码干了什么，很有可能就是判断<code>CALL</code>（也就是函数）的参数：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0m4afip8j312g0rh78w.jpg" alt="参数"></p>
<ul>
<li>两行代码执行后，<code>EAX</code>的数据在<code>寄存器窗口</code>看的很清楚，就是我们输入的假码；</li>
<li>而<code>EDX</code>的数据是什么呢？选中<code>EDX</code>右键<code>数据窗口中跟随</code>，数据一目了然，正是比较时用的可疑字符串；</li>
<li>这也就证明了，上面那个<code>CALL</code>就是处理数据用的；</li>
<li>而密码的规则：在好多个<code>CALL</code>之间跳来跳去分析之后，发现是一串固定的字符串加上用户名的 16 进制表示；</li>
<li>如：<code>yang</code>转换成 16 进制是<code>79616E67</code>，那么密码就是<code>€队蠹易仿耄79616E67</code>；</li>
</ul>
</li>
<li><p>测试一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0mxfxvr3j30v508p758.jpg" alt="测试"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之硬编码寻找序列号（四）</title>
    <url>/post/1116999438/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><code>OD</code>插件：<code>中文搜索引擎</code>；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a> 来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><p>事实证明：不能“以貌取人”。</p>
<p>刚打开软件的时候，心里还想着，这么简陋？分分钟就逆向完毕了，结果，“啪啪啪”实力打脸，针扎的疼。</p>
<p>嗯，还在学习阶段，等我功力深厚之时，定会找回场子！</p>
<ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，翻了翻，呀呵，看着简陋，用的<code>API</code>还真不少，那就搜索吧，没有<code>GetDlgItemTextA</code>？那就拿<code>GetWindowTextA</code>下手吧：在<code>GetWindowTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，“随便输入” 一些字符后点击验证，可以随便输入，但请记住它；</p>
</li>
<li><p>居然没有断下来，也没有弹窗，这让我很尴尬：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8frx378j305905zglj.jpg" alt="尴尬"></p>
</li>
<li><p>嗯，界面有按钮，那就试试消息断点，熟练的设置好<code>消息断点</code>，运行程序，输入，点击按钮，还是没有断下来；</p>
</li>
<li><p>不怕，还有<code>内存断点</code>、<code>硬件断点</code>，挨个试了一遍之后，没有一个成功的，灰心丧气呀，怎么像刺猬 🦔 一样无从下手？</p>
</li>
<li><p>等等，看了看程序的界面，猛的想起了大佬说的一个工具：</p>
<p><code>中文搜索引擎</code>：这玩意儿可以参考，但不要过分依赖，友好的开发者可能只是关闭你的程序不让你调试，至于不友好的，知道为啥要用虚拟机吗？</p>
</li>
<li><p>重载程序，在<code>反汇编窗口</code>右键选择<code>中文搜索引擎</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8ldzoguj311o0njq5w.jpg" alt="中文搜索引擎"></p>
<p>然后<code>Ctrl + F</code>搜索熟悉的字眼儿<code>Wrong Code DUDE</code>，果然有，双击来到<code>反汇编窗口</code>，嘿嘿，这里看起来很重要嘛：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8xso4qtj30m90by402.jpg" alt="关键"></p>
<ul>
<li>一个失败的字样；</li>
<li>一个成功的字样；</li>
<li>紧挨着上面有一个跳转：可以猜测，如果跳转的话，可能就显示成功了；</li>
<li>跳转上面是一个<code>CALL</code>，那它很可能是比较的<code>CALL</code>；</li>
<li>至于更上面的代码，那肯定是获取用的呗，瞎猜的；</li>
</ul>
</li>
<li><p>既然找到了可疑的代码，那就双击<code>CALL</code>给它下一个<code>CC断点</code>，然后运行程序，输入序列号点击验证后，程序暂停在了<code>CALL</code>的位置，那就<code>F7</code>进<code>CALL</code>看看，验证一下猜测；</p>
</li>
<li><p>刚一进<code>CALL</code>，就在寄存器窗口发现了熟悉的字样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz99kl1svj311n0nlgoq.jpg" alt="call"></p>
<p>既然把“序列号”都传进来了，那应该就是比较了，开始分析：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizaftudazj30xb0u0n15.jpg" alt="分析"></p>
</li>
<li><p>分析完成，比较的部分是常规方法，就是中断程序有点麻烦！</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>硬编码</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之软编码寻找序列号（一）</title>
    <url>/post/4167455493/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0t1wtpivj308z0anmxb.jpg" alt="开始"></p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>接着按下<code>Ctrl + N</code>查看使用了哪些<code>API</code>，用的<code>API</code>不多，一眼就看到了<code>GetDlgItemTextA</code>，在<code>GetDlgItemTextA</code>函数上设置断点，然后去<code>断点窗口</code>双击断点进入<code>反汇编窗口</code>给断点设置备注，这是一个好的习惯，请保持；</p>
</li>
<li><p>然后<code>F9</code>运行程序，输入用户名和注册码，点击确定；</p>
</li>
<li><p>程序断下来了，在堆栈窗口选择<code>Buffer</code>右键<code>数据窗口中跟随</code>，没有数据，因为断点在行首，<code>Ctrl + F9</code>或者点击菜单栏调试选项，选择<code>执行到返回</code>，再去数据窗口中看看，有数据了，是我们输入的用户名；</p>
</li>
<li><p>再次运行程序，程序再次中断，不出意外应该是获取注册码，在堆栈窗口选择<code>Buffer</code>右键<code>数据窗口中跟随</code>，没有数据，<code>Ctrl + F9</code>或者点击菜单栏调试选项，选择<code>执行到返回</code>，再去数据窗口中看看，有数据了，是我们输入的注册码；</p>
</li>
<li><p>能获取到数据就是一个好的开始，<code>F7 或 F8</code>单步执行到程序领空，熟悉的字样映入眼帘：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tc5u51bj312e0t3q6p.jpg" alt="程序领空"><br>既有我们输入的内容，也有提示字样，应该就是这里了，那就开始分析；</p>
</li>
<li><p>前面的代码是堆栈平衡和清除弹窗的代码，进<code>CALL</code>之后，直接<code>ALT + F9</code>或者点击菜单栏调试选项，选择<code>执行到用户代码</code>；</p>
</li>
<li><p>需要分析的代码来了：刚分析了两行，发现了几行特别的代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tni2rn6j30oy03hmxm.jpg" alt="发现"></p>
<p>这几行代码，一个<code>push</code>然后紧跟着一个<code>CALL</code>，而且 push 的是我们输入的内容，这里应该就是关键了；</p>
</li>
<li><p><code>F7</code>进第 1 个<code>CALL</code>看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tswn8jfj30ox01owee.jpg" alt="用户名call"></p>
<ul>
<li><p>刚进来第 1 行代码有困惑的吗？你咋知道是用户名放入<code>ESI 寄存器</code>？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0tvmwgxqj312j0satc7.jpg" alt="第一行"></p>
<p>很简单，<code>[ESP+4]</code>告诉我的，<code>ESP 寄存器</code>永远指向堆栈的顶端，那<code>[ESP+4]</code>就是下一行喽，看一眼堆栈窗口，第二行的数据不正是我们输入的用户名吗？</p>
</li>
<li><p>接着，出现了第 2 处令人疑惑的代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0xi158x1j312n0b0q4t.jpg" alt="疑惑1"></p>
<p>机器码和<code>41</code>比较，这到底是啥意思？刚开始我也弄不明白，而且后面的逻辑也显示和<code>41</code>半毛钱关系没有，直到无意中在用户名输入了数字，弹出两次<code>注册失败</code>，才好像明白了这里判断的是啥？我们先看看 16 进制的<code>41</code>到底是什么：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0xochjx2j30b50bs3ys.jpg" alt="41"></p>
<p>原来<code>41</code>是大写字母<code>A</code>，而后面的<code>5A</code>则是大写字母<code>Z</code>，那我好像明白怎么回事儿了，它应该是在判断用户名是否是英文字母；</p>
</li>
<li><p>当字符的机器码大于<code>41</code>并且大于<code>5A</code>时，程序会跳转到一个新的<code>CALL</code>，那它干了什么呢：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0y7pkvqij312l0sc432.jpg" alt="新CALL"></p>
<p>可以看到，这里只有 3 行代码，我们分析一下，小写字母的机器码减去<code>20</code>是什么，没错，是对应的大写字母，这三行代码的作用就是：将用户名转换为大写字母，然后用大写字母替换用户名中的小写字母，然后返回：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0z4k7ifkj312m0sbn3m.jpg" alt="大写"></p>
<p>当用户名全部转为大写字母之后，又来到了一个<code>CALL</code>，这个<code>CALL</code>又是干什么的呢，<code>F7</code>跟进去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0zamesrsj312k0sbwic.jpg" alt="新CALL"></p>
<p>原来，是将转换为大写字母后的用户名的每个字节的机器码累加在一起，然后和<code>5678</code>异或，并把异或后的结果放入<code>EAX</code>并返回：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0zluaydsj312k0se0xd.jpg" alt="返回"></p>
</li>
</ul>
</li>
<li><p>用户名处理完了，接下来就是注册码了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ztl37fnj30oy03daa7.jpg" alt="比较"></p>
<p>刚从用户名的连环<code>CALL</code>里出来就这么刺激吗？把用户名运算后的结果和我们输入的注册码都 push 到了这个<code>CALL</code>里面，这里应该就是比较了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj10dmcv8zj30ox06cwey.jpg" alt="注册码"></p>
<p>结果很打脸啊，不是验证<code>CALL</code>而是运算注册码的<code>CALL</code>，而第一行的<code>PUSH EAX</code>只是个入栈而已。。。</p>
</li>
<li><p>验证环节</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj10q4hzwfj30k6063wf9.jpg" alt="验证"></p>
<p>根据<code>CALL</code>跳转的位置，轻松知道它的用途；</p>
</li>
<li><p>注册码的计算规则：</p>
<ul>
<li>用户名必须是字母；</li>
<li>将每个字母转为大写字母；</li>
<li>把每个字母的 16 进制累加在一起；</li>
<li>累加的结果与 5678 异或；</li>
<li>异或后的结果与 1234 异或；</li>
<li>将最后的结果转为 10 进制，注册码就出来啦；</li>
</ul>
</li>
<li><p>无图无真相</p>
<ul>
<li><p>例如：<code>yang</code>的大写<code>YANG</code>的 16 进制是<code>59 41 4E 47</code>；</p>
</li>
<li><p>加在一起是<code>59 + 41 + 4E + 47 &gt;&gt; 12F</code>；</p>
</li>
<li><p><code>12F</code>与<code>5678</code>异或<code>xor 12F, 5678 &gt;&gt; 5757</code>；</p>
</li>
<li><p><code>5757</code>与<code>1234</code>异或<code>xor 5757, 1234 &gt;&gt; 4563</code>；</p>
</li>
<li><p><code>4563</code>转为 10 进制后<code>17763</code>;</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj119l81wcj30b50csdg7.jpg" alt="上图"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之软编码寻找序列号（三）</title>
    <url>/post/2238585999/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<ul>
<li><p>这是一个类似于蜘蛛纸牌的程序，需要安装，安装完成打开之后会提示输入注册码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2whju29rj310e0so0sw.jpg" alt="开始"></p>
</li>
<li><p>输入用户名和 6 位数字的注册码之后，发现<code>Ok</code>按钮无法点击：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wjvydm4j30ad07i746.jpg" alt="按钮"></p>
<p>有点意思，看来只有输入正确的序列号按钮才能点击，至于为啥注册码是 6 位数字，它不是已经说明了吗？</p>
</li>
</ul>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>猜测一下它的工作原理，如果在输入正确的注册码之后按钮可以点击，那就说明它会实时获取我们输入的内容并进行判断，这样的话，有用的应该就是<code>内存断点</code>了；</p>
</li>
<li><p>说干就干，既然要去内存中找我们输入的内容，那输入就一定得个性一点，起码不是内存中常见的，不然一找一大堆就无从下手了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wrgno31j309q06zmx1.jpg" alt="输入"></p>
</li>
<li><p>然后去<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，输入我们的序列号点击确定开始查找，记得勾选<code>区分大小写</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wtnjbibj30b806dglh.jpg" alt="查找"></p>
</li>
<li><p>输入的还算奇葩，只找到了一个：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wwddjlcj319s0rgaap.jpg" alt="查找结果"></p>
</li>
<li><p>设置<code>内存访问断点</code>，既然它都告诉我们是 6 位了，那就设置 6 个字节：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2wytjh8dj319r0rct9e.jpg" alt="设置断点"></p>
</li>
<li><p>然后去程序界面再输入一个字符后，发现程序中断了，回到<code>OD</code>看看，嘿，它居然在转移数据，在数据窗口跟随一下<code>EDI</code>，果然是我们输入的假序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2x6v1zckj319p0qoq3v.jpg" alt="转移数据"></p>
</li>
<li><p>既然数据都挪窝儿了，那之前的断点也就没用了，选择<code>EDI</code>的数据右键<code>断点 &gt;&gt; 内存访问</code>重新设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xbtwkjcj319q0qmq3p.jpg" alt="新断点"></p>
</li>
<li><p>断点设置好之后，<code>F9</code>继续运行程序，程序再次中断，发现又在挪窝儿？怎么回事儿，挪窝儿这么快乐吗？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xgb4q4mj319p0rc3zj.jpg" alt="又一个断点"></p>
<p>重新设置<code>内存访问断点</code>，然后继续运行程序；</p>
</li>
<li><p>程序再次中断，并且有比较有跳转，这儿可能就是重点了，分析一下：</p>
<ul>
<li><p>第 1 行是：<code>EAX</code>的前 4 字节数据拷贝到<code>EDX</code>，<code>F7</code>单步执行，然后查看一下是什么东西：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xsh9gtlj319o0qnwfg.jpg" alt="查看EAX"></p>
<p>原来是我们输入的假序列号，前面还多了个<code>04</code>，应该是长度吧；</p>
</li>
<li><p>第 2 行是：<code>EDX</code>的前 4 字节数据拷贝到<code>EBX</code>，<code>F7</code>单步执行，然后查看一下是什么东西：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xx6m4ydj319o0qnab0.jpg" alt="查看EDX"></p>
<p>嘿嘿，一串可疑的数字，而且是 6 位，和序列号的规则很吻合，而且前面多了个<code>06</code>，应该也是长度；</p>
</li>
<li><p>接着往后分析，逻辑很常规，比较完前四个字节比较长度，都不相等就返回了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2y4ynby5j319s0qlgmp.jpg" alt="返回"></p>
</li>
</ul>
</li>
<li><p>结局没有悬念，用户名对应的序列号就是那串数字，不过，序列号是如何计算出来的呢？我们接着分析：</p>
<ul>
<li><p>我们都知道<code>RETN</code>返回的是调用位置的下一行，那跟着<code>RETN</code>去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2yc0ugkuj319u0qngml.jpg" alt="RETN"></p>
<p>按照程序的流程，既然这里是判断，那上面的就是获取和处理了，上面<code>CALL</code>不少，哪一个才是我们想要的那个呢，按照先获取后处理的流程来看，离我们最近的那个<code>CALL</code>应该是处理用的，但<code>CALL</code>上面那行代码看着也不像是给它传递参数，那就在这个<code>CALL</code>上设置断点，进去看看它是干嘛的；</p>
</li>
<li><p>设置好断点，重载程序并运行程序之后，程序都没有加载完成就中断了，既然都没有输入，那肯定不行啦，<code>F9</code>运行程序，起码运行到我们能输入内容；</p>
</li>
<li><p>然后，我们发现，输入用户名的时候，每输入一个字符都会中断一次，那就说明断点有效，虽然不知道这个<code>CALL</code>具体是干嘛的，但肯定和用户名有关，既然每次都中断，那就输入一次运行一次呗，直到用户名输入完成，还没有完，为了防止它没有完全获取用户名（鬼知道它是怎么获取的，万一是运行之后获取呢？），在输入完用户名最后一个字符之后，程序会再次中断，我们再运行程序一次，在序列号一栏中，输入一个字符，发现它中断了；</p>
</li>
<li><p>管它呢，反正用户名输入完了，也在序列号一栏输入字符了，能保证它获取了完整用户名就行，至于它是干啥的，<code>F7</code>进去看看不就知道了：</p>
<ul>
<li><p>刚分析了几行，发现它用同样的方法转移用户名，既然要知道序列号是怎么计算的，那肯定要跟着用户名喽，给<code>EDI</code>中的用户名数据设置<code>内存访问断点</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj2z03oif9j31ay0qqgmf.jpg" alt="用户名"></p>
</li>
<li><p>接着，<code>F9</code>运行程序，程序跳转到了这里，果然，这里就是用来生成序列号的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj30aheyyqj31az0qomy7.jpg" alt="小循环"></p>
<p>这里是一个完整的小循环，用来运算用户名的每一个字符，并且把结果累加，至于运算规则：</p>
<ul>
<li><p>字节下标从 1 开始；</p>
</li>
<li><p>字节机器码和下标相乘；</p>
</li>
<li><p><code>IMUL DWORD PTR DS:[EDX*4+4EB5D8]</code>这行代码中的所有特殊字符：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
<p>从上面的表格可以看出，用户名最大不能超过 16 进制的 14 位，也就是 10 进制的 20 位，代码中也一直和 14 做比较，当然，这是我的猜测，有兴趣的同学可以试试；</p>
</li>
<li><p>然后字节机器码和下标相乘的结果，和表格中对应下标的字符相乘；</p>
</li>
<li><p>接着，把每个字符运算的结果累加；</p>
</li>
<li><p>就这？这么简单？想多了；</p>
</li>
</ul>
</li>
<li><p>接着往下看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj30sq2vhsj31au0qn3zk.jpg" alt="余数"></p>
<p>在上一步，也就是那个小循环中，按照特定的规则运算了用户名的每一个字节，并把每个字节的运算结果进行累加，然后才是这一步，规则如下：</p>
<ul>
<li><p>上一步累加的最终结果和<code>A 的 6 次方</code>进行求余运算；</p>
</li>
<li><p>如果余数大于<code>A 的 5 次方</code>，进行下一步，也就是开始计算序列号，至于为什么要有这么个规定，如果你还记得序列号的规则，那就不会有什么疑惑了，因为只有余数大于<code>A 的 5 次方</code>，才能计算出 6 位数的序列号，看到这句话，是不是已经想到如何计算序列号了，追随你的心，是的，就是那样计算的；</p>
</li>
<li><p>如果余数小于<code>A 的 5 次方</code>，那么就重复执行上一步中的小循环，只不过，这一次的计算结果会累加在上一次计算的最终结果上，也就是，你只需要计算一个完整小循环，如果计算的结果求余<code>A 的 6 次方</code>小于<code>A 的 5 次方</code>，只需要把你计算的最终结果乘以 2，就是下次循环的计算结果，如果乘以 2 的结果求余<code>A 的 6 次方</code>还是小于<code>A 的 5 次方</code>，那就乘以 3 呗，以此类推；</p>
</li>
<li><p>不要急，下面就开始计算序列号了；</p>
</li>
</ul>
</li>
<li><p>接着，就到了计算序列号的<code>CALL</code>:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj31e7p4jlj31ay0qmjsg.jpg" alt="计算序列号"></p>
<ul>
<li>这一步很简单，用累加结果求余<code>A 的 6 次方</code>，然后就是计算序列号的函数了；</li>
<li>到重点了，当然是<code>F7</code>进去看看喽；</li>
</ul>
</li>
<li><p>进<code>CALL</code>之后，你会很惊讶，因为真正的计算就简简单单几行代码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj31patcpxj31au0qk75i.jpg" alt="计算"></p>
<ul>
<li>用累加结果求余<code>A 的 6 次方</code>后的余数对<code>A</code>进行求余运算；</li>
<li>然后判断商是否为 0，不是 0 ，继续对<code>A</code>进行求余运算，直到商为 0；</li>
<li>把每次对<code>A</code>求余运算的余数加上 30 存起来；</li>
</ul>
</li>
<li><p>还没有结束，最后一步就是把上一步的结果逆序，然后就是真正的序列号了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj3278binyj31au0qmdh2.jpg" alt="剧终"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>啰哩啰嗦终于分析完了，总结一下注册码的生成规则：</p>
<ul>
<li><p>用户名必须小于 10 进制的 20 位，我也不确定啊，没试；</p>
</li>
<li><p>用户名字节的下标从 1 开始；</p>
</li>
<li><p>取用户名每个字节和它对应的下标进行乘法运算；</p>
</li>
<li><p>用每个字节运算的结果乘以对应下标的给定字符，给定字符如下，序号就是下标：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
</li>
<li><p>然后把每个字节乘以给定字符的结果相加；</p>
</li>
<li><p>用相加的结果求余<code>A 的 6 次方</code>，如果余数大于<code>A 的 5 次方</code>，向下执行；如果余数小于<code>A 的 5 次方</code>，用累加的最终结果乘以它的自然数倍数，如 2 倍或者 3 倍，直到最终结果求余<code>A 的 6 次方</code>的余数大于<code>A 的 5 次方</code>；</p>
</li>
<li><p>然后用上一步中的余数，也就是求余<code>A 的 6 次方</code>后的余数，对<code>A</code>进行求余运算，直到对<code>A</code>的求余运算商为 0；</p>
</li>
<li><p>把每次对<code>A</code>求余运算的余数加 30；</p>
</li>
<li><p>把余数加 30 后的数字逆序排列；</p>
</li>
<li><p>转为 10 进制就是用户名对应的序列号；</p>
</li>
</ul>
</li>
<li><p>说人话：</p>
<ul>
<li>16 进制的<code>A</code>是 10 进制的<code>10</code>;</li>
<li><code>A 的 6 次方</code>是<code>1000000</code>，也就是一百万；</li>
<li><code>A 的 5 次方</code>是<code>100000</code>，也就是十万；</li>
<li>也就是说，用户名累加的结果大于一百万的时候，这条规则才真正有意义，否则，对<code>A 的 6 次方</code>求余的余数永远是它自己；</li>
<li>至于为啥要大于<code>A 的 5 次方</code>，十万不就是最小的 6 位数吗？你不大于<code>A 的 5 次方</code>也就是不够 6 位，肯定不行喽；</li>
<li>至于对 10 求余的结果是什么，不用说了吧？</li>
<li>16 进制的<code>30</code>是什么，是 ASCII 码的<code>0</code>，所以，求余后加 0 的意义是什么？</li>
<li>总结：如果你输入的用户名运算的最终结果，转换为 10 进制是 6 位数字，那这个 6 位的数字就是注册码；如果小于 6 位，就用最终结果乘以 2 或 3 或 N，以此类推，直到是 6 位或更多位，当然，6 位最好，因为更多位需要求余 😊；</li>
</ul>
</li>
<li><p>无图无真相：</p>
<ul>
<li><p>例如：<code>crackme</code>的机器码是<code>63 72 61 63 6B 6D 65</code>；</p>
</li>
<li><p>每个字节和它对应的下标进行乘法运算：</p>
<table>
<thead>
<tr>
<th align="center">63 * 1</th>
<th align="center">72 * 2</th>
<th align="center">61 * 3</th>
<th align="center">63 * 4</th>
<th align="center">6B * 5</th>
<th align="center">6D * 6</th>
<th align="center">65 * 7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">63</td>
<td align="center">E4</td>
<td align="center">123</td>
<td align="center">18C</td>
<td align="center">217</td>
<td align="center">28E</td>
<td align="center">2C3</td>
</tr>
</tbody></table>
</li>
<li><p>用每个字节运算的结果乘以对应下标的给定字符：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D9</td>
<td align="center">63</td>
<td align="center">58</td>
<td align="center">22</td>
<td align="center">3E</td>
<td align="center">93</td>
<td align="center">F0</td>
<td align="center">08</td>
<td align="center">34</td>
<td align="center">62</td>
<td align="center">1B</td>
<td align="center">BF</td>
<td align="center">D7</td>
<td align="center">B9</td>
<td align="center">6F</td>
<td align="center">4A</td>
<td align="center">5A</td>
<td align="center">B2</td>
<td align="center">84</td>
<td align="center">24</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">63 * D9</th>
<th align="center">E4 * 63</th>
<th align="center">123 * 58</th>
<th align="center">18C * 22</th>
<th align="center">217 * 3E</th>
<th align="center">28E * 93</th>
<th align="center">2C3 * F0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">53EB</td>
<td align="center">582C</td>
<td align="center">6408</td>
<td align="center">3498</td>
<td align="center">8192</td>
<td align="center">1778A</td>
<td align="center">296D0</td>
</tr>
</tbody></table>
</li>
<li><p>把每个字节乘以给定字符的结果相加：<code>53EB + 582C + 6408 + 3498 + 8192 + 1778A + 296D0 &gt;&gt; 5D4A3</code>；</p>
</li>
<li><p>对 10 求余再加 0 之类的操作就没必要了吧；</p>
</li>
<li><p>将<code>5D4A3</code>转换成 10 进制是<code>382115</code>；</p>
</li>
<li><p>输入用户名和注册码：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj35sltkm7j30ld0gp0sz.jpg" alt="无图无真相"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析之软编码寻找序列号（二）</title>
    <url>/post/3362832349/</url>
    <content><![CDATA[<h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><ul>
<li>Ollydg1.1 原版，简称<code>OD</code>；</li>
<li><code>OD</code>汉化文件来自互联网；</li>
<li><a href="https://github.com/Undeio/undeio.github.io/releases">CrackMe</a>来自<a href="http://xuepojie.com/">学破解论坛</a>，仅供学习使用；</li>
<li>文中所有数字均是<code>HEX</code>，为了书写方便采用<code>DEC</code>；<a id="more"></a>

</li>
</ul>
<h4 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h4><ol>
<li><p>首先，打开软件到处点点，逆向一个软件起码要会用吧，不会用就没必要说逆向了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1lnjinquj307x04v0tf.jpg" alt="开始"></p>
<p>有点意思，输入内容之后没有任何提示，看来只有输入正确的序列号才会有提示；</p>
</li>
<li><p>倒入<code>OD</code>开始分析：</p>
<ul>
<li><p>首先按下<code>Ctrl + A</code>让<code>OD</code>分析一下代码；</p>
</li>
<li><p>既然界面没有按钮，那就得先猜测它的工作原理了，如果它会在输入正确之后提示的话，那么它就是实时获取我们输入的内容并进行判断，这样的话，有用的应该就是<code>内存断点</code>了；</p>
</li>
<li><p>说干就干，既然要去内存中找我们输入的内容，那输入就一定得个性一点，起码不是内存中常见的，不然一找一大堆就无从下手了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1lnjinquj307x04v0tf.jpg" alt="输入"></p>
</li>
<li><p>然后去<code>内存窗口</code>按下<code>Ctrl + B</code>或者右键选择<code>查找</code>，输入我们的序列号点击确定开始查找，记得勾选<code>区分大小写</code>：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m10r2ncj30b806e74c.jpg" alt="查找"></p>
</li>
<li><p>输入的还算奇葩，只找到了两个，选择第二个吧，虽然第一个是独立的，但它在内存中的范围不太像：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m2ueqnpj312j0nlgp6.jpg" alt="找到"></p>
</li>
<li><p>设置<code>内存访问断点</code>，长度随意，看心情，我就选 5 个字节了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1m8qdz03j312i0noadj.jpg" alt="内存断点"></p>
</li>
<li><p>然后去程序界面再输入一个字符后，发现程序中断了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mbkjvz1j312k0npgob.jpg" alt="中断1"></p>
<p>不过中断的地方好像没什么用，我们输入的内容在<code>EDX</code>中，下面的代码段并没有操作它，<code>F9</code>继续运行程序；</p>
</li>
<li><p>刚一进程序领空就发现了亮点，这里好像就是比较了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mgimi9aj312i0nljub.jpg" alt="亮点"></p>
</li>
<li><p>分析一番之后发现，逻辑很常规：</p>
<ul>
<li><p>首先，假码 和 可疑字符串 的前 4 个字节的机器码进行比较，不相等跳转到下一步；</p>
</li>
<li><p>接着，假码 和 可疑字符串 的第 1 个字节的机器码进行比较，不相等跳转到下一步</p>
</li>
<li><p>最后，恢复寄存器的内容并<code>RETN</code>，然后就杳无音讯了；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mp4qouej312g0qqdjn.jpg" alt="比较"></p>
</li>
</ul>
</li>
<li><p>至于正确的序列号，当然就是那串可疑字符串了，那这串字符是怎么来的呢，不能每次都这么找吧：</p>
<ul>
<li><p>我们都知道<code>RETN</code>返回的是调用位置的下一行，那跟着<code>RETN</code>去看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1mv3jb6bj312i0qnq6f.jpg" alt="调用位置"></p>
</li>
<li><p>按照程序的流程走，既然这里是判断，那上面的就是获取和处理了，上面有好几个<code>CALL</code>，哪一个才是我们想要的那个呢，按照先获取后处理的流程来看，离我们最近的那个<code>CALL</code>应该是处理用的，那么这个<code>CALL</code>上面那两行代码应该就是它的参数，在参数上设置断点，看看参数是什么就知道这个<code>CALL</code>的用途了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1n7mrqnaj312i0qp0w5.jpg" alt="重点"></p>
<p>设置断点，重载程序并运行后，程序中断了，但重点不在<code>反汇编窗口</code>，而是在<code>堆栈窗口</code>，我们发现了可疑字符串也就是正确的序列号，如果我们设置断点的这个<code>CALL</code>是处理函数的话，那么它还没运行怎么会出现正确的序列号呢？取消断点，在它上面那个<code>CALL</code>的参数上设置断点；</p>
</li>
<li><p>和上面的情况一样，程序中断后，在<code>堆栈窗口</code>，我们又发现了正确的序列号，再次取消断点，给它上面那个<code>CALL</code>设置断点：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1niua0lfj312g0qrgp0.jpg" alt="新断点"></p>
<p>这次就好多了，虽然没发现有用的数据但正确的序列号也没有出现，那这个<code>CALL</code>很可能就是生成序列号的函数了，<code>F7</code>跟进去看看，结果很丧气，它也不；</p>
</li>
<li><p>那就接着往上呗，终于，在设置好断点，重载并运行程序之后有了欣喜的收获，用户名当作参数传递了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1o2fra1jj312j0qowhy.jpg" alt="真的重点"></p>
<p>虽然还没有运行代码，但信息窗口已经告诉我们它是什么了；</p>
</li>
<li><p>果断<code>F7</code>跟进去看看，都失败那么多次了，不差这一次：<br><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1o7hfyf0j312h0qr0w3.jpg" alt="进CALL"></p>
<p>进来只有四行代码，但内容非常令人兴奋：这几行代码在检测有没有输入用户名；这就是一个好的开始，因为要操作数据的时候才会检测数据有没有输入；</p>
</li>
<li><p>从这个<code>CALl</code>里出来的窗口很熟悉，因为我们在这里已经操作了 3 次了，也失败了 3 次，这次将会是最后一次了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1ofq31sjj312h0qp78t.jpg" alt="多次操作"></p>
</li>
<li><p>这手灯下黑玩儿的漂亮，它一直在眼皮子底下计算序列号：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1q8fz1njj312g0qmn0r.jpg" alt="序列号运算"></p>
<p>这就完了？那序列号呢？嘿嘿，在这里：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1qc14sgtj312i0qn42d.jpg" alt="序列号"></p>
<p>是的，运算结束后，虽然数据保存到了<code>EBP-C</code>的位置，但我们并没有弹栈，所以<code>EAX</code>没有被覆盖，双击<code>EAX</code>试试，对啦，将运算结果转为 10 进制就是这个用户名对应的序列号；</p>
</li>
</ul>
</li>
<li><p>序列号的算法：</p>
<ul>
<li>用户名最少两位；</li>
<li>用户名的下标从 1 开始；</li>
<li>取用户名每个字节和它对应的下标进行异或运算；</li>
<li>所有字节异或后的结果累加在一起；</li>
<li>取最后一个字节的机器码，与对应下标进行异或运算后，循环左移 C 位；</li>
<li>然后把左移的结果和所有字节异或后累加的结果相加；</li>
<li>最后把最终结果转换成 10 进制就是这个用户名对应的注册码；</li>
</ul>
</li>
<li><p>无图无真相</p>
<ul>
<li><p>例如：用户名<code>feng</code>对应的机器码是<code>66 65 6E 67</code>；</p>
</li>
<li><p>用户名的下标从 1 开始；</p>
</li>
<li><p>每个字节分别与它对应的下标进行异或运算<code>xor 66, 1 &gt;&gt; 67</code>，<code>xor 65, 2 &gt;&gt; 67</code>，<code>xor 6E, 3 &gt;&gt; 6D</code>，<code>xor 67, 4 &gt;&gt; 63</code>;</p>
</li>
<li><p>异或后的结果累加<code>67 + 67 + 6D + 63 &gt;&gt; 19E</code>;</p>
</li>
<li><p>取最后一个字节的机器码，与对应下标进行异或运算后，循环左移 C 位<code>xor 67, 4 &gt;&gt; 63</code>，<code>ROL 63, C &gt;&gt; 63000</code>;</p>
</li>
<li><p>然后把左移的结果和所有字节异或后累加的结果相加<code>63000 + 19E &gt;&gt; 6319E</code>；</p>
</li>
<li><p>转换成 10 进制<code>6319E &gt;&gt; 405918</code>；</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1qoidbqcj30e409yq41.jpg" alt="真相"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>逆向工程</category>
        <category>汇编</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CrackMe</tag>
        <tag>逆向分析</tag>
        <tag>软编码</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
</search>
